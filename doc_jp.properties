## Ryusuke

# antonymy
axiom_Antonym1_diagnostic=対義語
# by antonymy of 'youngest' and 'oldest'
axiom_Antonym1_justification=「最年少」と「最年長」の対義語により
# antonymy
axiom_Antonym2_diagnostic=対義語
axiom_Antonym2_justification='最年少'と'最年長'が対義語であることにより# by antonymy of 'youngest' and 'oldest'
# uniqueness
axiom_Superlative1_diagnostic=一意性
# by uniqueness of the youngest
axiom_Superlative1_justification=最年小者の一意性により
# uniqueness
axiom_Superlative2_diagnostic=一意性
# by uniqueness of the oldest
axiom_Superlative2_justification=最年長者の一意性により
# ad absurdum
axiom_adabsurdium_diagnostic=背理法
# by ad absurdum reasoning
axiom_adabsurdium_justification=背理法により
# addition and subtraction
axiom_addsub_diagnostic=X = X + V - V
# by adding and subtracting {1} to {0}
axiom_addsub_justification={1}を{0}に足し引きした
# mapping
axiom_app_def_diagnostic=写像
# by definition of {0} applied to {1}
axiom_app_def_justification={0}の定義を{1}に適用
# square root
axiom_app_sqrt_bounded_diagnostic=平方根
# by applying the square root function
axiom_app_sqrt_bounded_justification=平方根を与える関数を適用
# square root
axiom_app_sqrt_diagnostic=平方根
# by applying the square root function
axiom_app_sqrt_justification=平方根を与える関数を適用
# square
axiom_app_square_bounded_diagnostic=平方
# by squaring
axiom_app_square_bounded_justification=平方をとった
# square
axiom_app_square_diagnostic=平方
# by squaring
axiom_app_square_justification=平方をとった
# mapping
axiom_apply_forall_diagnostic=全称量化子の除去
# by applying to {0}
axiom_apply_forall_justification={0}は上記の性質を持つ
# functional mapping
axiom_apply_fun_lr_diagnostic=関数写像
#! by mapping left and right sides of {0}
axiom_apply_fun_lr_justification={0}の左側と右側を写すことで
# multiplicative inverse
axiom_apply_ineq_inverse_diagnostic=乗法の逆元
#! by decrease of multplicative inverse on ℝ*
axiom_apply_ineq_inverse_justification=ℝ*における乗法逆元の減少により
# square root
axiom_apply_ineq_sqrt_diagnostic=平方根
# by applying the square root function
axiom_apply_ineq_sqrt_justification=平方根を与える関数の適用により
# square
axiom_apply_ineq_square_diagnostic=平方
# by squaring
axiom_apply_ineq_square_justification=平方をとることで
# definition
axiom_arith_def_diagnostic=定義
# by definition of an arithmetic progression
axiom_arith_def_justification=等差数列の定義により
#! functional expression
axiom_arith_pro_diagnostic=関数による表現
# by functional expression of an arithmetic progression
axiom_arith_pro_justification=等差数列の関数的表現により
# lies of swindlecants
axiom_ax_bad_diagnostic=嘘つきの嘘
#! by lies telling of swindlecants
axiom_ax_bad_justification=bylies
# truth of honestants
axiom_ax_good_diagnostic=正直者の真実
#! by truth telling of honestcants
axiom_ax_good_justification=bytruth
# definition
axiom_back_elim_equiv_diagnostic=⇔の書き換え
# by definition of equivalence
axiom_back_elim_equiv_justification=同値の定義により書き換える
!!
# double inequality
axiom_bound_conj_diagnostic=不等式の分解と合成
# by definition of double inequality
axiom_bound_conj_justification=連立不等式の定義により2
#! double inequality
axiom_bound_to_eq_diagnostic=反対称性
# by definition of double inequality
axiom_bound_to_eq_justification=連立不等式の定義により1
# double inequality
axiom_bounded_elim_diagnostic=連立不等式1
# by definition
axiom_bounded_elim_justification=定義により
# excluded middle
axiom_case_base_binary_diagnostic=排中律
# by principle of excluded middle
axiom_case_base_binary_justification=排中律の原理を適用
# by disjunction of case
axiom_case_base_diagnostic=場合分け
# by case base reasoning
axiom_case_base_justification=場合毎の推論を合わせる
# honestants or swindlecants
axiom_case_good_or_bad_diagnostic=正直者か嘘つきか
#! by disjonction of honestants and swindlecants
axiom_case_good_or_bad_justification=正直者と嘘つきの場合分けによる
# composition
axiom_comb_comp_lt_diagnostic=推移性
# by composition of inclusions
axiom_comb_comp_lt_justification=包含関係の推移性による
#! addition
axiom_combadd_diagnostic=加法
# by addition
axiom_combadd_justification=足し算による
# subtraction
axiom_combine_cmp_minus_diagnostic=減法
# by subtraction of inequalities
axiom_combine_cmp_minus_justification=不等式同士の差をとった
#! addition
axiom_combine_cmp_plus_diagnostic=加法
# by addition of inequalities
axiom_combine_cmp_plus_justification=不等式同士の和をとった
#! subtraction
axiom_combsub_diagnostic=減法
#! by subtraction
axiom_combsub_justification=差をとることで
#! commutativity
axiom_commutativity_diagnostic=可換
#! by commutativity
axiom_commutativity_justification=可換性を適用
# by conjunction
axiom_conj_diagnostic=論理積の導入
# by conjunction
axiom_conj_justification=論理積をとることで
#! binary color
axiom_deduce_not_color_diagnostic=二元色
#! by binarity of colors
axiom_deduce_not_color_justification=色の二元性により
# bijection
axiom_def_fbij_diagnostic=全単射
# by definition of a bijection
axiom_def_fbij_justification=全単射の定義により
# composition of functions
axiom_def_fcomp_diagnostic=関数の結合
# by definition of function composition
axiom_def_fcomp_justification=関数の結合の定義により
# injection
axiom_def_finj_diagnostic=単射
# by definition of an injection
axiom_def_finj_justification=単射の定義により
# involution
axiom_def_finvol_diagnostic=対合
# by definition of an involution
axiom_def_finvol_justification=対合の定義により
# surjection
axiom_def_fsurj_diagnostic=全射
# by definition of a surjection
axiom_def_fsurj_justification=全射の定義により
# antisymmetric relation
axiom_def_rantisym_diagnostic=反対称関係
# by definition of an anti-symmetric relation
axiom_def_rantisym_justification=反対称関係の定義により
# composition of relations
axiom_def_rcomp_diagnostic=関係の結合
# by definition of composition of relations
axiom_def_rcomp_justification=関係の結合の低儀により
#! functional relation
axiom_def_rfun_diagnostic=部分関数
#! by definition of a functional relation
axiom_def_rfun_justification=部分関数の定義により
# identity relation
axiom_def_rident_diagnostic=恒等関係
# by definition of the identity relation
axiom_def_rident_justification=恒等関係の定義により
#! injective relation
axiom_def_rinj_diagnostic=単射的関係
#! by definition of an injective relation
axiom_def_rinj_justification=単射的関係の定義により
# inverse relation
axiom_def_rinv_diagnostic=逆関係
# by definition of an inverse relation
axiom_def_rinv_justification=逆関係の定義により
# reflexive relation
axiom_def_rrefl_diagnostic=反射的関係
# by definition of a reflexive relation
axiom_def_rrefl_justification=反射的関係の定義により
# surjective relation
axiom_def_rsurj_diagnostic=全射的関係
# by definition of a surjective relation
axiom_def_rsurj_justification=全射的関係の定義により
# symmetric relation
axiom_def_rsym_diagnostic=対称関係
# by definition of a symmetric relation
axiom_def_rsym_justification=対称関係の定義により
# left-total relation
axiom_def_rtotleft_diagnostic=左全域的関係
# by definition of a left-total relation
axiom_def_rtotleft_justification=左全域的関係の定義により
# transitive relation
axiom_def_rtrans_diagnostic=推移的関係
# by definition of a transitive relation
axiom_def_rtrans_justification=推移的関係の定義により
# inequality
axiom_elim_comp_diagnostic=等号の付与
# by definition of inequality
axiom_elim_comp_justification=不等式の定義により1
# left deduction
axiom_elim_conj_left_diagnostic=論理積の除去(左)
# by left deduction
axiom_elim_conj_left_justification=論理積の左をとりだす
# right deduction
axiom_elim_conj_right_diagnostic=論理積の除去(右)
# by right deduction
axiom_elim_conj_right_justification=論理積の右をとりだす
# functional equality
??
axiom_elim_eqfun_diagnostic=関数の相等関係
# by definition of function equality
axiom_elim_eqfun_justification=関数の相等関係の定義により
# set equality
axiom_elim_eqset_diagnostic=集合の相等関係
# by definition of set equality
axiom_elim_eqset_justification=集合の相等関係の定義により
# parity
axiom_elim_even_def_diagnostic=偶奇性
# by definition of parity
axiom_elim_even_def_justification=偶奇性の定義により
# empty set
axiom_elim_false_exset_diagnostic=空集合
# by definition of the empty set
axiom_elim_false_exset_justification=空集合の定義により
!!
axiom_elim_gen_app_rel_diagnostic=# relational membership
!!
axiom_elim_gen_app_rel_justification=by relational membership
!!
axiom_elim_has_finite_limit_decr_diagnostic=decreasing convergence
!!
axiom_elim_has_finite_limit_decr_justification=by decreasing and reducing
!!
axiom_elim_has_finite_limit_incr_diagnostic=increasing convergence
!!
axiom_elim_has_finite_limit_incr_justification=by increasing et growing
# universe
axiom_elim_is_elem_universe_diagnostic=普遍集合
# by definition of the universe
axiom_elim_is_elem_universe_justification=普遍集合の定義により
# definition
!!
axiom_elim_multiple_diagnostic=定義elimmult
# by definition of divisibility
??
axiom_elim_multiple_justification=可除性の定義により
# by definition
axiom_elim_negation_diagnostic=否定の書き換え
# by definition of negation
axiom_elim_negation_justification=否定を書き換える
# cartesian product
axiom_elim_pprod_diagnostic=直積
# by definition of cartesian product
axiom_elim_pprod_justification=直積の定義により
# equivalence relation
axiom_elim_requiv_diagnostic=同値関係
# by definition of an equivalence relation
axiom_elim_requiv_justification=同値関係の定義
# complement
axiom_elim_scomp_diagnostic=補集合
# by definition of the complement of a set
axiom_elim_scomp_justification=補集合の定義により
# difference
axiom_elim_sdiff_diagnostic=差集合
# by definition of set difference
axiom_elim_sdiff_justification=差集合の定義により
# equivalence class
axiom_elim_sequiv_diagnostic=同値類
# by definition of an equivalence class
axiom_elim_sequiv_justification=同値類の定義により
# set inclusion
axiom_elim_set_lteq_diagnostic=包含関係
# by definition of set inclusion
axiom_elim_set_lteq_justification=包含関係の定義により
# lower bound
axiom_elim_shas_lower_bound_diagnostic=下限
# by definition
axiom_elim_shas_lower_bound_justification=定義により
# upper bound
axiom_elim_shas_upper_bound_diagnostic=上限
# by definition
axiom_elim_shas_upper_bound_justification=定義により
# intersection
axiom_elim_sinter_diagnostic=交わり
# by definition of set intersection
axiom_elim_sinter_justification=交わりの定義により
# decrease
??
axiom_elim_sis_decreasing_diagnostic=decrease
# by definition
axiom_elim_sis_decreasing_justification=定義により
# positive series
??
axiom_elim_sis_gt_zero_diagnostic=positiveseries
# by definition
axiom_elim_sis_gt_zero_justification=定義により
# increase
??
axiom_elim_sis_increasing_diagnostic=
# by definition
axiom_elim_sis_increasing_justification=定義により
# suites négative
??
axiom_elim_sis_lt_zero_diagnostic=suitesnegative
# by definition
axiom_elim_sis_lt_zero_justification=定義によりelimsislt
# power set
axiom_elim_subset_diagnostic=冪集合
# by definition of power set
axiom_elim_subset_justification=冪集合の定義により
# set union
axiom_elim_sunion_diagnostic=合併
# by definition of set union
axiom_elim_sunion_justification=合併の定義により
# definition of P
axiom_elim_true_at_rank_diagnostic=Pの定義により
# by definition of {0}
axiom_elim_true_at_rank_justification={0}の定義により
# reverse
??
axiom_eq_inverse_diagnostic=reverse2
# by changing to the reverse
??
axiom_eq_inverse_justification=bychange
# opposite
??
axiom_eq_reverse_diagnostic=opposite
# by taking the opposite
axiom_eq_reverse_justification=bytakingoppo
# symmetry
axiom_eq_symmetry_diagnostic=対称性
# by symmetry of the equalityrelation
axiom_eq_symmetry_justification=相等関係の対称性により
# transitivity
axiom_eq_trans_diagnostic=推移性
# by transitivity of the equality relation
axiom_eq_trans_justification=相等関係の推移性により
# inclusion-based formulation
!!
axiom_equiv_rtrans_diagnostic=rtransdiag
# by inclusion-based formulation of a transitive relation
!!
axiom_equiv_rtrans_justification=rtransjust
# by extraction
!!
# extract
axiom_ex_elim_diagnostic=存在量化子の除去
# by extraction of witness
!!
axiom_ex_elim_justification=証拠となる元を取り出したことによる
# by construction
!!
axiom_ex_intro_diagnostic=存在量化子の導入
# by construction
!!
axiom_ex_intro_justification=存在量化子を導入した
# expansion
axiom_expand_diagnostic=展開
!!
axiom_expand_justification=by expanding
# remarkable factorisation
axiom_factorize_diagnostic=重要な因数分解
# by factorising by {1}
axiom_factorize_justification={1}でくくりだす
# ex falso quodlibet
axiom_falseall_diagnostic=⊥の除去
!!
axiom_falseall_justification=by deducing a contradiction
# factorisation
!!
axiom_gen_factorize_diagnostic=因数分解
# by factorising {0} by {1}
axiom_gen_factorize_justification={1}で{0}をくくりだした
# definition
axiom_geo_def_diagnostic=定義
# by definition of a geometric progression
axiom_geo_def_justification=等比数列の定義により
!!
axiom_geo_pro_diagnostic=# functional expression
!!
axiom_geo_pro_justification=by functional expression of a geometric progression
!!
# simplify
axiom_inclusionsimpl_diagnostic=包含関係の書き換え
# by rewriting {1} as {0}
axiom_inclusionsimpl_justification={1}を{0}に書き換えて
# induction
axiom_ind_basic_forall_diagnostic=帰納法
# by induction
axiom_ind_basic_forall_justification=帰納法により
!!
axiom_ind_init_diagnostic=# induction from
# by induction
axiom_ind_init_justification=帰納法により
!!
# symmetry
axiom_ineq_sym_rew_diagnostic=左右の入れ替え
# by symmetrical rewriting
!!
axiom_ineq_sym_rew_justification=左右を入れ替えた
# non-contradiction
axiom_intro_false_diagnostic=無矛盾律
# by the principle of non-contradiction
axiom_intro_false_justification=無矛盾律を適用
# par justification à gauche
axiom_intro_or_left_diagnostic=論理和の導入(左)
# par justification à gauche
axiom_intro_or_left_justification=論理和を導入した
# par justification à droite
axiom_intro_or_right_diagnostic=論理和の導入(右)
# par justification à droite
axiom_intro_or_right_justification=論理和を導入した
# square root
axiom_intro_sqrt_square_diagnostic=平方根
!!
axiom_intro_sqrt_square_justification=# by simplifying the square root
!!
axiom_limit_finite_diagnostic=finite limit
!!
axiom_limit_finite_justification=by calculating a finite limit
!!
axiom_limit_inf_diagnostic=+∞ limit
# by calculating the limit at + ∞
axiom_limit_inf_justification=+ ∞ における極限を計算した
!!axiom_limit_neg_inf_diagnostic=# -∞ limit
# by calculating the limit at -∞
axiom_limit_neg_inf_justification=- ∞ における極限を計算した
# simplification
axiom_linearsimpl_diagnostic=簡単化
# by simplifying {0}
axiom_linearsimpl_justification={0}を簡単化して
!!
axiom_local_theo_justification=by local theorem {0}
# addition
axiom_lradd_bounded_diagnostic=加法
# by adding to left and right sides of {0}
axiom_lradd_bounded_justification=両辺に{0}を足すことで
# addition
axiom_lradd_diagnostic=加法
# addition
axiom_lradd_ineq_diagnostic=加法
# by adding to left and right sides of {0}
axiom_lradd_ineq_justification={0}を両辺に足した
# by adding {0} to both sides
axiom_lradd_justification=両辺に{0}を足した
# addition
axiom_lradd_neq_diagnostic=加法
# by adding to left and right sides of {0}
axiom_lradd_neq_justification=両辺に{0}を足した
# division
axiom_lrdiv_bounded_diagnostic=除法
# by dividing left and right sides by {0}
axiom_lrdiv_bounded_justification=両辺を{0}でわった
# division
axiom_lrdiv_diagnostic=除法
# division
axiom_lrdiv_ineq_diagnostic=除法
# by dividing left and right sides by {0}
axiom_lrdiv_ineq_justification=両辺を{0}でわった
# by dividing both sides by {0}
axiom_lrdiv_justification=両辺を{0}でわった
# division
axiom_lrdiv_neq_diagnostic=除法
# by dividing left and right sides of {0}
axiom_lrdiv_neq_justification=両辺を{0}でわって
# multiplication
axiom_lrmul_bounded_diagnostic=乗法
# by multiplying left and right sides by {0}
axiom_lrmul_bounded_justification=両辺に{0}をかけて
# multiplication
axiom_lrmul_diagnostic=乗法
# multiplication
axiom_lrmul_ineq_diagnostic=乗法
# by multiplying left and right sides by {0}
axiom_lrmul_ineq_justification=両辺に{0}をかけて
# by multiplying both sides by {0}
axiom_lrmul_justification=両辺に{0}をかけることで
# multiplication
axiom_lrmul_neq_diagnostic=乗法
# by multiplying left and right sides by {0}
axiom_lrmul_neq_justification=両辺に{0}をかけた
# subtraction
axiom_lrsub_bounded_diagnostic=減法
# by subtracting left and right sides of {0}
axiom_lrsub_bounded_justification=両辺から{0}を引いた
# subtraction
axiom_lrsub_diagnostic=減法
# subtraction
axiom_lrsub_ineq_diagnostic=減法
# by subtracting left and right sides of {0}
axiom_lrsub_ineq_justification=両辺から{0}を引いた
# by subtracting {0} from both sides
axiom_lrsub_justification=両辺から{0}を引いた
# subtraction
axiom_lrsub_neq_diagnostic=減法
# by subtracting left and right sides of {0}
axiom_lrsub_neq_justification=両辺から{0}を引いた
!!
# next integer
axiom_lt_next_int_diagnostic=整数と不等式
!!
# by transition to the next integer
axiom_lt_next_int_justification=整数と不等式の関係を用いた
# modus ponens
axiom_modus_ponens_diagnostic=モーダス・ポネンス
# by applying modus ponens
axiom_modus_ponens_justification=モーダス・ポネンスを適用
# multiplication and division
axiom_muldiv_diagnostic=倍分
# by multiplying and dividing by {1}
axiom_muldiv_justification={1}を分子分母にかけた
# symétrie
axiom_neq_symmetry_diagnostic=対称性
!!
axiom_neq_symmetry_justification=# par symétrie de la relation d'inégalité
!!
# strictly greater than
axiom_non_zero_gt_diagnostic=> ⇒ ≠
!!
axiom_non_zero_gt_justification=par supériorité stricte
!!
# strictly less than
axiom_non_zero_lt_diagnostic=< ⇒ ≠
!!
axiom_non_zero_lt_justification=par infériorité stricte
!!
# remarkable formulas
axiom_polysquare_diagnostic=重要な公式(2乗の展開)
!!
axiom_polysquare_justification=by identifying the perfect square {0}
!!
axiom_proddecompl_diagnostic=decomposition
!!
axiom_proddecompl_justification=by product decomposition
!!
axiom_proddef_diagnostic=assocication
!!
axiom_proddef_justification=by associativity of the product operator applied to {0}
!!
axiom_prodinverse_diagnostic=reverse indexing3
!!
axiom_prodinverse_justification=by reverse indexing2
!!
axiom_prodlinear_diagnostic=associativity
!!
axiom_prodlinear_justification=by associativity of the product operator applied to {0}
!!
axiom_prodresult1_diagnostic=prodresult1
!!
axiom_prodresult1_justification=prodresuult1
!!
axiom_prodsimpl_diagnostic=prodsimpl
!!
axiom_prodsimpl_justification=prodsimpl
!!
# index shifting
axiom_produpshift_diagnostic=添字のシフト1
!!
# by index shifting
axiom_produpshift_justification=添字をずらした1
!!
axiom_reason_capacity_diagnostic=ability to reason
!!
axiom_reason_capacity_justification=by hat wearer's ability to reason
# by definition
axiom_red_true_at_rank_diagnostic=定義による
# by definition of {0}
axiom_red_true_at_rank_justification={0}の定義による
# common denominator
axiom_reducedenom_diagnostic=通分
# by reduction to a common denominator
axiom_reducedenom_justification=通分した
# rewriting
axiom_rewriting_diagnostic=代入
# by rewriting {0} as {1}
axiom_rewriting_justification={0}を{1}に書き換えた
!!
# sandwich
axiom_sandwich_diagnostic=はさみうち
!!
# by the sandwich theorem
axiom_sandwich_justification=はさみうちの原理を適用
!!
# in a range
axiom_section_diagnostic=仮定への組み込み(intros)
!!
axiom_section_justification=demonstration
!!
# absorbtion
axiom_set_absorb_diagnostic=吸収元
!!
# by absorption
axiom_set_absorb_justification=吸収性を適用
# ad absurdum
axiom_set_adabsurdum_diagnostic=二重補集合作用素の除去
!!
# by involution of set complement
axiom_set_adabsurdum_justification=補集合作用素が対合であることを使った
# De Morgan's laws
axiom_set_demorgan_diagnostic=ド・モルガン律
# according to the laws of De Morgan
axiom_set_demorgan_justification=ド・モルガン律により
# symmetry
axiom_set_eq_symmetry_diagnostic=対称性
# by symmetry of the equality relation
axiom_set_eq_symmetry_justification=相等関係の対称性により
# transitivity
axiom_set_eq_trans_diagnostic=推移性
# by transitivity of the equality relation
axiom_set_eq_trans_justification=相等関係の推移性により
# excluded middle
axiom_set_excluded_diagnostic=排中律
# by applying the excluded middle principle
axiom_set_excluded_justification=排中律により
# intersection
axiom_set_inter_comb_diagnostic=交わり
# by intersection left and right
axiom_set_inter_comb_justification=左と右の交わり
# transitivity
axiom_set_lteq_transitivity_diagnostic=推移性
# by transitivity of inclusion
axiom_set_lteq_transitivity_justification=包含関係の推移性により
# identity element
axiom_set_neutral_diagnostic=単位元
# by property of the identity element
axiom_set_neutral_justification=単位元の性質により
# rewriting
axiom_set_rewriting_diagnostic=代入
!!
axiom_set_rewriting_justification=by rewriting {0} in {1}
# union
axiom_set_union_comb_diagnostic=合併
# by union left and right
axiom_set_union_comb_justification=左と右の合併により
# associativity
axiom_setassociative_diagnostic=結合性
# by associativity
axiom_setassociative_justification=結合性を適用
# commutativity
axiom_setcommutative_diagnostic=可換性
# by commutativity
axiom_setcommutative_justification=可換性を適用
# expansion
axiom_setdevelopp_diagnostic=展開
!!
axiom_setdevelopp_justification=# by developping
# factorisation
axiom_setfactorize_diagnostic=因数分解
# by factorising
axiom_setfactorize_justification=因数分解により
# decomposition
axiom_sigmadecompl_diagnostic=総和の分解
# by decomposing sigma
axiom_sigmadecompl_justification=総和を分解した
# definition
axiom_sigmadef_diagnostic=総和への取り込み
!!
axiom_sigmadef_justification=# by definition of the sigma function applied to {0}
!!
# reverse
axiom_sigmainverse_diagnostic=反転
!!
# by reverse indexing
axiom_sigmainverse_justification=和の順序を反転させた
# linearity
axiom_sigmalinear_diagnostic=線形性
# by linearity of the sigma function applied to {0}
axiom_sigmalinear_justification={0}について総和作用素の線形性を用いた
# first integers
axiom_sigmaresult1_diagnostic=Σk ('1乗の和'の公式)
!!
# by sum of the first integers
axiom_sigmaresult1_justification='1乗の和'の公式を使った
!!
# first squares
axiom_sigmaresult2_diagnostic=2乗の和の公式
!!
# by the sum of the first square roots
axiom_sigmaresult2_justification=2乗の和の公式を使った
!!
# first powers
axiom_sigmaresult3_diagnostic=等比級数の公式
!!
# by sum of the first powers
axiom_sigmaresult3_justification=等比級数の公式を使った
!!
# count
axiom_sigmasimpl_diagnostic=Σ1
# by definition of the sigma function
axiom_sigmasimpl_justification=総和作用素の定義により
!!
# index shifting
axiom_sigmaupshift_diagnostic=添字のシフト
!!
axiom_sigmaupshift_justification=by the difference of the indices
# limit
axiom_slim_def_elim_diagnostic=極限
# by definition of limit
axiom_slim_def_elim_justification=極限の定義により
!!
axiom_slim_inf_def_elim_diagnostic=# infinite limit
!!
axiom_slim_inf_def_elim_justification=by definition of an infinite limit
!!
axiom_slimfinite_inf_elim_diagnostic=infinite limit
#
axiom_slimfinite_inf_elim_justification=
# remarkable formula
axiom_square_diff_diagnostic=重要な公式(和と差の積)
!!
axiom_square_diff_justification=by factorising the difference of two squares
# subtraction and addition
axiom_subadd_diagnostic=X = X - V + V
# by subtracting and adding {1} to {0}
axiom_subadd_justification={0}に{1}を引いて足すことで
# transitivity
axiom_trans_lt_gt_diagnostic=推移性
# by transitivity
axiom_trans_lt_gt_justification=推移性により
!!
# simplification up and down
axiom_updownsimpl_diagnostic=約分
!!
# by simplification up and down
axiom_updownsimpl_justification=約分により
!!
# change of variables
axiom_varchange_diagnostic=変数変換
!!
axiom_varchange_justification=by rewriting {0} in {1}
!!
basic_A=A
!!
basic_BeMarried=to be married
!!
basic_BeMarried_neg=to not be married
!!
basic_BeScottish=to be Scottish
!!
basic_BeScottish_neg=to not be Scottish
!!
basic_BlackHat=black
basic_ExprGT={0} > {1}
basic_ExprGTEQ={0} ≥ {1}
basic_ExprLT={0} < {1}
basic_ExprLTEQ={0} ≤ {1}
# {0} is a bijection
basic_FBij={0}は全単射
basic_FComp={0} ∘ {1}
# {1} is an injection on [ 0 ... {0} ]
basic_FFInj={1}は[ 0 ... {0} ]上の単射
# {1} is strictly monotonic on [ 0 ... {0} ]
basic_FFMono={1}は[ 0 ... {0} ]上で狭義単調である
# {0} is an injection
basic_FInj={0}は単射
# {0} is not an injection
basic_FInj_neg={0}は単射でない
# {0} is an involution
basic_FInvolution={0}は対合
# {0} is a surjection
basic_FSurj={0}は全射
# {0} is not a surjection
basic_FSurj_neg={0}は全射でない
# contradiction
basic_False=矛盾
# false
basic_False_sci=⊥
!!
basic_FindX=# Find the value of x.
!!
basic_FindY=Find the value of y.
!!
basic_GoOutSundays=to go out on Sundays
!!
basic_GoOutSundays_neg=to not go out on Sundays
!!
basic_GoToMatch=to go to a football match tomorrow
!!
basic_GoToMatch_neg=to not go to the match tomorrow
!!
basic_GoToTraining=to go to training today
!!
basic_GoToTraining_neg=to not go to training today
# {0} is an injection
basic_O1FInj={0}は単射
# {0} is not an injection
basic_O1FInj_neg={0}は単射でない
# {0} is a surjection
basic_O1FSurj={0}は全射
# {0} is not a surjection
basic_O1FSurj_neg={0}は全射でない
# Who is the oldest and who is the youngest?
basic_OldYoungUtterance=誰が最年長で、誰が最年少だろうか。
# {0} is the oldest
basic_Oldest={0}は最年長
# {0} is not the oldest
basic_Oldest_neg={0}は最年長でない
# proposition depending on n
basic_PropDependentN={0}に依存する命題
# {2} is an antisymmetric relation
basic_RAntiSym={0}は反対称関係
basic_RComp={0} . {1}
# {2} is an equivalence relation
basic_REquiv={0}は同値関係
# {4} is a functional relation
basic_RFun={0}は関数関係
!!
basic_RIRRefl=# {2} is an irreflexive relation
!!
basic_RInj={0} is an injective relation
basic_RInv={0} ⁻¹
!!
basic_RRefl={0} is a relflexive relation
!!
basic_RSurj={0} is a surjective relation
!!
basic_RSym={0} is a symmetric relation
!!
basic_RTot={0} is a total relation
!!
basic_RTotLeft={0} is a left-total relation
!!
basic_RTrans={0} is a transitive relation
!!
basic_ScottishUtterance=Rules are so strict that no one can be accepted in the club.
!!
basic_Set=ensemble
!!
basic_ToBeHuman=to be human
!!
basic_ToBeHuman_neg=is not human
!!
basic_ToBeMortal=to be mortal
!!
basic_ToBeMortal_neg=is not mortal
!!
basic_ToBeSocrate=to be Socrates
!!
basic_ToBeSocrate_neg=is not Socrate
!!
basic_WearAKilt=to wear a kilt
!!
basic_WearAKilt_neg=does not wear a kilt
!!
basic_WearRedSocks=to wear red socks
!!
basic_WearRedSocks_neg=does not wear red socks
!!
basic_WhiteHat=white
# {0} is the youngest
basic_Youngest={0}は最年少
# {0} is not the youngest
basic_Youngest_neg={0}は最年少でない
# by adding {0}
basic_addition={0}を足すことで
basic_and=and
basic_and_sci=∧
basic_app_fun_exset={0} ( {1} )
basic_app_prop={0} ( {1} )
basic_app_prop2={0} ( {1} , {2} )
basic_app_prop2_sci={0} ( {1} , {2} )
basic_app_prop_sci={0} ( {1} )
basic_app_rel={1} {0} {2}
basic_app_rel_sci={1} {0} {2}
!!basic_are_collinear={0} are collinear
!!basic_are_collinear_neg={0} are not collinear
# {0} and {1} are parallel
basic_are_parallel={0}と{1}は平行
# {0} and {1} are not parallel
basic_are_parallel_neg={0}と{1}は平行でない
# by definition of an arithmetic sequence
basic_arith_elim=等比数列の定義により
!!
basic_case=case {0} : {1}
!!
basic_demonstrate_lim=Prove that {0} has a limit of {1}
!!
basic_determine=Determine {0}
!!
basic_determine_lim=Determine the limit of {0}
!!
basic_determine_reason=Determine the common difference of the series {0}
!!
basic_determine_value=Determine the value of {0}
# by expansion
basic_development=展開により
# dividing by {0}
!!
basic_division={0}でわることで
# dividing and multiplying by {0}
basic_division_and_multiplication={0}でわる/かけることにより
# by definition
basic_elim_is_solution_equiv=定義より
# by definition of a left or right limit
basic_elim_limit_expr_b=左/右極限の定義により
!!
basic_elim_rewrite_equiv=by rewriting
!!
basic_eq_symmetry_equiv=by symmetry of the equality relation
!!
basic_equation=the equation {1}
!!
basic_equation_systeq=the equation system {1}
basic_equiv={0} {math:⇔} {1}
basic_equiv1={0} {math:⇔} {1}
basic_equiv1_sci={0} {math: ⇔} {1}
basic_equiv_sci={0} {math:⇔} {1}
# by expanding
basic_expansion=展開により
!!
basic_expansion_of_power=by definition of powers

## Mirai

# {1} is defined on {2}
basic_expr_is_defined_on={0}は{1}の上で定義される
# {0} is not defined on {1}
basic_expr_is_defined_on_neg={0}は{1}の上で定義されない
# by factorising
basic_factorization=因数分解により
# determine the limit value {1} such that {2}
basic_findLimitExpr=[??]{0}のとき極限値{1}を決める
# {find} the asymptotic behavior of {2} at {3}
basic_find_asymptot={0}の{1}での漸近的なふるまいを{find}
# {find} the value of {0} {justTags}
basic_find_expr={0}の値を{find} {justTags}
# {find} the limit of {2} as x approaches {3} {justTags}
basic_find_limit=xが{0}に近づくときの{1}の極限を{find} {justTags}
# {find} the behavior of {4} at infinity
basic_find_limit_type={0}の無限遠でのふるまいを{find}
# {find} the type of series {0}
basic_find_series_type={0}の級数の形を{find}
# Floor
basic_floor_id=[!!]Floor
# {4} is convergent
basic_fun_has_finite_limit={0}は収束する
# {4} is bounded below
basic_fun_has_lower_bound={0}は下に有界
# {4} is bounded above
basic_fun_has_upper_bound={0}は上に有界
# {4} is limited
basic_fun_is_bounded={0}は有界
# {4} is constant
basic_fun_is_constant={0}は定数
# {4} is decreasing
basic_fun_is_decreasing={0}は減少する
# {4} is not decreasing
basic_fun_is_decreasing_neg={0}は減少しない
# {4} is defined on {5}
basic_fun_is_defined_on={0}は{1}の上で定義される
# {4} is strictly positive
basic_fun_is_gt_zero={0}は正
# {4} is increasing
basic_fun_is_increasing={0}は増加する
# {4} is not increasing
basic_fun_is_increasing_neg={0}は増加しない
# {4} is negative
basic_fun_is_lt_zero={0}は負
basic_gen_app_rel={1} {0} {2}
basic_gen_app_rel_sci={1} {0} {2}
# by construction of {0}
basic_geoconstr={0}の構成から
basic_id={0}
# implies
basic_imply=導く
basic_imply_sci={math:⇒}
# Rank of initialisation
basic_ind_basic_evar_0=[!!]Rank of initialisation
# {1} is a neighborhood of {2}
basic_is_a_neighborhood={1}は{2}の近傍
# Addition is increasing for relation '{0}'
basic_is_add_increasing=[!!]Addition is increasing for relation '{0}'
# {0} knows that {1}
basic_is_aware=[!!]{0} knows that {1}
# {0} does not know that {1}
basic_is_aware_neg=[!!]{0} does not know that {1}
basic_is_bad={0}は嘘吐きである
# {0} is big
basic_is_big_enough={0}は大きい
basic_is_crossed=[!!]the quadrilateral {0} is intersected
basic_is_crossed_neg=[!!]quadrilateral {0} is not crossed
# {0} is defined on {1}
basic_is_defined_on={0}は{1}の上で定義される
basic_is_definition_set=[!!]{0} is the set of definitions of {1}
basic_is_element={1} {math:∊} {2}
basic_is_element_dom={0} {math:∊} {1}
# {1} does not belong to {2}
basic_is_element_neg={1}は{2}に属さない
basic_is_element_sci={1} {math:∊} {2}
basic_is_element_sci_neg={1} {math:∉} {2}
# {0} is even
basic_is_even={0}は偶数
# {0} is an honestant
basic_is_good={0}は正直者
# {0} is in the neighborhood of {1}
basic_is_in_neighbourhood_of={0}は{1}の近傍にある
# {0} is an integer
basic_is_integer={0}は整数
# {0} is a binary operation on {1}
basic_is_lci={0}は{1}上の二項演算
# {0} is not a binary operation on {1}
basic_is_lci_neg={0}は{1}上の二項演算ではない
# {0} is the midpoint of the segment {1}
basic_is_middle_segment={0}は区間{1}の中間点
# {0} is not the midpoint of the segment {1}
basic_is_middle_segment_neg={0}は{1}の中間点ではない
# {1} is decreasing on {2}
basic_is_monotonic_on={1}は{2}上で減少する
# {0} is divisible by {1}
basic_is_multiple_of={0}は{1}で割り切れる
# {0} is not divisible by {1}
basic_is_multiple_of_neg={0}は{1}で割り切れない
# {0} is odd
basic_is_odd={0}は奇数
# {0} is a parallelogram
basic_is_parallelogram={0}は平行四辺形
# {0} is not a parallelogram
basic_is_parallelogram_neg={0}は平行四辺形ではない
# {1} is a partition of {0}
basic_is_partition={1}は{0}の分割
# {1} is a polynomial
basic_is_polynom={1}は多項式
# {0} is the orthogonal projection of {1} on {2}
basic_is_projected_on={0}は{1}の{2}上の直交射影
# Relation '{0}' is reflexive
basic_is_reflexive=関係'{0}'は反射的
# {5} is the restriction of {6} to {2}
basic_is_restriction={5}は{6}の{2}への制限
# {0} is the set of solutions of {1}
basic_is_solution={0}は{1}の解集合
# {0} is not the solution of {1}
basic_is_solution_neg={0}は{1}の解ではない
# {0} is the symmetric of {2} with respect to {1}
basic_is_symmetric={0}は{2}の{1}に関する鏡映
# Relation '{0}' is transitive
basic_is_transitive=関係'{0}'は推移的
basic_isolate=[!!]Isolate {0}
basic_knows_hatcolor=[!!]{0} knows the colour of their hat
basic_knows_hatcolor_neg=[!!]{0} does not know the colour of their hat
basic_le=≤
basic_lor_elim=[!!]sufficient hypothesis
# by multiplying and dividing by {0}
basic_multiplication_and_division=[??]{0}をかけたり割ったりすることで
basic_nats=[!!]{0} with {1}
basic_neighborset={0}
basic_not=[!!]not
basic_not_sci=¬
# oldest and youngest
basic_oldyoung=[??]最年長と最年少
# or
basic_or=または
basic_or_sci=∨
# {2} belongs to {3}
basic_pis_element={0}は{1}に属する
# {1} does not belong to {2}
basic_pis_element_neg={0}は{1}に属さない
basic_pis_element_sci={0} {math:∊} {1}
basic_pis_element_sci_neg={0} {math:∉} {1}
# by decomposition
basic_proddecompr=分解により
# by index shifting
basic_proddownshift=添字をシフトすることで
# {0} {1} and {2}
basic_pset3={0}, {1}, {2}
# {0} is defined on {1}
basic_rel_is_defined_on={0}は{1}の上で定義される
# {0} is not defined on {1}
basic_rel_is_defined_on_neg={0}は{1}の上で定義されない
basic_rel_le=≤
basic_resolve=[!!]Resolve {0}
# {1} is rewritten {2} in {0}
basic_rewrite_in={0}において{1}を{2}で置き換えられる
basic_ror_elim=[!!]Sufficient hypothesis
basic_say=[!!]{0} says that {1}
basic_set_lt={0} ⊂ {1}
basic_set_lteq={0} ⊆ {1}
# {0} is convergent
basic_shas_finite_limit={0}は収束する
# {0} has a limit of {1}
basic_shas_limit={0}は極限{1}を持つ
# {0} does not have a limit of {1}
basic_shas_limit_neg={0}は極限{1}を持たない
# by decomposing sigma
basic_sigmadecompr=シグマを分解することで
basic_sigmadownshift=[!!]by the difference of the indices
# {0} is arithmetic
basic_sis_arith={0}は等差級数
# {0} is not arithmetic
basic_sis_arith_neg={0}は等差級数でない
# {2} is arithmetic for reason {3}
basic_sis_arith_reason={0}は{1}により等差級数
# {2} is not arithmetic because of {3}
basic_sis_arith_reason_neg={0}は{1}により等差級数でない
# Is the series {0} arithmetic or geometric?
basic_sis_caracterized=級数{0}は等差級数か等比級数か？
basic_sis_element={0} {math:∊} {1}
basic_sis_element_neg={0} {math:∉} {1}
basic_sis_element_sci={0} {math:∊} {1}
basic_sis_element_sci_neg={0} {math:∉} {0}
# {0} is a geometric series
basic_sis_geo={0}は等比級数
# {0} is not a geometric series
basic_sis_geo_neg={0}は等比級数でない
# {2} is geometric with common ratio {3}
basic_sis_geo_reason={0}は公比{1}の等比級数
basic_sis_geo_reason_neg=[!!]{0} is not a geometric series because with common ratio {1}
# by subtracting {0}
basic_subtraction={0}を引くことで
# by subtracting or adding {0}
basic_subtraction_and_addition={0}を引くか足すことで
basic_triv_div_lr=[!!]by dividing the two members by {0}
basic_true_at_rank=[!!]{0} is true at rank {1}
basic_true_at_rank_neg=[!!]{0} is false on rank {1}
basic_true_at_rank_sci={0} ( {1} )
basic_true_at_rank_sci_neg=¬ {0} ( {1} )
basic_uprod={0}×{1}
# {0} wears a hat {1}
basic_wears_hat={0}は帽子{1}をかぶっている
# {0} does not wear a {1} hat
basic_wears_hat_neg={0}は帽子{1}をかぶっていない
# Content
help_part_content=コンテンツ
help_part_paper=[!!]Digital paper
# Navigation
help_section_browsing=ナビゲーション
# Commutativity
help_section_commutativity=可換性
help_section_evar=[!!]Reasoning variable
# Exercises
help_section_exercises=演習問題
# Proof
help_section_proof=証明
# Selection
help_section_selection=選択
help_section_trophy=[!!]Cockades
help_section_unification=[!!]Unifications
key_Product=[!!]Product
# Content
key_access_content=コンテンツ
key_access_date=Date
key_access_role=Role
key_access_role_ref=Admin
# Student
key_access_role_user=学生
# My account
key_account=マイ・アカウント
# Add
key_add=追加
key_add_exercise_message=[!!]Type exercise utterance ...
# Request new exercise
key_add_exercise_title=新しい演習問題をリクエストする
key_and=[!!]and
key_apply=[!!]Apply
# Hint
key_ask_hint_button=ヒント
# !! Assume
key_assume=仮定:
# To get back to previous screen,
key_back_connection_panel=前の画面に戻る
# Exercises
key_browsing_train=演習問題
# according to {0}
key_by={0}より
# Cancel
key_cancel=キャンセル
key_catchme=[!!]Catch me
# Change password
key_change_password=パスワードを変える
# Chapters
key_chapters=章
# character not available
key_character_not_available=この章は利用できません
# Check box
key_check_box=チェックボックス
key_check_cgu=GTU
# Accept
key_check_text_cgu=承認
# Class
key_class=クラス
# No class found.
key_class_default_message=クラスが見付かりません
# click here
key_click_here=ここをクリック
# Click here
key_clickme=ここをクリック
key_clickme_fix=[!!]Fix it and click here to validate
# Click here to validate
key_clickme_valid=クリックして確認
key_commuteme=[!!]Obtain below the following value:
# ?? Conclusion
key_conclusion=[結論]
key_confirm_delete_tab_message=[!!]Delete scope ?
# Yes
key_confirm_delete_tab_message_yes=はい
# Confirm password
key_confirm_password=パスワードの確認
# Give up exercise?
key_confirm_quit_exercise=演習問題を中断しますか？
# Well done, the exercise is proved!
key_congrats=証明終了！
# Connection
key_connection=接続
# Construct
key_construct=構成
key_context=[!!]Context
# Create account
key_create_account=アカウント作成
# Create account / login
key_create_account_connect=アカウント作成/ログイン
key_credits=[!!]tokens
# Buy application content directly.
key_credits_content_message=アプリケーション・コンテンツを直接購入
# Content
key_credits_content_title=コンテンツ
key_credits_pack_message=[!!]Unlock content in the application with tokens.
key_credits_pack_pack1_title=Discovery
key_credits_pack_pack2_title=Training
key_credits_pack_pack3_title=Ultimate
key_credits_pack_title=Credits
key_deduce=[!!]Deduce
key_deduce_in=[!!]Deduce in
key_deduce_of=[!!]Deduction from
key_deduce_scope=[!!]Deduce in this scope
# Delete
key_delete=削除
# Delete account
key_delete_account=アカウントの削除
# A deletion link has been sent to your email address
key_delete_account_message=アカウント削除のためのリンクをメールしました
# To delete the account, type 'DELETE' in the text field below and click the OK button.
key_delete_message=アカウントを削除するには、下のテキストフィールドに'DELETE'と入力してOKボタンをクリックしてください。
key_delete_word=DELETE
# {0} account has been deleted.
key_deleted_account={0}アカウントは削除されました。
# ?? Prove:
key_demonstrate=次の命題を証明せよ
# <div>Justify statement <!--{type="tag" input="{statementId}"}--> with the rule : <!--{type="axiom_api" input="{axiomId}"}--></div>
key_description_back=<div><!--{type="tag" input="{statementId}"}-->を規則<!--{type="axiom_api" input="{axiomId}"}-->にしたがって証明せよ</div>
# <div>Justify statement <!--{type="tag" input="{statementId}"}--> with the rule : <!--{type="axiom_api" input="{axiomId}"}--></div>
key_description_backsel=<div><!--{type="tag" input="{statementId}"}-->を規則<!--{type="axiom_api" input="{axiomId}"}-->にしたがって証明せよ</div>
# <div>Delete statement <!--{type="tag" input="{statementId}"}--></div>
key_description_delete=<div><!--{type="tag" input="{statementId}"}-->を削除</div>
# <div>Delete justification of statement <!--{type="tag" input="{statementId}"}--></div>
key_description_deleteby=<div><!--{type="tag" input="{statementId}"}-->の証明を削除</div>
# <div>Deduce from <!--{type="tag" input="{statementId}"}--> with <!--{type="axiom_api" input="{axiomId}"}--></div>
key_description_for=<div><!--{type="tag" input="{statementId}"}-->と<!--{type="axiom_api" input="{axiomId}"}-->から導け</div>
# <div>Deduce from <!--{type="tag" input="{statementId}"}--> with <!--{type="axiom_api" input="{axiomId}"}--></div>
key_description_forsel=<div><!--{type="tag" input="{statementId}"}-->と<!--{type="axiom_api" input="{axiomId}"}-->から導け</div>
# Assign value <!--{type="expr" input="{actTypArg2}"}--> to <!--{type="paper_evar" input="{actTypArg}"}--></div>
key_description_inst=値<!--{type="expr" input="{actTypArg2}"}-->に<!--{type="paper_evar" input="{actTypArg}"}-->を割り当てよ</div>
key_description_section=[!!]Open scope for statement <!--{type="tag" input="{statementId}"}-->
# <div>Congrats, exercise solved!</div>
key_description_success=<div>問題は解けました！div>
key_description_unif=[!!]Unify statements <!--{type="tag" input="{actTypArg}"}--> and <!--{type="tag" input="{statementId}"}-->
# The entries in this chapter are not yet available.
key_diagnostic_no_diag=この章のエントリーはまだ利用できません
key_disconnect=[!!]Disconnect
# Move titles
key_draggable_title=タイトルに戻る
# Drag here
key_dragme=ここにドラッグ
# Email
key_email=メール
# email not authorized
key_email_not_authorized=メールアドレスが許可されていません
# email not found
key_email_not_found=メールアドレスが見付かりません
# email not valid
key_email_not_valid=メールアドレスが有効ではありません
# email not verified
key_email_not_verif=メールアドレスが確定されていません
# email unknown
key_email_unknown=未知のメールアドレスです
# email used
key_email_used=メールアドレスは使われています
# email valid
key_email_valid=メールアドレスは有効です
# empty field
key_empty_field=空のフィールドです
# Nothing available for this action
key_empty_suggest=この操作に対しては何も利用できません
# Not found
key_error_paper_subtitle=見付かりません
key_error_paper_title=[!!]jcannot retrieve this paper
# Exercise
key_exercise=演習問題
# Exercises
key_exercises=演習問題
# Value of
key_fill_evar=[??]値
# Find
key_find=求める
# Firstname
key_firstname=名前
key_focus_text=[!!]Context
# News
key_follow_us=ニュース
# The application is not available on mobile
key_forbid_mobile=アプリケーションはモバイルでは利用できません
# Forgot password ?
key_forgot_password=パスワードを忘れたら
# Geometrical figure
key_geo_figure=幾何学的な図
# Get credits
key_get_credits=クレジットを取得
# Goal
key_goal=ゴール
key_got_it=[!!]Got it.
# Graph
key_graph=グラフ
# Add
key_group_popup_button=追加
# access code
key_group_popup_input_default=アクセスコード
# Enter access code
key_group_popup_title=アクセスコードを入力
# Help
key_help=ヘルプ
key_help_tooltip_chapter_icon_all=Indique la résolution ou non de tous les exercices du chapitre.
key_help_tooltip_chapter_icon_diag=Indique la résolution ou non de tous les exercices de type incontournable sur le chapitre.
key_help_tooltip_chapter_icon_tuto=Indique la résolution ou non de tous les exercices du didacticiel.
key_help_tooltip_chapter_icon_unavoidable=Indique la résolution ou non de tous les exercices de type incontournable sur le chapitre.
# clear all
key_help_tooltip_clearall=すべて消去
key_help_tooltip_deduce=[!!]deduction diagnosis
# Exercice débloquant le mode diagnostic
key_help_tooltip_exercise_icon_diag=診断モードのエクササイズをアンロック
# Exercice de difficulté facile
key_help_tooltip_exercise_icon_difficulty_easy=難易度低の演習問題
# Exercice de difficulté moyenne
key_help_tooltip_exercise_icon_difficulty_hard=難易度中の演習問題
# Exercice de difficulté difficile
key_help_tooltip_exercise_icon_difficulty_medium=難易度高の演習問題
key_help_tooltip_exercise_icon_hint=Exercice prenant en charge des indications ou non.
key_help_tooltip_exercise_icon_unavoidable=Exercice de type incontournable ou non
# hint
key_help_tooltip_hint=ヒント
key_help_tooltip_justify=justification diagnosis
# Not available
key_help_tooltip_lock_access_no=利用できません
# accessible
key_help_tooltip_lock_access_without_deadline=アクセス可
key_help_tooltip_print=[!!]print
# redo
key_help_tooltip_redo=やり直し
key_help_tooltip_section=[!!]Creation of scope
# undo
key_help_tooltip_undo=戻る
key_help_tooltip_unify=[!!]unification
# Click the button below to display a hint
key_hint_message=下のボタンをクリックしてヒントを表示
key_hintpopup_action=[!!]Action
key_hintpopup_actions=[!!]Actions
# Description
key_hintpopup_description=説明
# Preview
key_hintpopup_preview=プレビュー
# Description
key_hintpopup_tab_desc=説明
# Hint
key_hintpopup_tab_hint=ヒント
key_home_credits_text=[!!]Number of tokens
key_home_dashboard_badges=[!!]Cockades
# Solved exercises
key_home_dashboard_exercises=既に解いた演習問題
# Welcome, {firstname}
key_home_profile_text=ようこそ、{firstname}
# An internal error occurred. Please reload.
key_ice=内部エラーが起きました。リロードしてください。
# Connection
key_id_connection=接続
# if
key_if=もし
# Mettre à jour
key_img_text_1=最新版です
# ma photo de profil
key_img_text_2=プロファイル画像
# Enter the following value:
key_inputme=以下の値を入力:
key_justify=[!!]Justify
key_justify_of=[!!]Justification of
# Language
key_language=言語
# Lastname
key_lastname=名字
key_legend=[!!]Legend:
# Levels
key_levels=レベル
# Loading, please wait ...
key_loading_message=ロード中です。しばらくお待ちください。
key_local_theorem=[!!]Local theorem
key_login_with=[!!]Log in with:
key_main_scope=[!!]main scope
key_membership_alreadyadd=[!!]already added
# Error
key_membership_error=エラー
# unknown code
key_membership_notfound=不明なコードです
# quota reached
key_membership_overused=ノルマに達しました
# Modify
key_modify=修正
key_nats=[!!]{0} with {1}
# Need help ?
key_need_help=ヘルプが必要ですか？
# New exercise
key_new_exercise=新しい演習問題
# Next
key_next=次
# email hidden, cannot log in.
key_no_email_message=メールアドレスがありません。ログインできません。
# If you're not registered yet,
key_not_yet_register=もしまだ登録していないなら、
key_ok=OK
# or
key_or=または
# Password
key_password=パスワード
# password confirmed
key_password_confirmed=パスワードが確定されました
# Current password
key_password_current=現在のパスワード
# password incorrect
key_password_incorrect=パスワードが間違っています
# New password
key_password_new=新しいパスワード
# password not confirmed
key_password_not_confirmed=パスワードは確定されていません
# password is too short (at least 6 characters)
key_password_too_short=パスワードが短かすぎます(6文字以上入力してください)
# password valid
key_password_valid=パスワードは有効です
# password must contained at least 1 digit
key_password_with_digit=パスワードは少くとも1文字の数字を含んでいなければいけません
# Preview
key_preview=プレビュー
# Profile information
key_profile_informations=プロフィール情報
# Proof of
key_proof_of=[??]証明
# the definition
key_propdeftag_def=定義
# proposition
key_propdeftag_prop=命題
# Proof
key_prove_text=証明
# Proof ...
key_prove_text_close=証明 ...
# Proof:
key_prove_text_open=[証明]
# Register
key_register=登録
# Registration
key_registration=登録
# Reset
key_reinit=リセット
# Enter your email address to reset your password.
key_reinit_password=パスワードをリセットするためにメールアドレスを入力してください。
# A reset link has been sent to your email address.
key_reinit_password_message=リセットのためのリンクが入力されたメールアドレスに送られました。
key_report_input_default=[!!]Give feedback or ask for help
# Send us a message
key_report_label=管理者に連絡
# Your email address:
key_report_label_email=登録されたメールアドレス：
# Message sent !
key_report_message_sent=メッセージが送られました
# Edit message
key_report_modify_message=メッセージを編集する
# Next
key_report_next=次
# Email address
key_report_placeholder_email=メールアドレス
# We will get back to you.
key_report_recontact=返事をお待ちください。
# Send
key_report_send=送る
key_require_message=[!!]To access this chapter, get the cockade 'tutorial' of chapters below:
key_require_message_exercise=[!!]To access this exercise, get the cockade 'tutorial' of chapters below:
key_require_message_part=[!!]Get 'tutorial' cockades for access to chapters below
# Prerequisites
key_required=必要条件
# Save
key_save=保存
# Scroll down
key_scroll_down=下にスクロール
# Scroll up
key_scroll_up=上にスクロール
# Segments
key_segments=[??]区分
# Select the value above
key_selectme=上の値を選択
# Send
key_send=送る
# <div class="{0}"> <a target="_blank" href="http://en.wikipedia.org/wiki/Social_login" class="{1}">social login</a> is the easiest and safest way to sign-in and login. Nothing will be published on your "wall". </div> <div class="{2}">By clicking on one of the buttons, you are accepting <a target="_blank" href="{3}" class="{4}">our conditions of use and our confidentiality policy</a>. </div>
key_social_login=[??]<div class="{0}"> <a target="_blank" href="http://en.wikipedia.org/wiki/Social_login" class="{1}">ソーシャルログイン</a>は簡単で安全な登録/ログインの方法です。Nothing will be published on your "wall". </div> <div class="{2}">下のボタンのうち一つをクリックして、<a target="_blank" href="{3}" class="{4}">使用上の条件や守秘義務方針</a>に同意します</div>
# The application is not available. If you with to sign up, please send an email to: contact@edukera.com
key_sorry_whitelist=アプリケーションが利用できません。登録したい場合、contact@edukera.com にメールしてください。
# Start
key_start=始める
# Report a problem
key_status_report=問題を報告
key_step_choice_axiom=<div class="instruction-item"><!--{type="hint_itemize"}--> In part <span class="hint-text"> <!--{type="label_toolbox" input="{TPartId}"}--></span> <!--{type="toolbox_button" input="{TPartId}"}--> access toolbox chapter by clicking on <!--{type="label_toolbox" input="{TChapterId}"}--> <!--{type="toolbox_button" input="{TChapterId}"}--> <!--{type="hint_check"}--></div>
key_step_choice_axiom_in_diag=<div class="instruction-item"> <!--{type="hint_itemize"}--> Select rule <!--{type="diag_axiom" input="{axiomId}"}--> in section <!--{type="diag_axiom_part" input="{TSectionId}"}--> <!--{type="hint_check"}--></div>
key_step_choice_question_tab=<div class="instruction-item"> <!--{type="hint_itemize"}--> Select tab <!--{type="question_tab" input="{tabQuestionValue}"}--> <!--{type="hint_check"}--></div>
key_step_choice_tab_index_in_diag=<div class="instruction-item"> <!--{type="hint_itemize"}--> Click on tab <!--{type="diag_tab" input="{actIdx}"}--> <!--{type="hint_check"}--></div>
key_step_click_apply=<div class="instruction-item"> <!--{type="hint_itemize"}--> Click on <!--{type="button_apply"}--> in 'preview section'. <!--{type="hint_check"}--></div>
key_step_click_deduce=<div class="instruction-item"> <!--{type="hint_itemize"}--> Click on <!--{type="button_deduce"}--> of <!--{type="propdeftag" input="{statementId}"}--> <!--{type="tag" input="{statementId}"}--> to display diagnostic window. <!--{type="hint_check"}--></div>
key_step_click_justify=<div class="instruction-item"> <!--{type="hint_itemize"}--> Click on <!--{type="button_justify"}--> of statement <!--{type="tag" input="{statementId}"}--> to diaply diagnostic window. <!--{type="hint_check"}--></div>
key_step_delete=<div class="instruction-item"> <!--{type="hint_itemize"}--> Delete statement <!--{type="tag" input="{statementId}"}--> <!--{type="hint_check"}--></div>
key_step_deleteby=<div class="instruction-item"> <!--{type="hint_itemize"}--> Delete justification of statement <!--{type="tag" input="{statementId}"}--> <!--{type="hint_check"}--></div>
key_step_drag=<div class="instruction-item"> <!--{type="hint_itemize"}--> Drag rule <!--{type="toolbox_item" readonly="true" input="{axiomId}"}--> from section <!--{type="label_toolbox" class="toolbox-section-title-content" input="{TSectionId}"}-->. <!--{type="hint_check"}--></div>
key_step_drop=<div class="instruction-item"> <!--{type="hint_itemize"}--> Drop it on statement <!--{type="propdeftag" input="{statementId}"}--> <!--{type="tag" input="{statementId}"}--> <!--{type="hint_check"}--></div>
key_step_enter_expr_in_diag=<div class="instruction-item"> <!--{type="hint_itemize"}--> Enter value <!--{type="expr" statement="{statementId}" input="{actArgItemSecond}"}--> with virutal keyboard for proof variable <!--{type="evar" input="{evarId}"}--> <!--{type="hint_check"}--></div>
key_step_inst=<div class="instruction-item"> <!--{type="hint_itemize"}--> Enter value <!--{type="expr" input="{actTypArg2}"}--> for <!--{type="paper_evar" input="{actTypArg}"}--> <!--{type="hint_check"}--></div>
key_step_open_toolbox=<div class="instruction-item"> <!--{type="hint_itemize"}--> Open toolbox by clicking on <!--{type="toolbox_header_button"}--> <!--{type="hint_check"}--></div>
key_step_section=<div class="instruction-item"> <!--{type="hint_itemize"}--> Click on <!--{type="button_section"}--> of statement <!--{type="tag" input="{statementId}"}--> <!--{type="hint_check"}--></div>
key_step_selection=<div class="instruction-item"> <!--{type="hint_itemize"}--> Select, in statement <!--{type="tag" input="{statementId}"}-->, the term hilighted in blue below : <br> <div>  <!--{type="prop" statement="{statementId}" input="{selectionProp}"}-->  <!--{type="hint_check"}--> </div></div>
key_step_unification=<div class="instruction-item"> <!--{type="hint_itemize"}--> Click on <!--{type="button_unify" input="{actTypArg}"}--> of statement <!--{type="tag" input="{statementId}"}--> <!--{type="hint_check"}--></div>
key_step_unify_in_diag=<div class="instruction-item"> <!--{type="hint_itemize"}--> Click on <!--{type="button_unify" input="{actUnifItem}"}--> <!--{type="hint_check"}--></div>
# Thank you ! A confirmation link has been sent to your email address.
key_sub_subscription_sentence=ありがとうございます。確認のリンクがメールアドレスに送られました。
key_success_trophy_message=[!!]Congratulations, you just get the cockade {trophyId}, for chapter {chapterId}
key_success_trophy_title=[!!]Cockade {trophyId}
key_task_justify_label=[!!]Justify
# then
key_then=ならば
# This rule does not apply to this statement.
key_toolbox_error_message=この規則はこの主張に適用できません。
# hide formula
key_tooltip_axiom_close=公式を隠す
# display formula
key_tooltip_axiom_open=公式を表示
# display context
key_tooltip_context_close=コンテキストを表示
# hide context
key_tooltip_context_open=コンテキストを隠す
# hide scope
key_tooltip_section_close=スコープを隠す
# display scope
key_tooltip_section_open=スコープを表示
# diagnosis
key_trophy_diagnostic=診断
# Fiscal Year 2010
key_trophy_exercises=[??]会計年度2010
# tutorial
key_trophy_tutorial=チュートリアル
key_trophy_unavoidable=[!!]unavoidable
# Tutorial
key_tutorial=チュートリアル
key_uid=ID
# Unlock
key_unlock=アンロック
# You are currently using {browser} in version {current_version}. This version is not compatible with edukera application. Please, update or change your browser.
key_update_browser=現在使用している{browser}のバージョンは{current_version}です。このバージョンは edukera アプリケーションに不整合です。ブラウザをアップデートするか変更してください。
# Usage
key_usage=使用法
key_utterance=[!!]Utterance
# Validate
key_validate=有効化
key_with=[!!]with
# No hint for this exercise.
key_without_hint=この演習問題にはヒントはありません。
# Yes
key_yes=はい
# My account
pager_account=マイ・アカウント
pager_adabusrdum=[!!]Ad absurdum
# Algebra
pager_algebra=代数
# Structures algébriques
pager_algebra_structures=代数構造
pager_algebra_structures_01=
# Analysis
pager_analysis=解析
# Induction
pager_analysis_induction=帰納法
# Limits
pager_analysis_limits=極限
# Series
pager_analysis_series=級数
pager_analysis_series_05=
pager_badges=[!!]Cockades
pager_classical=[!!]Classical
# Systems of equations
pager_comb=方程式系
# Commutativity
pager_commutativity=可換性
# Credits
pager_credits=クレジット
# Dashboard
pager_dashboard=ダッシュボード
# Bernoulli inequality 1
pager_demo_bernoulli_1=ベルヌーイ不等式 1
# Bernoulli inequality 2
pager_demo_bernoulli_2=ベルヌーイ不等式 2
pager_demo_medium_ex_02=[!!]Divisibility
# Calculus
pager_demo_seg=微積分
# Applications
pager_demo_tuto_app=アプリケーション
pager_demo_tuto_comb=[!!]Combinations
# Left and right operations
pager_demo_tuto_first=式の操作
# Definitions
pager_demo_tuto_fun=定義
# Inequality
pager_demo_tuto_neq=不等式
# Transitivity
pager_demo_tuto_rel=推移性
# Limit of 1/n
pager_demo_tuto_serie=1/n の極限
# The sum of the first n integers
pager_demo_tuto_sigma=最初の n 個の整数の和
# De Morgan
pager_demorgan=ド・モルガン
# Easy
pager_easy=簡単
# Enigmas
pager_enigma=[??]謎
# Equality
pager_eq_seg=等式
pager_eqothers=[!!]Mixtures
# Existence
pager_existence=存在
# Distributivity
pager_expansion=分配性
# Injectivity
pager_finj=単射性
# Pigeonhole principle
pager_funpigeon=鳩の巣原理
# Surjectivity
pager_funsurj=全射性
# Truths and lies
pager_good_bad=真実と嘘
# Hard
pager_hard=難しい
# Inequalities
pager_ind_bernouilli=不等式
pager_ind_divis=[!!]Divisibility
# Calculations of sum
pager_ind_sum=和の計算
# Operations
pager_ineq_ex_15=演算
# Combinations
pager_ineq_ex_20=組み合わせ
# Double inequality
pager_ineq_ex_22=[??]二重不等式
# Applications
pager_ineq_ex_24=[??]適用
# Relation
pager_ineq_ex_25=関係
# Inequality
pager_ineq_seg=不等式
# Systems of inequalities
pager_ineq_system=不等式系
# Inequalities
pager_ineqs=不等式

## Haochen

# Limits of functions at a finite point
pager_limits_finite=有限な点における関数の極限
# Functions limit at infinity
pager_limits_inf=無限における関数の極限
# Properties by definition
pager_limits_prop=定義による性質
# eries limits
pager_limits_series=級数の極限
# Logic
pager_logic=数理論理
# Connectors
pager_logic_connector=論理結合子
# !! Peirce's law by reduction ad absurdium
pager_logic_connector_abs_peirce=パースの法則による背理法
# Associativities
pager_logic_connector_associativity=結合律
# Classical logic
pager_logic_connector_classical=古典論理
# Constructivist logic
pager_logic_connector_constructivism=構成的論理
# De Morgan's laws
pager_logic_connector_deMorgan_laws=ド・モルガンの法則
# Distributive properties
pager_logic_connector_distributivity=分配法則
# ?? Distributivity of disjunction
pager_logic_connector_ex_easy_01=選言における分配法則
# Distributivity of the conjunction
pager_logic_connector_ex_easy_02=連言における分配法則
# ?? The universe of integers 1/2
pager_logic_connector_ex_easy_06=整数の宇宙 (universe) 1/2
# The syllogism
pager_logic_connector_ex_easy_08=三段論法
# De Morgan's laws 3/3
pager_logic_connector_ex_easy_12=ド・モルガンの法則 3/3
# De Morgan's laws 1/3
pager_logic_connector_ex_easy_13=ド・モルガンの法則 1/3
# Associativity of conjunction
pager_logic_connector_ex_easy_14=連言の結合法則
# Contraposition 1/2
pager_logic_connector_ex_easy_16=命題の対偶 1/2
# Contraposition 2/2
pager_logic_connector_ex_easy_17=命題の対偶 2/2
# Associativity of disjunction
pager_logic_connector_ex_easy_27=選言の結合法則
# Ad absurdium reasoning
pager_logic_connector_ex_easy_31=背理法
# De Morgan’s laws 2/3
pager_logic_connector_ex_easy_32=ド・モルガンの法則 2/3
# Distributivity of disjunction
pager_logic_connector_ex_easy_33=選言における分配法則
# Distributivity of conjunction
pager_logic_connector_ex_easy_34=連言における分配法則
# Negations
pager_logic_connector_negation=命題の否定
# reduction ad absurdium by Peirce's law
pager_logic_connector_peirce_abs_te=パースの法則による背理法
# Peirce's law
pager_logic_connector_peirce_law=パースの法則
# ?? Reasonings
pager_logic_connector_reasoning=演繹
# Basics
pager_logic_connector_training=基本
# ?? To deduce from a conjunction
pager_logic_connector_tuto_01=連言による演繹をせよ
# ?? To prove a conjunction
pager_logic_connector_tuto_02=連言を証明せよ
# To Prove a disjunction
pager_logic_connector_tuto_03=選言を証明せよ
# Case base reasoning
pager_logic_connector_tuto_04=場合分けをせよ
# To prove an implication
pager_logic_connector_tuto_06=包含を証明せよ
# To deduce from an implication
pager_logic_connector_tuto_07=包含による演繹をせよ
# To prove a negation
pager_logic_connector_tuto_08=否定を証明せよ
# To deduce from a negation
pager_logic_connector_tuto_085=否定による演繹をせよ
# !! Ex False quodlibet
pager_logic_connector_tuto_09=爆発律を導け
# Excluded middle
pager_logic_connector_tuto_10=排中律
# Functions
pager_logic_function=関数
# The universe of integers 2/2
pager_logic_quantifer_tuto_2=整数の宇宙 (universe) 2/2
# Quantifiers
pager_logic_quantifier=量化子
# The Scottish Club
pager_logic_quantifier_21=スコットランド人クラブ
# Distributivity of union
pager_logic_quantifier_ex_01=集合の合併(和集合)における分配法則
# Distributivity of intersection
pager_logic_quantifier_ex_02=集合の交叉(共通部分)における分配法則
# De Morgan Law 1/2
pager_logic_quantifier_ex_03=ド・モルガンの法則 1/2
# De Morgan law 2/2
pager_logic_quantifier_ex_04=ド・モルガンの法則 2/2
# Power set
pager_logic_quantifier_ex_05=冪集合
# Distributivity of the cartesian product
pager_logic_quantifier_ex_06=直積における分配法則
# Existential distributivity
pager_logic_quantifier_ex_07=存在量化子における分配法則
# De Morgan law 2/2
pager_logic_quantifier_ex_easy_08=ド・モルガンの法則 2/2
# De Morgan law 1/2
pager_logic_quantifier_ex_easy_09=ド・モルガンの法則 1/2
# Is less than
pager_logic_quantifier_ex_le_01=小なり
# Is less than (2)
pager_logic_quantifier_ex_le_02=小なり (2)
# Is less than (3)
pager_logic_quantifier_ex_le_03=小なり (3)
# !!
pager_logic_quantifier_ex_le_04=Honestants and Swindlecants 1/4
pager_logic_quantifier_ex_le_05=Honestants and Swindlecants 2/4
pager_logic_quantifier_ex_le_06=Honestants and Swindlecants 3/4
pager_logic_quantifier_ex_le_07=Honestants and Swindlecants 4/4
# ?? Inverse, Injection
pager_logic_quantifier_ex_le_08=単射、逆関数
# Total relations
pager_logic_quantifier_ex_le_10=全域関数
# The Pigeonhole Principle 1/2
pager_logic_quantifier_ex_le_13=鳩の巣原理 1/2
# The Pigeonhole Principle 2/2
pager_logic_quantifier_ex_le_14=鳩の巣原理 2/2
# Binary relations
pager_logic_quantifier_ex_le_15=二項関係
# Distributivity of the cartesian product
pager_logic_quantifier_ex_le_37=集合の直積における分配法則
# Function, injection
pager_logic_quantifier_ex_le_40=関数、単射
# Surjection function
pager_logic_quantifier_ex_le_41=全射関数
# Involution, bijection
pager_logic_quantifier_ex_le_42=対合、全単射
# Composition
pager_logic_quantifier_ex_le_43=関数の合成
# Law of excluded middle by ad absurdium reasoning
pager_logic_quantifier_ex_le_48=背理法による排中律
# Symmetry of equality
pager_logic_quantifier_ex_le_52=相等関係における対称法則
# Transitivity of equality
pager_logic_quantifier_ex_le_53=相等関係における推移法則
# Transitivity of inclusion
pager_logic_quantifier_ex_le_54=包含関係(部分集合)における推移法則
# !! Intersection of equalities
pager_logic_quantifier_ex_le_67=Intersection of equalities
pager_logic_quantifier_ex_le_68=Union of equalities
pager_logic_quantifier_ex_le_69=Intersection of inclusions
pager_logic_quantifier_ex_le_70=Union of inclusions
pager_logic_quantifier_ex_le_71=Ms. Confuse
pager_logic_quantifier_ex_le_72=Three hats enigma
# To prove an existence
pager_logic_quantifier_tuto_01=存在を証明せよ
# To deduce an existence
pager_logic_quantifier_tuto_02=存在をいうには
# To prove a theorem
pager_logic_quantifier_tuto_03=定理を証明せよ
# To deduce from a theorem
pager_logic_quantifier_tuto_04=定理による演繹せよ
# Relations
pager_logic_relation=関係
# Graph of a relation
pager_logic_relation_tuto_01=関係の図式
# Equivalence
pager_logic_relation_tuto_04=同値関係
# Composition
pager_logic_relation_tuto_05=関数の合成
# Rewriting
pager_logic_set_rewrite_01=書き換え
# Associativity
pager_logic_set_rewrite_03=結合法則
# Commutativity
pager_logic_set_rewrite_04=交換法則
# Simplification
pager_logic_set_rewrite_05=簡約
# ?? Development / Factoring
pager_logic_set_rewrite_06=[??]Development・素因数分解
# Symmetry of equality
pager_logic_set_rewrite_08=相等関係における対称法則
# Transitivity of equality
pager_logic_set_rewrite_09=相等関係における推移法則
# Transitivity of inclusion
pager_logic_set_rewrite_10=集合の包含における推移法則
# ?? Combinations
pager_logic_set_rewrite_11=[??]Combinations
# Intersection
pager_logic_settheory_tuto_01=共通部分(集合の交叉)
# Union
pager_logic_settheory_tuto_02=和集合(集合の合併)
# Difference
pager_logic_settheory_tuto_03=差集合
# Complement
pager_logic_settheory_tuto_04=補集合
# Inclusion
pager_logic_settheory_tuto_05=部分集合(集合の包含)
# Equality
pager_logic_settheory_tuto_06=相等関係
# Empty set
pager_logic_settheory_tuto_07=空集合
# Power set
pager_logic_settheory_tuto_08=冪集合
# Cartesian product
pager_logic_settheory_tuto_09=直積
# Left and right Operations
pager_lrops=式の操作
# ?? Medium
pager_medium=[??]中間
# ?? Set formulation
pager_relcar=[??]集合の構成
# Composition
pager_relcomp=関数の合成
# Equivalence
pager_relequiv=同値関係
# Reverse
pager_relinv=[!!]逆
# Relation
pager_relle=小なり(≤)
# Transitivity
pager_reltrans=推移法則
# Almost perfect squares
pager_rew_almostsquare=[!!]近似平方数
# Conjugate values
pager_rew_conjugate=[!!]Conjugate values
# Equations
pager_rew_equation=等式
# Factorisations
pager_rew_factorize=[??]因数分解
# Gold number
pager_rew_gold=[??]黄金数
# Systems of equations
pager_rew_system=方程式系
# Development
pager_rew_tuto_develop=[!!]Development
# Factorisation
pager_rew_tuto_fact1=[??]因数分解
# Remarkable factorization
pager_rew_tuto_fact2=[??]特徴因数分解
# Grouping
pager_rew_tuto_group=[??]グループ分け
# Différence de carrés
pager_rew_tuto_idrem1=[??]平方差
# Difference of squares
pager_rew_tuto_idrem2=[??]平方差
# Commutativity
pager_rew_tuto_misc1=交換法則
# Rewriting
pager_rew_tuto_misc2=[??]リライティング
# Operations
pager_rew_tuto_op=演算子
# Simplifications
pager_rew_tuto_simpl=[??]簡約
# Common denominator
pager_rew_tuto_simpl2=[??]共通分母
# Change of variables
pager_rew_tuto_varchange=変数変更
# Rewritings
pager_rewrite_seg=[??]リライティング
# Home
pager_root=ホーム
# Arithmetic progressions
pager_series_arith=等差数列
# Arithmetico-geometric sequences
pager_series_arithgeo=等比数列
# Bounded sequences
pager_series_bounded=[??]有界数列
pager_series_ex_01=
# Geometric sequences
pager_series_geo=等比数列
# Monotonicity
pager_series_variation=[??]単調性
# Operators
pager_set_operators=演算子
# Set calculus
pager_set_rewoperators=[??]集合演算
# Combinations
pager_setcomb=[??]Combinations
# De Morgan
pager_setdemorgan=ド・モルガンの法則
# Distributive properties
pager_setdistrib=[??]分配法則
# Inclusions
pager_setinclusion=包含関係
# Properties
pager_setprop=集合の性質
# Sets
pager_settheory=集合論
# Sum of the first integers
pager_sigma_ex_15=[!!]Sum of the first integers
# Sum of the first square
pager_sigma_ex_16=[!!]Sum of the first square
# Decomposition
pager_sigma_ex_18=[??]分解
# Association
pager_sigma_ex_19=[??]関連
# Index shifting
pager_sigma_ex_20=[??]番号の変更
# Sum of the first powers
pager_sigma_ex_21=[!!]Sum of the first powers
# linearity
pager_sigma_ex_22=線形性
# Remarkable sums
pager_sigma_ex_23=[!!]Remarkable sums
# Standard sums
pager_sigma_ref=[!!]Standard sums
# Sigma
pager_sigma_seg=[??]シグマ
# Telescoping series
pager_sigma_telescop=畳み込み級数
# Using the standard sums
pager_sigma_withref=[!!]standard sumの使用
# Syllogisms
pager_syllogism=三段論法
toolbox_analysis=解析学
# Function definition
toolbox_appdef=関数の定義
# Arithmetic progression
toolbox_arith_series=等差数列
# Binary relation
toolbox_binrel=二項関係
toolbox_calculus=微分積分
# Combinaisons
toolbox_combinaison=[??]Combinaisons
# Conjunction
toolbox_conjunction=連言
# Connector
toolbox_connector=[??]Connector
# Convergence
toolbox_converge=[??]収束
# Disjunction
toolbox_disjonction=選言
# Distributivity
toolbox_distrib=分配法則
# Equality
toolbox_eq=相等関係
# Equality
toolbox_eqfun=[??]相等関係
# Equal relation
toolbox_eqrel=相等関係
# Equality
toolbox_eqset=相等関係
# Equivalence
toolbox_equiv=同値関係
# Existential quantifier
toolbox_exists=存在量化子
# Factorial
toolbox_fact=因数分解
# Universal quantifier
toolbox_forall=全称量化子
# Function
toolbox_function=関数
# Functional operators
toolbox_funop=関数演算子
# Geometric sequence
toolbox_geo_series=等比数列
# Implication
toolbox_implication=[!!]含意
# Récurrence
toolbox_induction=[??]帰納法
# Inequality
toolbox_ineq=不等式
# Applications
toolbox_ineqapp=[??]応用
# Double inequality
toolbox_ineqbound=[??]二重不等式
# Combinations
toolbox_ineqcomb=[??]Combinations
# Conversions
toolbox_ineqconv=[??]変換
# Relation
toolbox_ineqrel=関係
# Left and right operations
toolbox_leftright=[??]左右演算子
# Left and right operations
toolbox_leftright_ineq=[??]左右演算子
# Inequality
toolbox_leftright_neq=不等式
# Limit at a point
toolbox_limfinite=[??]点での極限
# Limit at infinity
toolbox_limitinf=[??]無限大での極限
# Operations
toolbox_limitops=演算子
# Limit
toolbox_limits=極限
# Logic
toolbox_logic=論理
# Classical logic
toolbox_logicothers=古典論理
# Applications
toolbox_lrapply=[??]応用
# Divisibility
toolbox_multiple=[??]割きれる
# Negation
toolbox_negation=否定
# Etre le plus agé
toolbox_oldest=最も古い
# Operation
toolbox_operation=操作
# Rewriting
toolbox_operation_rewrite=[??]リライティング
toolbox_prod=
toolbox_prodidx=
toolbox_prodrem=
# Quantifiers
toolbox_quantifier=量化子
# Mrs. Confuse
toolbox_quantifier_confuse=[!!]Mrs. Confuse
# Truths and lies
toolbox_quantifier_truthlie=[!!]真実と嘘
# Relation
toolbox_relation=関係
# Relational operators
toolbox_relops=関係演算子
# Remarkable Relations
toolbox_relothers=[??]重要な関係
# Relation
toolbox_relprop=関係
# Set relations
toolbox_relset=集合関係
# Remarkable rewritings
toolbox_remid=[??]重要なリライティング
# Operations
toolbox_rewops=操作
# Rewritings
toolbox_rewprops=[??]リライティング
# Rewriting
toolbox_rewrite=[??]リライティング
# Series
toolbox_series=級数
# Bounding
toolbox_series_limitation=[!!]Bounding
# Sign
toolbox_series_sign=符号
# Monotonicity
toolbox_series_variation=単調性
# Set
toolbox_set=集合
# Combinations
toolbox_set_comb=[??]Combinations
# Rewritings
toolbox_set_rewriting=[??]リライティング
# Set formulation
toolbox_setexpr=[!!]集合の形成
# Function
toolbox_setfun=関数
# Graphe de relation
toolbox_setgraph=関係図
# Operations
toolbox_setops=操作
# Sigma rewriting
toolbox_sigma=シグマに関するリライティング
# Index shiftings
toolbox_sigmaidx=[??]番号の操作
# Remarkable formulas
toolbox_sigmarem=[??]重要な公式
# Simplifications
toolbox_simpl=[??]簡約
# Inclusion
toolbox_slteq=包含
# Remarkable sets
toolbox_somesets=[??]重要な集合
# Three hats enigma
toolbox_sophiehat=[!!]Three hats enigma
# Hat theory
toolbox_sophiehattheory=[??]鳩の巣の原理
# True to the rank n
toolbox_true_at_rank=[!!]True to the rank n
# Vérités et mensonges
toolbox_truthlie=[!!]Vérités et mensonges
# Etre le plus jeune
toolbox_youngest=[??]最も若い
# binary relation on {1}
type_BinRel_arg={1}上の二項関係
# Let {id} be a binary relation on {1}
type_BinRel_dec={id}を{1}上の二項関係とする
# Let {id} be a binary relation on {1} defined by {body}
type_BinRel_dec_body={id}を{1}上の二項関係{body}とする
# there exist {id} binary relations on {1} such that
type_BinRel_exists_several={1}上二項関係{id}が存在し、
# there exists {id} a binary relation on {1} such that
type_BinRel_exists_simple={1}上二項関係{id}が存在し、
# for every {id} binary relations on {1},
type_BinRel_forall_several={1}上任意の二項関係{id}について、
# for every {id} a binary relation on {1},
type_BinRel_forall_simple={1}上任意の二項関係{id}について、
type_BinRel_letin_several=
type_BinRel_letin_simple=
type_BinRel_sci_arg=({1}×{1})
# Let {id} ⊆ {1}×{1}
type_BinRel_sci_dec={id} ⊆ {1}×{1}とする
# Let {id} be a binary relation on {1} defined by {body}
type_BinRel_sci_dec_body={id}を{1}上の二項関係{body}とする
type_BinRel_sci_exists_several=∃ {cartesian_id} ⊆ {cartesian_type},
type_BinRel_sci_exists_simple=∃ {id} ⊆ {1}×{1},
type_BinRel_sci_forall_several=∀ {cartesian_id} ⊆ {cartesian_type},
type_BinRel_sci_forall_simple=∀ {id} ⊆ {1}×{1},
type_BinRel_sci_letin_several=
type_BinRel_sci_letin_simple=
# child
type_Child_arg=子供
# Let {id} be a child
type_Child_dec={id}を子供とする
type_Child_dec_body=
# there exist children {id} such that
type_Child_exists_several=子供{id}が存在し、
# there exists a child {id} such that
type_Child_exists_simple=子供{id}が存在し、
# for every children {id},
type_Child_forall_several=任意の子供{id}について、
# for every child {id},
type_Child_forall_simple=任意の子供{id}について、
type_Child_letin_several=
type_Child_letin_simple=
# child
type_Child_sci_arg=子供
# Let {id} be a child
type_Child_sci_dec={id}を子供とする
type_Child_sci_dec_body=
# there exist children {id} such that
type_Child_sci_exists_several=子供{id}が存在し、
# there exists a child {id} such that
type_Child_sci_exists_simple=子供{id}が存在し、
# for every children {id},
type_Child_sci_forall_several=任意の子供{id}について、
# for every child {id},
type_Child_sci_forall_simple=任意の子供{id}について、
type_Child_sci_letin_several=
type_Child_sci_letin_simple=
# interval
type_Domain_arg=区間
# Let {id} be an interval
type_Domain_dec={id}を区間とする
# Let the interval {id} defined by {body}
type_Domain_dec_body={id}を区間{body}とする
# there exist intervals {id} such as,
type_Domain_exists_several=空間{id}が存在し、
# there exists an interval {id} such that,
type_Domain_exists_simple=空間{id}が存在し、
# for every intervals {id};
type_Domain_forall_several=任意の空間{id}について、
# for every interval {id}
type_Domain_forall_simple=任意の空間{id}について、
type_Domain_letin_several=
type_Domain_letin_simple=
# interval
type_Domain_sci_arg=空間
# Let {id} be an interval
type_Domain_sci_dec={id}を区間とする
# Let {id} = {body}
type_Domain_sci_dec_body={id}を{body}とする
type_Domain_sci_exists_several=∃ {id},
type_Domain_sci_exists_simple=∃ {id},
type_Domain_sci_forall_several=∀ {id},
type_Domain_sci_forall_simple=∀ {id},
type_Domain_sci_letin_several=
type_Domain_sci_letin_simple=
type_ExSet_arg={id}
# Let {id} be a set
type_ExSet_dec={id}を集合とする
# Let {id} be a set defined by {body}
type_ExSet_dec_body={id}を集合{body}とする
# there exist sets {id} such that
type_ExSet_exists_several=集合{id}が存在し、
# there exists a set  {id} such that
type_ExSet_exists_simple=集合{id}が存在し、
# for every sets {id},
type_ExSet_forall_several=任意の集合{id}について
# for every set {id}
type_ExSet_forall_simple=任意の集合{id}について
type_ExSet_letin_several=
type_ExSet_letin_simple=
type_ExSet_sci_arg={id}
# Let {id} be a set
type_ExSet_sci_dec=集合{id}が存在し、
# Let {id} be a set defined by {body}
type_ExSet_sci_dec_body={id}を集合{body}とする
# there exist sets {id} such that
type_ExSet_sci_exists_several=集合{id}が存在し、
# there exists a set  {id} such that
type_ExSet_sci_exists_simple=集合{id}が存在し、
# for every sets {id},
type_ExSet_sci_forall_several=任意の集合{id}について
# for every set {id},
type_ExSet_sci_forall_simple=任意の集合{id}について
type_ExSet_sci_letin_several=
type_ExSet_sci_letin_simple=
# function from ℝ to ℝ
type_ExprFun_arg=ℝからℝまでの関数
# Let {id} be a function from ℝ to ℝ
type_ExprFun_dec={id}をℝからℝまでの関数とする
# Let {id} be a function from ℝ to ℝ defined by {body}
type_ExprFun_dec_body={id}をℝからℝまでの関数{body}とする
type_ExprFun_exists_several=
type_ExprFun_exists_simple=
# for every functions {id} from ℝ to ℝ,
type_ExprFun_forall_several=任意のℝからℝまでの関数{id}について
# for every function {id} from ℝ to ℝ,
type_ExprFun_forall_simple=任意のℝからℝまでの関数{id}について
type_ExprFun_letin_several=
type_ExprFun_letin_simple=
type_ExprFun_sci_arg=
# Let f : ℝ→ℝ
type_ExprFun_sci_dec=f : ℝ→ℝとする
# Let f : ℝ→ℝ defined by {body}
type_ExprFun_sci_dec_body=[??]f : ℝ→ℝ、{body}とする
type_ExprFun_sci_exists_several=
type_ExprFun_sci_exists_simple=
type_ExprFun_sci_forall_several=
type_ExprFun_sci_forall_simple=
type_ExprFun_sci_letin_several=
type_ExprFun_sci_letin_simple=
# real number
type_Expr_arg=実数
# Let {id} be a real number
type_Expr_dec={id}を実数とする
# Let {id} be a real number defined by {body}
type_Expr_dec_body={id}を{body}となるような実数とする
# there exist real numbers {id} such that
type_Expr_exists_several=以下の性質を満す実数{id}が存在する
# there  exists a real number {id} such that
type_Expr_exists_simple=以下の性質を満す実数{id}が存在する
type_Expr_forall_several=任意の実数{id}について,
type_Expr_forall_simple=任意の実数{id}について,
type_Expr_letin_several=
# {id} the real {id} defined by {body}
type_Expr_letin_simple=[!!]{id} the real {id} defined by {body}
type_Expr_sci_arg=ℝ
# Let {id} {math:∊} ℝ
type_Expr_sci_dec={id} {math:∊} ℝとする
# Let {id}={body}
type_Expr_sci_dec_body={id}={body}とする
type_Expr_sci_exists_several=∃ {pair_id} {math:∊} {cartesian_type},
type_Expr_sci_exists_simple=∃ {id} {math:∊} ℝ,
type_Expr_sci_forall_several=∀ {pair_id} {math:∊} {cartesian_type},
type_Expr_sci_forall_simple=∀ {id} {math:∊} ℝ,
type_Expr_sci_letin_several=
type_Expr_sci_letin_simple={id} {math:∊} ℝ, {id} = {body}
type_FRel_arg=
type_FRel_dec=
type_FRel_dec_body=
type_FRel_exists_several=
type_FRel_exists_simple=
type_FRel_forall_several=
type_FRel_forall_simple=
type_FRel_letin_several=
type_FRel_letin_simple=
type_FRel_sci_arg={2}×{3}
# Soit {id} ⊆ {2}×{3}
type_FRel_sci_dec={id} ⊆ {2}×{3}とする
type_FRel_sci_dec_body=
type_FRel_sci_exists_several=
type_FRel_sci_exists_simple=
type_FRel_sci_forall_several=∀ {cartesian_id} ⊆ {cartesian_type},
type_FRel_sci_forall_simple=∀ {id} ⊆ {2}×{3},
type_FRel_sci_letin_several=
type_FRel_sci_letin_simple=
# the function defined on {2}
type_FunDef_arg={2}の上の関数
# Let {id} be a function defined on {2}
type_FunDef_dec={id}を{2}の上の関数とする
# Let {id} be a function defined on {2} by {body}
type_FunDef_dec_body={id}を{2}の上の関数{body}とする
# there exist {id} functions on {2} such that,
type_FunDef_exists_several={2}の上の関数{id}が存在し、
# there exists {id} a function defined on {2} such that,
type_FunDef_exists_simple={2}の上に定義されている関数{id}が存在し、
# for  every function defined on {2} {id},
type_FunDef_forall_several=任意の{2}の上の関数{id}について、
# for every function defined on {2} {id},
type_FunDef_forall_simple=任意の{2}の上の関数{id}について、
type_FunDef_letin_several=
# {id} is the function on {2} by {body}
type_FunDef_letin_simple={id}を{2}の上の関数{body}とする
type_FunDef_sci_arg={2}→{2}
# Let {id}: {2}→{2}
type_FunDef_sci_dec={id}: {2}→{2}とする
# Let {id}: {2}→{2} defined by {body}
type_FunDef_sci_dec_body=[??]{body}で与えられる{id}: {2}→{2}
type_FunDef_sci_exists_several=∃ {pair_id} : {2}→{2},
type_FunDef_sci_exists_simple=∃ {id} : {2}→{2},
type_FunDef_sci_forall_several=∀ {pair_id} : {2}→{2},
type_FunDef_sci_forall_simple=∀ {id} : {2}→{2},
type_FunDef_sci_letin_several=
# {id} is the function on {2} by {body}
type_FunDef_sci_letin_simple={id}が{2}の上の関数{body}である
# the function
type_FunUnknown_arg=関数
# Let {id} be a function
type_FunUnknown_dec={id}を関数とする
# Let {id} be a function defined on {0}{2}{/0} by {body}
type_FunUnknown_dec_body={id}を{0}{2}{/0}の上の関数{body}とする
# there exist functions {id} such as,
type_FunUnknown_exists_several=関数{id}が存在し、
# there exist a function {id} such that,
type_FunUnknown_exists_simple=関数{id}が存在し、
# for every functions {id},
type_FunUnknown_forall_several=任意の関数{id}について、
# for every function {id},
type_FunUnknown_forall_simple=任意の関数{id}について、
type_FunUnknown_letin_several=
# {id} is the function defined by {body}
type_FunUnknown_letin_simple={id}が関数{body}である
type_FunUnknown_sci_arg={0}→{1}
# Let {id}: {0}→{1}
type_FunUnknown_sci_dec={id}: {0}→{1}とする
# Let {id}:{0}→{1} defined by {body}
type_FunUnknown_sci_dec_body=[??]{body}で与えられる{id}: {2}→{2}
type_FunUnknown_sci_exists_several=∃ {pair_id} : {0}→{1},
type_FunUnknown_sci_exists_simple=∃ {id} : {0}→{1},
type_FunUnknown_sci_forall_several=∀ {pair_id} : {0}→{1},
type_FunUnknown_sci_forall_simple=∀ {id} : {0}→{1},
type_FunUnknown_sci_letin_several=
type_FunUnknown_sci_letin_simple=
# function from {2} to {3}
type_Fun_arg={2}から{3}までの関数
# Let {id} be a function from {2} to {3}
type_Fun_dec={id}を{2}から{3}までの関数とする
# Let {id} be a function from {2} to {3} defined by {body}
type_Fun_dec_body={id}を{2}から{3}までの関数{body}とする
# there exist {id} functions from {2} to {3},
type_Fun_exists_several={2}から{3}までの関数{id}が存在し、
# there exists {id} a function form {2} to {3},
type_Fun_exists_simple={2}から{3}までの関数{id}が存在し、
# for every functions {id} from {2} to {3},
type_Fun_forall_several={2}から{3}までの任意の関数{id}について、
# for every function {id} from {2} to {3},
type_Fun_forall_simple={2}から{3}までの任意の関数{id}について、
type_Fun_letin_several=
# {id} is the application from {2} to {3} defined by {body}
type_Fun_letin_simple={id}が{2}から{3}までの適用{body}である
type_Fun_sci_arg={2}→{3}
type_Fun_sci_dec={id} : {2}→{3}とする
# Let {id} be a function from {2} to {3} defined by {body}
type_Fun_dec_body={id}を{2}から{3}までの関数{body}とする
# {id} : {2}→{3} defined by {body}
type_Fun_sci_dec_body=[??]{body}で与えられる{id}: {2}→{3}
type_Fun_sci_exists_several=∃ {pair_id} : {2}→{3},
type_Fun_sci_exists_simple=∃ {id} : {2}→{3},
type_Fun_sci_forall_several=∀ {pair_id} : {2}→{3},
type_Fun_sci_forall_simple=∀ {id} : {2}→{3},
type_Fun_sci_letin_several=
# {id} is the application from {2} to {3} defined by {body}
type_Fun_sci_letin_simple={id}が{2}から{3}までの適用{body}である
# color
type_HatColor_arg=色
# Let {id} be a color
type_HatColor_dec={id}を色とする
type_HatColor_dec_body=
# there exist colors {id} such that,
type_HatColor_exists_several=色{id}が存在し、
# there exists a color {id} such that,
type_HatColor_exists_simple=色{id}が存在し、
# for every colors {id},
type_HatColor_forall_several=任意の色{id}に対し、
# for every color {id},
type_HatColor_forall_simple=任意の色{id}に対し、
type_HatColor_letin_several=
type_HatColor_letin_simple=
# limit value
type_LimitExpr_arg=極限値
# Let {id} be a limit value
type_LimitExpr_dec={id}を極限値とする
# Let the limit value {id} = {body}
type_LimitExpr_dec_body=極限値として{id} = {body}をとる
# there exist limit values such that,
type_LimitExpr_exists_several=以下のような極限値が存在し、
# there exist a limit value {id} such that,
type_LimitExpr_exists_simple=以下のような極限値{id}が存在し、
# for every limit values {id}
type_LimitExpr_forall_several=任意の極限値{id}について,
# for every limit value {id},
type_LimitExpr_forall_simple=任意の極限値{id}について,
type_LimitExpr_letin_several=
type_LimitExpr_letin_simple=
type_LimitExpr_sci_arg=
type_LimitExpr_sci_dec=
type_LimitExpr_sci_dec_body=
type_LimitExpr_sci_exists_several=
type_LimitExpr_sci_exists_simple=
type_LimitExpr_sci_forall_several=
type_LimitExpr_sci_forall_simple=
type_LimitExpr_sci_letin_several=
type_LimitExpr_sci_letin_simple=

## Daisuke

# the neighborhood of {0}
type_Neighborhood_arg={0}の近傍
# Let {id} be a neighborhood of {0}
type_Neighborhood_dec={id}を{0}の近傍とする
# Let {id} be a neighborhood of {0} defined by {body}
type_Neighborhood_dec_body={id}を{0}の近傍として{body}で定義する
# there exist neighborhoods of {0} {id} such that,
type_Neighborhood_exists_several=以下を満たす{0}の近傍{id}が存在する,
# there exists a neighborhood of {0} {id} such that,
type_Neighborhood_exists_simple=以下を満たす{0}の近傍{id}が存在する,
# for every neighborhoods of {0} {id},
type_Neighborhood_forall_several={0}の近傍{id}のそれぞれについて,
# for every neighborhood of {0} {id},
type_Neighborhood_forall_simple={0}の近傍{id}のそれぞれについて,
type_Neighborhood_letin_several=
# {id} the neighborhood of {0} defined by {body}
type_Neighborhood_letin_simple={body}で定義される{0}の近傍{id}
type_Neighborhood_sci_arg=𝓥({0})
# Let {id} {math:∊} 𝓥({0})
type_Neighborhood_sci_dec={id} {math:∊} 𝓥({0})とする
# Let {id}={body}
type_Neighborhood_sci_dec_body={id}={body}とする
type_Neighborhood_sci_exists_several=∃ {pair_id} {math:∊} 𝓥({0}),
type_Neighborhood_sci_exists_simple=∃ {id} {math: 𝓥 ε} ( {0} )
type_Neighborhood_sci_forall_several={} {∀ pair_id math: 𝓥 ε} ( {0} )
type_Neighborhood_sci_forall_simple=∀ {id} {math: 𝓥 ε} ( {0} )
type_Neighborhood_sci_letin_several=
type_Neighborhood_sci_letin_simple=
# function form ℕ to ℕ
type_NvarFun_arg=ℕからℕへの関数
# Let {id} be a function from ℕ to ℕ
type_NvarFun_dec={id}をℕからℕへの関数とする
# Let {id} be a function from ℕ to ℕ defined by {body}
type_NvarFun_dec_body={id}をℕからℕへの関数として{body}で定義する
type_NvarFun_exists_several=
type_NvarFun_exists_simple=
# for every functions {id} from ℕ to ℕ,
type_NvarFun_forall_several=ℕからℕへの関数{id}のそれぞれについて,
# for every function {id} from ℕ to ℕ,
type_NvarFun_forall_simple=ℕからℕへの関数{id}のそれぞれについて,
type_NvarFun_letin_several=
# type_NvarFun_letin_simple={id} is the application of ℕ to ℕ defined by {body}
# [!!]適用？
type_NvarFun_letin_simple={id}をℕからℕへの適用として{body}で定義する
type_NvarFun_sci_arg=
# Let f : ℕ→ℕ
type_NvarFun_sci_dec=f : ℕ→ℕとする
# Let f : ℕ→ℕ defined by {body}
type_NvarFun_sci_dec_body=f : ℕ→ℕとして{body}で定義する
type_NvarFun_sci_exists_several=
type_NvarFun_sci_exists_simple=
type_NvarFun_sci_forall_several=
type_NvarFun_sci_forall_simple=
type_NvarFun_sci_letin_several=
# {id} is the application of ℕ to ℕ defined by {body}
type_NvarFun_sci_letin_simple={id}をℕからℕへの適用として{body}で定義する
type_NvarProp_arg=
# Let {id} be a proposition defined on ℕ
type_NvarProp_dec={id}をℕ上で定義された命題とする
# Let {id} be a proposition defined at rank {var} by {body}
# [!!] rank?
type_NvarProp_dec_body={id}をℕ上で定義されたrank{var}の命題として{body}で定義する
type_NvarProp_exists_several=
type_NvarProp_exists_simple=
type_NvarProp_forall_several=
# for every proposition {id} defined on ℕ
type_NvarProp_forall_simple=ℕ上で定義された命題{id}のそれぞれについて
type_NvarProp_letin_several=
type_NvarProp_letin_simple=
type_NvarProp_sci_arg=
# Let {id} be a proposition defined on ℕ
type_NvarProp_sci_dec={id}をℕ上で定義された命題とする
# Let {id} be a proposition defined at rank {var} by {body}
# [!!] rank(同上)
type_NvarProp_sci_dec_body={id}をℕ上で定義されたrank{var}の命題として{body}で定義する
type_NvarProp_sci_exists_several=
type_NvarProp_sci_exists_simple=
type_NvarProp_sci_forall_several=
# for every proposition {id} defined on ℕ,
type_NvarProp_sci_forall_simple=for every proposition {id} defined on ℕ,
type_NvarProp_sci_letin_several=
type_NvarProp_sci_letin_simple=
type_NvarRel_arg=
# Let {id} be a proposition defined on ℕ×ℕ
type_NvarRel_dec=Let {id} be a proposition defined on ℕ×ℕ
type_NvarRel_dec_body=
type_NvarRel_exists_several=
type_NvarRel_exists_simple=
type_NvarRel_forall_several=
# for every proposition {id} defined on ℕ×ℕ,
type_NvarRel_forall_simple=for every proposition {id} defined on ℕ×ℕ,
type_NvarRel_letin_several=
type_NvarRel_letin_simple=
# integer
type_Nvar_arg=integer
# type_Nvar_dec=Let {id} be an integer
type_Nvar_dec=Let {id} be an integer
# type_Nvar_dec_body=Let {id} be an integer defined by {body}
type_Nvar_dec_body=Let {id} be an integer defined by {body}
# type_Nvar_exists_several=there exist integers {id} such that
type_Nvar_exists_several=there exist integers {id} such that
# type_Nvar_exists_simple=there exists an integer {id} such that
type_Nvar_exists_simple=there exists an integer {id} such that
# type_Nvar_forall_several=for every integers {id},
type_Nvar_forall_several=for every integers {id},
# type_Nvar_forall_simple=for every integer {id},
type_Nvar_forall_simple=for every integer {id},
type_Nvar_letin_several=
type_Nvar_letin_simple=
type_Nvar_sci_arg=ℕ
# type_Nvar_sci_dec=Let {id} {math:∊} ℕ
type_Nvar_sci_dec=Let {id} {math:∊} ℕ
# type_Nvar_sci_dec_body=Let {id}={body}
type_Nvar_sci_dec_body=Let {id}={body}
type_Nvar_sci_exists_several=∃ {pair_id} {math:∊} {cartesian_type},
type_Nvar_sci_exists_simple=∃ {id} {math:∊} ℕ,
type_Nvar_sci_forall_several=∀ {pair_id} {math:∊} {cartesian_type},
type_Nvar_sci_forall_simple=∀ {id} {math:∊} ℕ,
type_Nvar_sci_letin_several=
type_Nvar_sci_letin_simple=
# type_O1BinRel_arg=binary relation on {0}
type_O1BinRel_arg=binary relation on {0}
# type_O1BinRel_dec=Let {id} be a binary relation on {0}
type_O1BinRel_dec=Let {id} be a binary relation on {0}
# type_O1BinRel_dec_body=Let {id} be a binary relation on {0} defined by {body}
type_O1BinRel_dec_body=Let {id} be a binary relation on {0} defined by {body}
# type_O1BinRel_exists_several=there exist binary relations {id} on {0} such that
type_O1BinRel_exists_several=there exist binary relations {id} on {0} such that
# type_O1BinRel_exists_simple=there exists a binary relation {id} on {0} such that
type_O1BinRel_exists_simple=there exists a binary relation {id} on {0} such that
# type_O1BinRel_forall_several=for every binary relations {id} on {0},
type_O1BinRel_forall_several=for every binary relations {id} on {0},
# type_O1BinRel_forall_simple=for every binary relation {id} on {0},
type_O1BinRel_forall_simple=for every binary relation {id} on {0},
type_O1BinRel_letin_several=
type_O1BinRel_letin_simple=
type_O1BinRel_sci_arg=({0}×{0})
# type_O1BinRel_sci_dec=Let {id} ⊆ {0}×{0}
type_O1BinRel_sci_dec=Let {id} ⊆ {0}×{0}
# type_O1BinRel_sci_dec_body=Let {id} be a binary relation on {0} defined {body}
type_O1BinRel_sci_dec_body=Let {id} be a binary relation on {0} defined {body}
type_O1BinRel_sci_exists_several=∃ {cartesian_id} ⊆ {cartesian_type},
type_O1BinRel_sci_exists_simple=∃ {id} ⊆ {0}×{0},
type_O1BinRel_sci_forall_several=∀ {cartesian_id} ⊆ {cartesian_type},
type_O1BinRel_sci_forall_simple=∀ {id} ⊆ {0}×{0},
type_O1BinRel_sci_letin_several=
type_O1BinRel_sci_letin_simple=
# type_O1ExSet_arg=set
type_O1ExSet_arg=set
# type_O1ExSet_dec=Let {id} be a set
type_O1ExSet_dec=Let {id} be a set
# type_O1ExSet_dec_body=Let {id}={body}
type_O1ExSet_dec_body=Let {id}={body}
# type_O1ExSet_exists_several=there exist sets {id} such that
type_O1ExSet_exists_several=there exist sets {id} such that
# type_O1ExSet_exists_simple=there exists a set {id} such that
type_O1ExSet_exists_simple=there exists a set {id} such that
# type_O1ExSet_forall_several=for every sets {id},
type_O1ExSet_forall_several=for every sets {id},
# type_O1ExSet_forall_simple=for every set {id},
type_O1ExSet_forall_simple=for every set {id},
type_O1ExSet_letin_several=
type_O1ExSet_letin_simple=
# type_O1ExSet_sci_arg=set
type_O1ExSet_sci_arg=set
# type_O1ExSet_sci_dec=Let {id} be a set
type_O1ExSet_sci_dec=Let {id} be a set
# type_O1ExSet_sci_dec_body=Let {id}={body}
type_O1ExSet_sci_dec_body=Let {id}={body}
type_O1ExSet_sci_exists_several=∃ {id},
type_O1ExSet_sci_exists_simple=∃ {id},
# type_O1ExSet_sci_forall_several=for every sets {id},
type_O1ExSet_sci_forall_several=for every sets {id},
# type_O1ExSet_sci_forall_simple=for every set {id},
type_O1ExSet_sci_forall_simple=for every set {id},
type_O1ExSet_sci_letin_several=
type_O1ExSet_sci_letin_simple=
# type_O1Fun_arg=function from {0} to {1}
type_O1Fun_arg=function from {0} to {1}
# type_O1Fun_dec=Let {id} be a function from {0} to {1}
type_O1Fun_dec=Let {id} be a function from {0} to {1}
# type_O1Fun_dec_body=Let {id} be a function from {0} to {1} defined by {body}
type_O1Fun_dec_body=Let {id} be a function from {0} to {1} defined by {body}
# type_O1Fun_exists_several=there exist functions {id} from {0} to {1} such that
type_O1Fun_exists_several=there exist functions {id} from {0} to {1} such that
# type_O1Fun_exists_simple=there exists a function {id} from {0} to {1} such that
type_O1Fun_exists_simple=there exists a function {id} from {0} to {1} such that
# type_O1Fun_forall_several=for every functions {id} from {0} to {1},
type_O1Fun_forall_several=for every functions {id} from {0} to {1},
# type_O1Fun_forall_simple=for every function {id} from {0} to {1},
type_O1Fun_forall_simple=for every function {id} from {0} to {1},
type_O1Fun_letin_several=
type_O1Fun_letin_simple=
type_O1Fun_sci_arg={0}→{1}
# type_O1Fun_sci_dec=Let {id} : {0}→{1}
type_O1Fun_sci_dec=Let {id} : {0}→{1}
# type_O1Fun_sci_dec_body=Let {id} : {0}→{1} defined by {body}
type_O1Fun_sci_dec_body=Let {id} : {0}→{1} defined by {body}
type_O1Fun_sci_exists_several=∃ {pair_id} : {0}→{1},
type_O1Fun_sci_exists_simple=∃ {id} : {0}→{1},
type_O1Fun_sci_forall_several=∀ {pair_id} : {0}→{1},
type_O1Fun_sci_forall_simple=∀ {id} : {0}→{1},
type_O1Fun_sci_letin_several=
type_O1Fun_sci_letin_simple=
# type_O1Rel_arg=relation de {0}×{1}
# [!!] deになってるｗ
type_O1Rel_arg=relation de {0}×{1}
# type_O1Rel_dec=Let {id} be a relation on {0}×{1}
type_O1Rel_dec=Let {id} be a relation on {0}×{1}
# type_O1Rel_dec_body=Let {id} be a relation on {0}×{1} defined by {body}
type_O1Rel_dec_body=Let {id} be a relation on {0}×{1} defined by {body}
# type_O1Rel_exists_several=there exist relations {id} on {0}×{1} such that
type_O1Rel_exists_several=there exist relations {id} on {0}×{1} such that
# type_O1Rel_exists_simple=there exists a relation {id} on {0}×{1} such that
type_O1Rel_exists_simple=there exists a relation {id} on {0}×{1} such that
# type_O1Rel_forall_several=for every relations {id} on {0}×{1},
type_O1Rel_forall_several=for every relations {id} on {0}×{1},
# type_O1Rel_forall_simple=for every relation {id} on {0}×{1},
type_O1Rel_forall_simple=for every relation {id} on {0}×{1},
type_O1Rel_letin_several=
type_O1Rel_letin_simple=
type_O1Rel_sci_arg=({0}×{1})
# type_O1Rel_sci_dec=Let {id} ⊆ {0}×{1}
type_O1Rel_sci_dec=Let {id} ⊆ {0}×{1}
# type_O1Rel_sci_dec_body=Let {id} ⊆ {0}×{1} defined by {body}
type_O1Rel_sci_dec_body=Let {id} ⊆ {0}×{1} defined by {body}
type_O1Rel_sci_exists_several=∃ {cartesian_id} ⊆ {cartesian_type},
type_O1Rel_sci_exists_simple=∃ {id} ⊆ {0}×{1},
type_O1Rel_sci_forall_several=∀ {cartesian_id} ⊆ {cartesian_type},
type_O1Rel_sci_forall_simple=∀ {id} ⊆ {0}×{1},
type_O1Rel_sci_letin_several=
type_O1Rel_sci_letin_simple=
type_O1SetProp2_arg=formula
# type_O1SetProp2_dec=Let {id} be a formula
type_O1SetProp2_dec=Let {id} be a formula
# type_O1SetProp2_dec_body=Let {id} be a formula defined by {body}
type_O1SetProp2_dec_body=Let {id} be a formula defined by {body}
# type_O1SetProp2_exists_several=there exist formulas {id} such that
type_O1SetProp2_exists_several=there exist formulas {id} such that
# type_O1SetProp2_exists_simple=there exists a formula {id} such that
type_O1SetProp2_exists_simple=there exists a formula {id} such that
# type_O1SetProp2_forall_several=for every formulas {id},
type_O1SetProp2_forall_several=for every formulas {id},
# type_O1SetProp2_forall_simple=for every formula {id},
type_O1SetProp2_forall_simple=for every formula {id},
type_O1SetProp2_letin_several=
type_O1SetProp2_letin_simple=
# type_O1SetProp2_sci_arg=formula
type_O1SetProp2_sci_arg=formula
# type_O1SetProp2_sci_dec=Let {id} be a formula
type_O1SetProp2_sci_dec=Let {id} be a formula
# type_O1SetProp2_sci_dec_body=Let {id} be a formula defined by {body}
type_O1SetProp2_sci_dec_body=Let {id} be a formula defined by {body}
# type_O1SetProp2_sci_exists_several=there exist formulas {id} such that
type_O1SetProp2_sci_exists_several=there exist formulas {id} such that
# type_O1SetProp2_sci_exists_simple=there exists a formula {id} such that
type_O1SetProp2_sci_exists_simple=there exists a formula {id} such that
# type_O1SetProp2_sci_forall_several=for every formulas {id},
type_O1SetProp2_sci_forall_several=for every formulas {id},
# type_O1SetProp2_sci_forall_simple=for every formula {id},
type_O1SetProp2_sci_forall_simple=for every formula {id},
type_O1SetProp2_sci_letin_several=
type_O1SetProp2_sci_letin_simple=
# type_O1SetProp_arg=formula
type_O1SetProp_arg=formula
# type_O1SetProp_dec=Let {id} be a formula
type_O1SetProp_dec=Let {id} be a formula
# type_O1SetProp_dec_body=Let {id} be a formula defined by {body}
type_O1SetProp_dec_body=Let {id} be a formula defined by {body}
# type_O1SetProp_exists_several=there exist formulas {id} such that
type_O1SetProp_exists_several=there exist formulas {id} such that
# type_O1SetProp_exists_simple=there exists a formula {id} such that
type_O1SetProp_exists_simple=there exists a formula {id} such that
# type_O1SetProp_forall_several=for every formulas {id},
type_O1SetProp_forall_several=for every formulas {id},
# type_O1SetProp_forall_simple=for every formula {id},
type_O1SetProp_forall_simple=for every formula {id},
type_O1SetProp_letin_several=
type_O1SetProp_letin_simple=
# type_O1U_arg=universe
type_O1U_arg=universe
# type_O1U_dec=Let {id} be an element
type_O1U_dec=Let {id} be an element
# type_O1U_dec_body=Let {id} be the element {body}
type_O1U_dec_body=Let {id} be the element {body}
# type_O1U_exists_several=there exist element {id} such that
type_O1U_exists_several=there exist element {id} such that
# type_O1U_exists_simple=there exists an element {id} such that
type_O1U_exists_simple=there exists an element {id} such that
# type_O1U_forall_several=for every elements {id},
type_O1U_forall_several=for every elements {id},
# type_O1U_forall_simple=for every element {id},
type_O1U_forall_simple=for every element {id},
type_O1U_letin_several=
type_O1U_letin_simple=
# type_O1U_sci_arg=universe
type_O1U_sci_arg=universe
# type_O1U_sci_dec=Let {id} be an element
type_O1U_sci_dec=Let {id} be an element
# type_O1U_sci_dec_body=Let {id}={body}
type_O1U_sci_dec_body=Let {id}={body}
type_O1U_sci_exists_several=∃ {id},
type_O1U_sci_exists_simple=∃ {id},
type_O1U_sci_forall_several=∀ {id},
type_O1U_sci_forall_simple=∀ {id},
type_O1U_sci_letin_several=
type_O1U_sci_letin_simple=
type_PHITYPE_arg=
type_PHITYPE_dec=
type_PHITYPE_dec_body=
type_PHITYPE_exists_several=
type_PHITYPE_exists_simple=
type_PHITYPE_forall_several=
type_PHITYPE_forall_simple=
type_PHITYPE_letin_several=
# type_PHITYPE_letin_simple={id} is the function from ℘({2}) to ℘({0})×℘({1}) defined by {body}
type_PHITYPE_letin_simple={id} is the function from ℘({2}) to ℘({0})×℘({1}) defined by {body}
type_PHITYPE_sci_arg=
type_PHITYPE_sci_dec=
# type_PHITYPE_sci_dec_body=Let {id} : ℘({2})→℘({0})×℘({1}) defined by {body}
type_PHITYPE_sci_dec_body=Let {id} : ℘({2})→℘({0})×℘({1}) defined by {body}
type_PHITYPE_sci_exists_several=
type_PHITYPE_sci_exists_simple=
type_PHITYPE_sci_forall_several=
type_PHITYPE_sci_forall_simple=
type_PHITYPE_sci_letin_several=
# type_PHITYPE_sci_letin_simple={id} : ℘({2})→℘({0})×℘({1}) defined by {body}
type_PHITYPE_sci_letin_simple={id} : ℘({2})→℘({0})×℘({1}) defined by {body}
# type_Point_arg=point
type_Point_arg=point
# type_Point_dec=Let {id} be a point
type_Point_dec=Let {id} be a point
# type_Point_dec_body=Let {id} be a point defined by {body}
type_Point_dec_body=Let {id} be a point defined by {body}
# type_Point_exists_several=there exist points {id} such that
type_Point_exists_several=there exist points {id} such that
# type_Point_exists_simple=there exists a point {id} such that
type_Point_exists_simple=there exists a point {id} such that
# type_Point_forall_several=for every points {id},
type_Point_forall_several=for every points {id},
# type_Point_forall_simple=for every point {id},
type_Point_forall_simple=for every point {id},
type_Point_letin_several=
type_Point_letin_simple=
# type_Prop_arg=proposition
type_Prop_arg=proposition
# type_Prop_dec=Let {id} be a proposition
type_Prop_dec=Let {id} be a proposition
# type_Prop_dec_body=Let {id} be a proposition defined by {body}
type_Prop_dec_body=Let {id} be a proposition defined by {body}
# type_Prop_exists_several=there exist propositions {id} such that
type_Prop_exists_several=there exist propositions {id} such that
# type_Prop_exists_simple=there exist a proposition {id} such that
type_Prop_exists_simple=there exist a proposition {id} such that
# type_Prop_forall_several=for every propositions {id},
type_Prop_forall_several=for every propositions {id},
# type_Prop_forall_simple=for every proposition {id},
type_Prop_forall_simple=for every proposition {id},
type_Prop_letin_several=
type_Prop_letin_simple=
type_Rel_arg=({2}×{3})
# type_Rel_dec=Let {id} be a relation on {2}×{3}
type_Rel_dec=Let {id} be a relation on {2}×{3}
# type_Rel_dec_body=Let {id} be a relation on {2}×{3} defined by {body}
type_Rel_dec_body=Let {id} be a relation on {2}×{3} defined by {body}
# type_Rel_exists_several=there exist relations {id} on {2}×{3} such that
type_Rel_exists_several=there exist relations {id} on {2}×{3} such that
# type_Rel_exists_simple=there exists a relation {id} on {2}×{3} such that
type_Rel_exists_simple=there exists a relation {id} on {2}×{3} such that
# type_Rel_forall_several=for every relations {id} on {2}×{3},
type_Rel_forall_several=for every relations {id} on {2}×{3},
# type_Rel_forall_simple=for every relation {id} on {2}×{3},
type_Rel_forall_simple=for every relation {id} on {2}×{3},
type_Rel_letin_several=
type_Rel_letin_simple=
type_Rel_sci_arg=({2}×{3})
# type_Rel_sci_dec=Let {id} ⊆ {2}×{3}
type_Rel_sci_dec=Let {id} ⊆ {2}×{3}
# type_Rel_sci_dec_body=Let {id} be a relation on {2}×{3} defined by {body}
type_Rel_sci_dec_body=Let {id} be a relation on {2}×{3} defined by {body}
type_Rel_sci_exists_several=∃ {cartesian_id} ⊆ {cartesian_type},
type_Rel_sci_exists_simple=∃ {id} ⊆ {2}×{3},
type_Rel_sci_forall_several=∀ {cartesian_id} ⊆ {cartesian_type},
type_Rel_sci_forall_simple=∀ {id} ⊆ {2}×{3},
type_Rel_sci_letin_several=
type_Rel_sci_letin_simple=
#type_Series_arg=series
type_Series_arg=series
# type_Series_dec=Let {id} be a series
type_Series_dec=Let {id} be a series
# type_Series_dec_body=Let {id} be a series defined on {0} by {body} {dom_serie}
type_Series_dec_body=Let {id} be a series defined on {0} by {body} {dom_serie}
# type_Series_exists_several=there exist series {id} such that
type_Series_exists_several=there exist series {id} such that
# type_Series_exists_simple=there exists a series {id} such that
type_Series_exists_simple=there exists a series {id} such that
# type_Series_forall_several=for very series {id},
type_Series_forall_several=for very series {id},
# type_Series_forall_simple=for every series {id},
type_Series_forall_simple=for every series {id},
type_Series_letin_several=
# type_Series_letin_simple={id} be a series defined on {0} by {body}
type_Series_letin_simple={id} be a series defined on {0} by {body}
type_SetProp2_arg=
# type_SetProp2_dec=Let {id} be a proposition on {0}
type_SetProp2_dec=Let {id} be a proposition on {0}
type_SetProp2_dec_body=
type_SetProp2_exists_several=
type_SetProp2_exists_simple=
# type_SetProp2_forall_several=for every propositions {id} on {0},
type_SetProp2_forall_several=for every propositions {id} on {0},
# type_SetProp2_forall_simple=for every proposition {id} on {0},
type_SetProp2_forall_simple=for every proposition {id} on {0},
type_SetProp2_letin_several=
type_SetProp2_letin_simple=
type_SetProp2_sci_arg=
# type_SetProp2_sci_dec=Let {id} be a proposition on {0}
type_SetProp2_sci_dec=Let {id} be a proposition on {0}
type_SetProp2_sci_dec_body=
type_SetProp2_sci_exists_several=
type_SetProp2_sci_exists_simple=
# type_SetProp2_sci_forall_several=for every propositions {id} on {0},
type_SetProp2_sci_forall_several=for every propositions {id} on {0},
# type_SetProp2_sci_forall_simple=for every proposition {id} on {0},
type_SetProp2_sci_forall_simple=for every proposition {id} on {0},
type_SetProp2_sci_letin_several=
type_SetProp2_sci_letin_simple=
type_SetProp_arg=
# type_SetProp_dec=Let {id} be a proposition on {0}
type_SetProp_dec=Let {id} be a proposition on {0}
type_SetProp_dec_body=
type_SetProp_exists_several=
type_SetProp_exists_simple=
# type_SetProp_forall_several=for every propositions {id} on {0},
type_SetProp_forall_several=for every propositions {id} on {0},
# type_SetProp_forall_simple=for every proposition {id} on {0},
type_SetProp_forall_simple=for every proposition {id} on {0},
type_SetProp_letin_several=
type_SetProp_letin_simple=
type_UA_arg=A
# type_UA_dec=Let {type} {id}
type_UA_dec=Let {type} {id}
# type_UA_dec_body=Let {type} {id} = {body}
type_UA_dec_body=Let {type} {id} = {body}
type_UA_exists_several=∃ {id} {math:∊} {cartesian_type},
type_UA_exists_simple=∃ {id} {math:∊} {type},
type_UA_forall_several=∀ {id} {math:∊} {cartesian_type},
type_UA_forall_simple=∀ {id} {math:∊} {type},
type_UA_letin_several=
type_UA_letin_simple=
type_UA_sci_arg=A
# type_UA_sci_dec=Let {id} {math:∊} A
type_UA_sci_dec=Let {id} {math:∊} A
# type_UA_sci_dec_body=Let {id} = {body}
type_UA_sci_dec_body=Let {id} = {body}
type_UA_sci_exists_several=∃ {pair_id} {math:∊} {cartesian_type},
type_UA_sci_exists_simple=∃ {id} {math:∊} {type},
type_UA_sci_forall_several=∀ {pair_id} {math:∊} {cartesian_type},
type_UA_sci_forall_simple=∀ {id} {math:∊} {type},
type_UA_sci_letin_several=
type_UA_sci_letin_simple=
type_UB_arg=B
# type_UB_dec=Let {type} {id}
type_UB_dec=Let {type} {id}
# type_UB_dec_body=Let {type} {id} = {body}
type_UB_dec_body=Let {type} {id} = {body}
type_UB_exists_several=∃ {id} {math:∊} {cartesian_type},
type_UB_exists_simple=∃ {id} {math:∊} {type},
type_UB_forall_several=∀ {id} {math:∊} {cartesian_type},
type_UB_forall_simple=∀ {id} {math:∊} {type},
type_UB_letin_several=
type_UB_letin_simple=
type_UB_sci_arg=B
# type_UB_sci_dec=Let {id} {math:∊} B
type_UB_sci_dec=Let {id} {math:∊} B
# type_UB_sci_dec_body=Let {id} = {body}
type_UB_sci_dec_body=Let {id} = {body}
type_UB_sci_exists_several=∃ {pair_id} {math:∊} {cartesian_type},
type_UB_sci_exists_simple=∃ {id} {math:∊} {type},
type_UB_sci_forall_several=∀ {pair_id} {math:∊} {cartesian_type},
type_UB_sci_forall_simple=∀ {id} {math:∊} {type},
type_UB_sci_letin_several=
type_UB_sci_letin_simple=
type_UC_arg=C
# type_UC_dec=Let {type} {id}
type_UC_dec=Let {type} {id}
# type_UC_dec_body=Let {type} {id} = {body}
type_UC_dec_body=Let {type} {id} = {body}
type_UC_exists_several=∃ {id} {math:∊} {cartesian_type},
type_UC_exists_simple=∃ {id} {math:∊} {type},
type_UC_forall_several=∀ {id} {math:∊} {cartesian_type},
type_UC_forall_simple=∀ {id} {math:∊} {type},
type_UC_letin_several=
type_UC_letin_simple=
type_UC_sci_arg=C
# type_UC_sci_dec=Let {id} {math:∊} C
type_UC_sci_dec=Let {id} {math:∊} C
# type_UC_sci_dec_body=Let {id} = {body}
type_UC_sci_dec_body=Let {id} = {body}
type_UC_sci_exists_several=∃ {pair_id} {math:∊} {cartesian_type},
type_UC_sci_exists_simple=∃ {id} {math:∊} {type},
type_UC_sci_forall_several=∀ {pair_id} {math:∊} {cartesian_type},
type_UC_sci_forall_simple=∀ {id} {math:∊} {type},
type_UC_sci_letin_several=
type_UC_sci_letin_simple=
type_UE_arg=E
# type_UE_dec=Let {type} {id}
type_UE_dec=Let {type} {id}
# type_UE_dec_body=Let {type} {id} = {body}
type_UE_dec_body=Let {type} {id} = {body}
type_UE_exists_several=∃ {id} {math:∊} {cartesian_type},
type_UE_exists_simple=∃ {id} {math:∊} {type},
type_UE_forall_several=∀ {id} {math:∊} {cartesian_type},
type_UE_forall_simple=∀ {id} {math:∊} {type},
type_UE_letin_several=
type_UE_letin_simple=
type_UE_sci_arg=E
# type_UE_sci_dec=Let {id} {math:∊} E
type_UE_sci_dec=Let {id} {math:∊} E
# type_UE_sci_dec_body=Let {id} = {body}
type_UE_sci_dec_body=Let {id} = {body}
type_UE_sci_exists_several=∃ {pair_id} {math:∊} {cartesian_type},
type_UE_sci_exists_simple=∃ {id} {math:∊} {type},
type_UE_sci_forall_several=∀ {pair_id} {math:∊} {cartesian_type},
type_UE_sci_forall_simple=∀ {id} {math:∊} {type},
type_UE_sci_letin_several=
type_UE_sci_letin_simple=
type_U_arg={id}
# type_U_dec=Let {type} {id}
type_U_dec=Let {type} {id}
# type_U_dec_body=Let {type} {id} = {body}
type_U_dec_body=Let {type} {id} = {body}
type_U_exists_several=∃ {id} {math:∊} {cartesian_type},
type_U_exists_simple=∃ {id} {math:∊} {type},
type_U_forall_several=∀ {id} {math:∊} {cartesian_type},
type_U_forall_simple=∀ {id} {math:∊} {type},
type_U_letin_several=
type_U_letin_simple=
type_U_sci_arg={id}
# type_U_sci_dec=Let {id} {math:∊} {type}
type_U_sci_dec=Let {id} {math:∊} {type}
# type_U_sci_dec_body=Let {id} = {body}
type_U_sci_dec_body=Let {id} = {body}
type_U_sci_exists_several=∃ {pair_id} {math:∊} {cartesian_type},
type_U_sci_exists_simple=∃ {id} {math:∊} {type},
type_U_sci_forall_several=∀ {pair_id} {math:∊} {cartesian_type},
type_U_sci_forall_simple=∀ {id} {math:∊} {type},
type_U_sci_letin_several=
type_U_sci_letin_simple=
# type_Universe_arg=universe
type_Universe_arg=universe
# type_Universe_dec=Let {id} be a universe
type_Universe_dec=Let {id} be a universe
# type_Universe_dec_body=Let {id} be a universe defined by {body}
type_Universe_dec_body=Let {id} be a universe defined by {body}
# type_Universe_exists_several=there exists universes {id} such that
type_Universe_exists_several=there exists universes {id} such that
# type_Universe_exists_simple=there exists a universe {id} such that
type_Universe_exists_simple=there exists a universe {id} such that
# type_Universe_forall_several=for every universes {id},
type_Universe_forall_several=for every universes {id},
# type_Universe_forall_simple=for every universe {id},
type_Universe_forall_simple=for every universe {id},
type_Universe_letin_several=
type_Universe_letin_simple=
# type_WearingHat_arg=hat wearer
type_WearingHat_arg=hat wearer
# type_WearingHat_dec=Let {id} be a hat wearer
type_WearingHat_dec=Let {id} be a hat wearer
type_WearingHat_dec_body=
# type_WearingHat_exists_several=there exist hat wearers {id} such that,
type_WearingHat_exists_several=there exist hat wearers {id} such that,
# type_WearingHat_exists_simple=there exists a hat carrier {id} such that,
type_WearingHat_exists_simple=there exists a hat carrier {id} such that,
# type_WearingHat_forall_several=for every hat wearers {id},
type_WearingHat_forall_several=for every hat wearers {id},
# type_WearingHat_forall_simple=for every hat wearer {id},
type_WearingHat_forall_simple=for every hat wearer {id},
type_WearingHat_letin_several=
type_WearingHat_letin_simple=
# type_gbmember_arg=islander
type_gbmember_arg=islander
# type_gbmember_dec=Let {id} be an islander
type_gbmember_dec=Let {id} be an islander
type_gbmember_dec_body=
# type_gbmember_exists_several=there exists islanders {id} such that
type_gbmember_exists_several=there exists islanders {id} such that
# type_gbmember_exists_simple=there exists an islander {id} such that
type_gbmember_exists_simple=there exists an islander {id} such that
# type_gbmember_forall_several=for every islanders {id},
type_gbmember_forall_several=for every islanders {id},
# type_gbmember_forall_simple=for every islander {id},
type_gbmember_forall_simple=for every islander {id},
type_gbmember_letin_several=
type_gbmember_letin_simple=
# type_gbmember_sci_arg=islander
type_gbmember_sci_arg=islander
# type_gbmember_sci_dec=Let {id} be an islander
type_gbmember_sci_dec=Let {id} be an islander
type_gbmember_sci_dec_body=
# type_gbmember_sci_exists_several=there exists islanders {id} such that
type_gbmember_sci_exists_several=there exists islanders {id} such that
# type_gbmember_sci_exists_simple=there exists an islander {id} such that
type_gbmember_sci_exists_simple=there exists an islander {id} such that
# type_gbmember_sci_forall_several=for every islanders {id},
type_gbmember_sci_forall_several=for every islanders {id},
# type_gbmember_sci_forall_simple=for every islander {id},
type_gbmember_sci_forall_simple=for every islander {id},
type_gbmember_sci_letin_several=
type_gbmember_sci_letin_simple=
type_type_default_arg={id}
# type_type_default_dec=Let {type} {id}
type_type_default_dec=Let {type} {id}
# type_type_default_dec_body=Let {type} {id} = {body}
type_type_default_dec_body=Let {type} {id} = {body}
type_type_default_exists_several=∃ {id} {math:∊} {cartesian_type},
type_type_default_exists_simple=∃ {id} {math:∊} {type},
type_type_default_forall_several=∀ {id} {math:∊} {cartesian_type},
type_type_default_forall_simple=∀ {id} {math:∊} {type},
type_type_default_letin_several=
type_type_default_letin_simple=
type_type_default_sci_arg={id}
# type_type_default_sci_dec=Let {id} {math:∊} {type}
type_type_default_sci_dec=Let {id} {math:∊} {type}
# type_type_default_sci_dec_body=Let {id} = {body}
type_type_default_sci_dec_body=Let {id} = {body}
type_type_default_sci_exists_several=∃ {pair_id} {math:∊} {cartesian_type},
type_type_default_sci_exists_simple=∃ {id} {math:∊} {type},
type_type_default_sci_forall_several=∀ {pair_id} {math:∊} {cartesian_type},
type_type_default_sci_forall_simple=∀ {id} {math:∊} {type},
type_type_default_sci_letin_several=
type_type_default_sci_letin_simple=


### new entries
# axiom_app_def_rewrite_diagnostic=function definition
axiom_app_def_rewrite_diagnostic=function definition
# axiom_app_def_rewrite_justification=by definition of {0} applied to {1}
axiom_app_def_rewrite_justification=by definition of {0} applied to {1}
axiom_app_inverse_bounded_diagnostic=
axiom_app_inverse_bounded_justification=
axiom_app_opposite_bounded_diagnostic=
axiom_app_opposite_bounded_justification=
# axiom_ineqbound_comb_add_diagnostic=addition
axiom_ineqbound_comb_add_diagnostic=addition
# axiom_ineqbound_comb_add_justification=by addition
axiom_ineqbound_comb_add_justification=by addition
# axiom_ineqbound_comb_mul_diagnostic=multiplication
axiom_ineqbound_comb_mul_diagnostic=multiplication
# axiom_ineqbound_comb_mul_justification=by multiplication
axiom_ineqbound_comb_mul_justification=by multiplication
# axiom_ineqbound_comb_sub_diagnostic=subtraction
axiom_ineqbound_comb_sub_diagnostic=subtraction
# axiom_ineqbound_comb_sub_justification=by subtraction
axiom_ineqbound_comb_sub_justification=by subtraction
# axiom_ineqbound_trans_diagnostic=transitivity
axiom_ineqbound_trans_diagnostic=transitivity
# axiom_ineqbound_trans_justification=by transitivity
axiom_ineqbound_trans_justification=by transitivity
# axiom_limit_neg_inf_diagnostic=-∞ limit
axiom_limit_neg_inf_diagnostic=-∞ limit
# basic_HatUtterance=Three hats enigma
basic_HatUtterance=Three hats enigma
# basic_are_collinear={0} are collinear
basic_are_collinear={0} are collinear
# basic_are_collinear_neg={0} are not collinear
basic_are_collinear_neg={0} are not collinear
basic_no_intro={0}
# key_assume_prefix=Assume
key_assume_prefix=Assume
key_assume_suffix=
# key_highlight_icon_backward=backward
key_highlight_icon_backward=backward
# key_highlight_icon_definition=definition
key_highlight_icon_definition=definition
# key_highlight_icon_forward=forward
key_highlight_icon_forward=forward
# key_highlight_icon_reduce=simplify
key_highlight_icon_reduce=simplify
# key_hintpopup_settings=Settings
key_hintpopup_settings=Settings
# key_hintpopup_settings_exercise_intro_key=Utterance introduction
key_hintpopup_settings_exercise_intro_key=Utterance introduction
# key_hintpopup_settings_exercise_intro_value_partial=partial
key_hintpopup_settings_exercise_intro_value_partial=partial
# key_hintpopup_settings_exercise_intro_value_total=total
key_hintpopup_settings_exercise_intro_value_total=total
# key_hintpopup_settings_exercise_language_key=Language
key_hintpopup_settings_exercise_language_key=Language
# key_hintpopup_settings_exercise_sci_key=Scientific notation
key_hintpopup_settings_exercise_sci_key=Scientific notation
# key_hintpopup_settings_exercise_sci_value_activate=activated
key_hintpopup_settings_exercise_sci_value_activate=activated
# key_hintpopup_settings_exercise_sci_value_inactivate=deactivated
key_hintpopup_settings_exercise_sci_value_inactivate=deactivated
# key_hintpopup_settings_exercise_title=Exercise
key_hintpopup_settings_exercise_title=Exercise
# key_hintpopup_settings_locked_empty=None
key_hintpopup_settings_locked_empty=None
# key_hintpopup_settings_locked_title=Locked axioms
key_hintpopup_settings_locked_title=Locked axioms
# key_hintpopup_settings_scope_elim_and_key=Elimination of 'And'
key_hintpopup_settings_scope_elim_and_key=Elimination of 'And'
# key_hintpopup_settings_scope_elim_and_value_activate=activated
key_hintpopup_settings_scope_elim_and_value_activate=activated
# key_hintpopup_settings_scope_elim_and_value_inactivate=deactivated
key_hintpopup_settings_scope_elim_and_value_inactivate=deactivated
# key_hintpopup_settings_scope_elim_exists_key=Elimination of 'exists'
key_hintpopup_settings_scope_elim_exists_key=Elimination of 'exists'
# key_hintpopup_settings_scope_elim_exists_value_activate=activated
key_hintpopup_settings_scope_elim_exists_value_activate=activated
# key_hintpopup_settings_scope_elim_exists_value_inactivate=deactivated
key_hintpopup_settings_scope_elim_exists_value_inactivate=deactivated
# key_hintpopup_settings_scope_intro_forall_key=Introduction of 'for every'
key_hintpopup_settings_scope_intro_forall_key=Introduction of 'for every'
# key_hintpopup_settings_scope_intro_forall_value_total=total
key_hintpopup_settings_scope_intro_forall_value_total=total
# key_hintpopup_settings_scope_intro_forall_value_unit=step-wize
key_hintpopup_settings_scope_intro_forall_value_unit=step-wize
# key_hintpopup_settings_scope_title=Scope creation
key_hintpopup_settings_scope_title=Scope creation
# key_hintpopup_tab_settings=Settings
key_hintpopup_tab_settings=Settings
# key_premises=Premises
key_premises=Premises
# key_preview_deduce=Preview of deduction of
key_preview_deduce=Preview of deduction of
# key_preview_justify=Preview of justification of
key_preview_justify=Preview of justification of
# key_to_justify=to justify
key_to_justify=to justify
# key_toolbox_error_message_no_backward=This rule cannot be applied in backward.
key_toolbox_error_message_no_backward=This rule cannot be applied in backward.
# key_toolbox_error_message_no_forward=This rule cannot be applied in forward.
key_toolbox_error_message_no_forward=This rule cannot be applied in forward.
# key_toolbox_error_message_no_select=This rule cannot be applied without selection.
key_toolbox_error_message_no_select=This rule cannot be applied without selection.
# key_toolbox_error_message_not_match=This rule does not apply to this statement.
key_toolbox_error_message_not_match=This rule does not apply to this statement.
pager_axiom=
# pager_double_inequality=Double inequality
pager_double_inequality=Double inequality
# pager_double_inequality_tuto_01=Operations on the left, right and center
pager_double_inequality_tuto_01=Operations on the left, right and center
# pager_double_inequality_tuto_02=Combinations
pager_double_inequality_tuto_02=Combinations
# pager_double_inequality_tuto_03=Applications
pager_double_inequality_tuto_03=Applications
# pager_double_inequality_tuto_04=Transitivity
pager_double_inequality_tuto_04=Transitivity
# pager_ineqbound_misc=Miscellaneous
pager_ineqbound_misc=Miscellaneous
pager_internal=
# toolbox_double_inequality=Double inequality
toolbox_double_inequality=Double inequality
# toolbox_ineqbound_application=Applications
toolbox_ineqbound_application=Applications
# toolbox_ineqbound_combination=Combinations
toolbox_ineqbound_combination=Combinations
# toolbox_ineqbound_conversion=Conversion
toolbox_ineqbound_conversion=Conversion
# toolbox_ineqbound_operations=Operations
toolbox_ineqbound_operations=Operations
# toolbox_ineqbound_relation=Relation
toolbox_ineqbound_relation=Relation
