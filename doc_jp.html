<!-- ## Ryusuke -->

<div class="pedagogic paper" key="exercise_description_demo_bernoulli_1">
 <!--{type="ex_title"}-->
 <p> <span class="txtwrap slide" style="padding-top:15px"> <img src="./img/demo_bernoulli_1.png"> </span> </p>
 <!-- <p> The powers of two are bound from above by the values of the exponent, i.e. that
	  <!--{type="expr" input="(pow 2 n) >= (plus n 1)"}-->, as is illustrated in the graph opposite. </p> -->
 <p> The powers of two are bound from above by the values of the exponent, i.e. that
  <!--{type="expr" input="(pow 2 n) >= (plus n 1)"}-->, as is illustrated in the graph opposite. </p>
 
 <center>
  <table class="borderblue">
   <colgroup>
    <col width="60">
    <col width="60">
    <col width="60">
   </colgroup>
   <tbody>
    <tr>
     <td><span class="bold">
       <!--{type="expr" input="n"}--></span></td>
     <td><span class="bold">
       <!--{type="expr" input="n+1"}--></span></td>
     <td><span class="bold">
       <!--{type="expr" input="2^n"}--></span></td>
    </tr>
    <tr>
     <td>
      <!--{type="expr" input="0"}--></td>
     <td>
      <!--{type="expr" input="1"}--></td>
     <td>
      <!--{type="expr" input="1"}--></td>
    </tr>
    <tr>
     <td>
      <!--{type="expr" input="1"}--></td>
     <td>
      <!--{type="expr" input="2"}--></td>
     <td>
      <!--{type="expr" input="2"}--></td>
    </tr>
    <tr>
     <td>
      <!--{type="expr" input="2"}--></td>
     <td>
      <!--{type="expr" input="3"}--></td>
     <td>
      <!--{type="expr" input="4"}--></td>
    </tr>
    <tr>
     <td>
      <!--{type="expr" input="3"}--></td>
     <td>
      <!--{type="expr" input="4"}--></td>
     <td>
      <!--{type="expr" input="8"}--></td>
    </tr>
    <tr>
     <td>...</td>
     <td>...</td>
     <td>...</td>
    </tr>
   </tbody>
  </table>
 </center>
 <!-- <p> This inequality is a specific example of <span class="exturl"><a href="https://en.wikipedia.org/wiki/Bernoulli%27s_inequality" target="_blank">Bernoulli’s inequalities</a></span>, demonstrated in the following exercise: </p> -->
 <p> これは<span class="exturl"><a href="https://en.wikipedia.org/wiki/Bernoulli%27s_inequality" target="_blank">ベルヌーイ(Bernoulli)の不等式</a></span>の特別な場合であり、以下の練習問題でベルヌーイ不等式が示される: </p>
 
 <p>
  <!--{type="exercise" input="demo_bernoulli_2"}--> </p>
 <!-- <p> <span class="light-bulb">ń</span> Use reasoning <span class="buttontheo">by induction</span>. </p> -->
 <p> <span class="light-bulb">ń</span> <span class="buttontheo">帰納法</span> を使う </p>
 
</div>
<div class="pedagogic paper" key="exercise_description_demo_bernoulli_2">
 <!--{type="ex_title"}-->
	<!-- <p> These inequalities generalize the result see previously. They are attributed to the Swiss mathematician, <span class="exturl"><a href="https://en.wikipedia.org/wiki/Jacob_Bernoulli" target="_blank">Jacques Bernoulli</a></span>. We call them the <span class="exturl"><a href="https://en.wikipedia.org/wiki/Bernoulli%27s_inequality" target="_blank">Bernoulli’s inequality</a></span>. </p> -->
	<p> これらの不等式は前出の結果を一般化するものである。これらはスイスの数学者<span class="exturl"><a href="https://en.wikipedia.org/wiki/Jacob_Bernoulli" target="_blank">ヤコブ ベルヌーイ(Jacques Bernoulli</a></span>によって与えられ、<span class="exturl"><a href="https://en.wikipedia.org/wiki/Bernoulli%27s_inequality" target="_blank">ベルヌーイの不等式</a></span>と呼ばれる。</p>
	
	<!-- <p> <span class="light-bulb">ń</span> Use reasoning by induction. </p> -->
 <p> <span class="light-bulb">ń</span> 帰納法を使う。 </p>
	
</div>
<div class="pedagogic paper" key="exercise_description_ineq_ex_8">
 <!--{type="ex_title"}-->
</div>
<div class="pedagogic paper" key="exercise_description_logic_connector_abs_peirce">
 <!--{type="ex_title"}-->
	<!-- <p><span class="lock">w</span><span class="cons">Constructive logic</span></p> -->
 <p><span class="lock">w</span><span class="cons">構成的論理</span></p>
	
</div>
<div class="custom pedagogic" key="exercise_description_logic_connector_ex_easy_01">
 <!--{type="ex_title"}-->
	<!-- <p>We can demonstrate that disjunction is distributive <span class="stress">over conjunction</span>.</p> -->
	<p>論理和は<span class="stress">論理積に対して</span>分配的であることが示せる。</p>
	<!-- <p><span class="lock">w</span><span class="cons">Constructive logic</span></p> -->
<p><span class="lock">w</span><span class="cons">構成的論理</span></p>
	
</div>
<div class="custom pedagogic" key="exercise_description_logic_connector_ex_easy_02">
	<!--{type="ex_title"}-->
	<!-- <p> It can be shown that conjunction is distributive <span class="stress">over disjunction</span>. </p> -->
	<p>論理積は <span class="stress">論理和に対して</span>分配的であることが示せる。 </p>
	
	
 <p> <span class="lock">w</span><span class="cons">構成的論理</span> </p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_connector_ex_easy_06">
	<!--{type="ex_title"}-->
	<!-- <p> In this exercise, the universe of elements is made up of all <span class="exturl"><a href="https://en.wikipedia.org/wiki/Natural_number" target="_blank">natural numbers</a></span>. </p> -->
 <p> この練習問題では、要素の全体集合(宇宙)は<span class="exturl"><a href="https://en.wikipedia.org/wiki/Natural_number" target="_blank">自然数</a></span>の全てからなるものとする。 </p>
 <p> また、式は<span class="stress">ℕ上で定義された命題で</span>要素は整数である。 </p>
 <p> 注意 "
  <!--{type="prop" sci="true" input="forall (x:Nvar), app_prop P x"}-->" と "
	 <!--{type="prop" sci="true" input="exists (x:Nvar), app_prop P x"}-->" はℕ上の量化子である。

 </p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_connector_ex_easy_08">
 <!--{type="ex_title"}-->
 <a href="https://en.wikipedia.org/wiki/The_School_of_Athens" target="_blank"><img class="txtwrap" src="./img/aristote-raphael-ecole-d-athenes.jpg" height="30%" width="30%"></a>
 <!-- <p> The <span class="exturl"><a href="https://en.wikipedia.org/wiki/Syllogism" target="_blank">syllogism</a></span> is a reasoning formalized in the 4<span class="sup">th</span> Century BC in <span class="exturl"><a href="https://en.wikipedia.org/wiki/Ancient_Greece" target="_blank">Ancient Greece</a></span> par <span class="exturl"><a href="https://en.wikipedia.org/wiki/Aristotle" target="_blank">Aristotle</a></span> who considered it a fundamental element of logic and reasoning. </p> -->
 <p> <span class="exturl"><a href="https://en.wikipedia.org/wiki/Syllogism" target="_blank">三段論法</a></span> は紀元前4世紀に<span class="exturl"><a href="https://en.wikipedia.org/wiki/Ancient_Greece" target="_blank">古代ギリシア</a></span> の <span class="exturl"><a href="https://en.wikipedia.org/wiki/Aristotle" target="_blank">アリストテレス(Aristotle)</a></span>によって公式化された。アリストテレスはこれを論理と証明の基本的要素と考えていた。 </p>
 <!-- <p> The syllogism served, and continues to serve, as a logical foundation to <span class="exturl"><a href="https://en.wikipedia.org/wiki/Law" target="_blank">Legislation</a></span>, born in <span class="exturl"><a href="https://en.wikipedia.org/wiki/Ancient_Rome#Republic" target="_blank">Ancient Rome</a></span>. It is the scheme on which legal judgements are constructed in western tradition. </p> -->
  <p> 三段論法は<span class="exturl"><a href="https://en.wikipedia.org/wiki/Ancient_Rome#Republic" target="_blank">Ancient Rome</a></span>で生まれた <span class="exturl"><a href="https://en.wikipedia.org/wiki/Law" target="_blank">立法</a></span>の論理的根幹を支え続けている。, born in .西洋の歴史において立法的判断は三段論法の上で構成された。 </p>
  <!-- <p>Let’s imagine, for example that a tribunal must respond to the question "Is Socrates mortal?". The answer lies in the discovery of un attribute "man". Let’s lay out the definitions:</p> -->
   <p>例えば、法定が"ソクラテス(Socrates)は死ぬか。"という問に答えねばならないとよう。それには、"人間"の特性について調べる必要がある。定義を展開していこう:</p>
 <table class="slide">
  <colgroup>
   <col width="150">
   <col width="30">
   <col width="150">
  </colgroup>
  <tbody>
   <tr>
    <td style="padding-top: 10px; border-right: 1px solid whitesmoke; border-bottom: 1px solid whitesmoke;">小概念</td>
    <td style="padding-top: 10px; border-right: 1px solid whitesmoke; border-bottom: 1px solid whitesmoke;">A</td>
    <td style="padding-top: 10px; border-bottom: 1px solid whitesmoke;">ソクラテス</td>
   </tr>
   <tr>
	   <!-- <td style="border-right: 1px solid whitesmoke; border-bottom: 1px solid whitesmoke;">Middle term</td> -->
    <td style="border-right: 1px solid whitesmoke; border-bottom: 1px solid whitesmoke;">媒概念</td>
    <td style="border-right: 1px solid whitesmoke; border-bottom: 1px solid whitesmoke;">B</td>
    <td style="border-bottom: 1px solid whitesmoke;">人間である</td>
   </tr>
   <tr>

       <!-- <td style="border-right: 1px solid whitesmoke;">Major term</td>
			<td style="border-right: 1px solid whitesmoke;">C</td>
			<td>being mortal</td> -->
    <td style="border-right: 1px solid whitesmoke;">大概念</td>
    <td style="border-right: 1px solid whitesmoke;">C</td>
    <td>死ぬ</td>
   </tr>
  </tbody>
 </table>
 <!-- <p>It is therefore judged following the schema below:</p> -->
 <p>よって以下の図式が従うことが導かれる:</p>
 <table class="slide">
  <colgroup>
   <col width="200">
   <col width="90">
   <col width="250">
   <col width="250">
  </colgroup>
  <tbody>
   <tr>
       <!-- <td style="padding-top: 10px; border-right: 1px solid whitesmoke; border-bottom: 1px solid whitesmoke; vertical-align: middle;">Major premise</td>
			<td style="border-right: 1px solid whitesmoke; border-bottom: 1px solid whitesmoke; vertical-align: middle;">B ⇒ C</td>
			<td style="border-right: 1px solid whitesmoke; border-bottom: 1px solid whitesmoke; vertical-align: middle;"> All men are mortals. (man ⇒ mortal)</td>
			<td style="border-bottom: 1px solid whitesmoke; vertical-align: middle;">The rule of law</td>
			</tr>
			<tr>
			<td style="border-right: 1px solid whitesmoke; border-bottom: 1px solid whitesmoke; vertical-align: middle;">Minor premise</td>
			<td style="border-right: 1px solid whitesmoke; border-bottom: 1px solid whitesmoke; vertical-align: middle;">A ⇒ B</td>
			<td style="border-right: 1px solid whitesmoke; border-bottom: 1px solid whitesmoke; vertical-align: middle;">Socrates is a man.</td>
			<td style="border-bottom: 1px solid whitesmoke; vertical-align: middle;"> The legal qualification of the minor term (Socrates), which is subject to the proceedings.</td>
			</tr>
			<tr>
			<td style="border-right: 1px solid whitesmoke; border-bottom: 1px solid whitesmoke; vertical-align: middle;">Conclusion</td>
			<td style="border-right: 1px solid whitesmoke; border-bottom: 1px solid whitesmoke; vertical-align: middle;">A ⇒ C</td>
			<td style="border-right: 1px solid whitesmoke; border-bottom: 1px solid whitesmoke; vertical-align: middle;">Socrates is mortal.</td>
			<td style="border-bottom: 1px solid whitesmoke; vertical-align: middle;">The judgement</td> -->
	    <td style="padding-top: 10px; border-right: 1px solid whitesmoke; border-bottom: 1px solid whitesmoke; vertical-align: middle;">大前提</td>
    <td style="border-right: 1px solid whitesmoke; border-bottom: 1px solid whitesmoke; vertical-align: middle;">B ⇒ C</td>
    <td style="border-right: 1px solid whitesmoke; border-bottom: 1px solid whitesmoke; vertical-align: middle;"> いかなる人間も死ぬ。 (人間 ⇒ 死ぬ)</td>
    <td style="border-bottom: 1px solid whitesmoke; vertical-align: middle;">法律</td>
   </tr>
   <tr>
    <td style="border-right: 1px solid whitesmoke; border-bottom: 1px solid whitesmoke; vertical-align: middle;">小前提</td>
    <td style="border-right: 1px solid whitesmoke; border-bottom: 1px solid whitesmoke; vertical-align: middle;">A ⇒ B</td>
    <td style="border-right: 1px solid whitesmoke; border-bottom: 1px solid whitesmoke; vertical-align: middle;">ソクラテスは人間である。</td>
    <td style="border-bottom: 1px solid whitesmoke; vertical-align: middle;"> 小概念(ソクラテス)の法的な身分。小概念は以下の審判の対象となる。</td>
   </tr>
   <tr>
    <td style="border-right: 1px solid whitesmoke; border-bottom: 1px solid whitesmoke; vertical-align: middle;">結論</td>
    <td style="border-right: 1px solid whitesmoke; border-bottom: 1px solid whitesmoke; vertical-align: middle;">A ⇒ C</td>
    <td style="border-right: 1px solid whitesmoke; border-bottom: 1px solid whitesmoke; vertical-align: middle;">ソクラテスは死ぬ。</td>
    <td style="border-bottom: 1px solid whitesmoke; vertical-align: middle;">評決</td>
   </tr>
  </tbody>
 </table>
 <!-- <p> The challenge the process presents is therefore qualifying (or not) the minor term (the accused) as a middle term. Learning the spirit of the laws (the meaning given to the laws) allows the judge to decide, by studying <span class="exturl"><a href="https://en.wikipedia.org/wiki/Case_law" target="_blank">case law</a></span> that is the set of court decisions. </p> -->
 <p> 上のように争われた裁判では小概念(被告)が媒概念として見做せるか否かを判断している。<span class="exturl"><a href="https://en.wikipedia.org/wiki/Case_law" target="_blank">判例</a></span>を研究し、法の精神、すなわちそれぞれの法の意味を理解することで審判をくだすことができる。</p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_connector_ex_easy_12">
 <!--{type="ex_title"}-->
	<!-- <p>This implication is only true in classical logic. This poses no problem to its use in electronics : either the current flows or it doesn’t.</p> -->
	<p>この導出は古典論理においてのみ正しいが、この結論の電子工学(電流が流れているか否かについての考察)への応用は全く問題がない。</p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_connector_ex_easy_13">
 <!--{type="ex_title"}-->
 <a href="./img/Diopsis.jpg" target="_blank"><img class="txtwrap" src="./img/Diopsis.jpg" height="30%" width="30%"></a>
 <!-- <p>The <span class="exturl"><a href="https://en.wikipedia.org/wiki/De_Morgan%27s_laws" target="_blank">De Morgan's laws</a></span> are formulae that allow us to calculate the negation of any mathematical proposition.</p> -->
  <p><span class="exturl"><a href="https://en.wikipedia.org/wiki/De_Morgan%27s_laws" target="_blank">ド モルガン(De Morgan)律</a></span> は数学的命題の否定を求めるのに使える。</p>
  <!-- <p>We can demonstrate that the negation of a disjunction is the conjunction of the negations of the operands.</p> -->
  <p>論理和の否定は和を構成する命題の否定の論理積である。</p>
  <!-- <p>These laws are used in IT within the conception of <span class="exturl"><a href="https://en.wikipedia.org/wiki/Logic_gate" target="_blank">logical functions</a></span> and and their physical materialization, notably in the form of <span class="exturl"><a href="https://en.wikipedia.org/wiki/Integrated_circuit">integrated circuits</a></span>.</p> -->
 <p>これらの法則はITにおいて<span class="exturl"><a href="https://en.wikipedia.org/wiki/Logic_gate" target="_blank">論理回路</a></span>のなかで応用される。製品としては特に<span class="exturl"><a href="https://en.wikipedia.org/wiki/Integrated_circuit">集積回路</a></span>がある。</p>
 <!-- <p><span class="lock">w</span><span class="cons">Constructive logic</span></p> -->
 <p><span class="lock">w</span><span class="cons">構成的論理</span></p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_connector_ex_easy_14">
 <!--{type="ex_title"}-->
	<!-- <p> A binary <span class="exturl"><a href="https://en.wikipedia.org/wiki/Operator_(mathematics)" target="_blank">operator</a></span> noted, for example, ★, is <span class="exturl"><a href="https://en.wikipedia.org/wiki/Associative_property" target="_blank">associative</a></span> if, whatever the <span class="exturl"><a href="https://en.wikipedia.org/wiki/Operand" target="_blank">operands</a></span> a b c : </p> -->
	<p> 二項 <span class="exturl"><a href="https://en.wikipedia.org/wiki/Operator_(mathematics)" target="_blank">演算子</a></span> (ここでは ★ であらわす)は以下のような性質をもつとき <span class="exturl"><a href="https://en.wikipedia.org/wiki/Associative_property" target="_blank">結合的</a></span> であるという: いかなる<span class="exturl"><a href="https://en.wikipedia.org/wiki/Operand" target="_blank">被演算子</a></span> a b c にたいしても </p>
 <p>a ★ (b ★ c) = (a ★ b) ★ c が成立</p>
 <p>かっこのつきかたは重要な意味をもたないため、かっこは省略できる。よって上の値は a ★ b ★ c と書かれる. たとえば加法の結合性により、3 + 5 + 8 とかっこを使わずに書ける。</p>
 <!-- <p> <span class="lock">w</span><span class="cons">Constructive logic</span> </p> -->
 <p> <span class="lock">w</span><span class="cons">構成的論理</span> </p>
 <div class="slide">
	 <!-- <p> <span class="light-bulb">ń</span> By definition, an equivalence is demonstrated by demonstrating two implications. Definition of <span class="buttontheo">equivalence</span> is chosen to demonstrate
		  <!--{type="tag" input="s0"}-->. </p> -->
  <p> <span class="light-bulb">ń</span> 定義により、同値を示すには両方向の論理的包含を示せばよい。<!--{type="tag" input="s0"}--> を示すのに <span class="buttontheo">equivalence</span> の定義を選択する。 </p>
 </div>
</div>
<div class="custom pedagogic" key="exercise_description_logic_connector_ex_easy_16">
 <!--{type="ex_title"}-->
	<!-- <p> <span class="exturl"><a href="https://en.wikipedia.org/wiki/Contraposition" target="_blank">Contraposition</a></span>, or modus tollens, consists of demonstrating that A implies B, by demonstrating that the negation of B implies the negation of A: if B didn’t stand, A wouldn’t stand, therefore if A stands, then B stands. </p> -->
	<p> <span class="exturl"><a href="https://en.wikipedia.org/wiki/Contraposition" target="_blank">対偶</a></span>、またはモーダストレンス、は A ならば B を証明する方法の一つで、A ならば B の代りに Bでない ならば Aでない を示す:もしBが成り立たなければAも成り立たないとすれば、Aが成り立つときBも成り立つはずである。 </p>
	<!-- <p> This reasoning only applies within <span class="stress">classical logic</span>. However, the inverse implication,
		 <!--{type="prop" sci="true" input="(A -> B) -> (~B -> ~A)"}--> is true in constructive logic, as demonstrated in the following exercise. </p> -->
 <p> この証明法は<span class="stress">古典論理</span>においてのみ成り立つが、その逆である、
  <!--{type="prop" sci="true" input="(A -> B) -> (~B -> ~A)"}--> は構成的論理においても正しい。次の練習問題でそれが示される。 </p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_connector_ex_easy_17">
 <!--{type="ex_title"}-->
 <p><span class="lock">w</span><span class="cons">構成的論理</span></p>
 <p>このように、上の結論は構成的論理でも示すことができる。</p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_connector_ex_easy_27">
 <!--{type="ex_title"}-->
 <p>論理積の結合性は論理和のそれと似た手順で示せる。</p>
 <div class="slide">
	 <!-- <p> <span class="light-bulb">ń</span> Demonstrating disjunction of
		  <!--{type="prop" sci="true" input="or A B"}--> requires <span class="stress">choosing</span> between the demonstration of A or B. </p> -->
 <p> <span class="light-bulb">ń</span> 以下の論理和
	  <!--{type="prop" sci="true" input="or A B"}--> を示すにはAかBのどちらか一方を <span class="stress">選んで</span> 証明すればよい。 </p>
 <!-- <p>The method consists of choosing as late as possible, and then exploiting all hypotheses (by disjunction of cases) in order to obtain the maximum amount of information that allows us to make the choice.</p> -->
 <p>この手順では、選択はできるだけ後にまわし、選択のための情報を最大限にとりだす。</p>
 </div>
 <p> <span class="lock">w</span><span class="cons">構成的論理</span> </p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_connector_ex_easy_31">
 <!--{type="ex_title"}-->
	<!-- <p> <span class="exturl"><a href="https://en.wikipedia.org/wiki/Reductio_ad_absurdum" target="_blank">Ad absurdium reasoning</a></span> consists of demonstrating a proposition A by showing that if its negation, ¬ A, is true, then we obtain a contradiction: </p> -->
	<p> <span class="exturl"><a href="https://en.wikipedia.org/wiki/Reductio_ad_absurdum" target="_blank">背理法</a></span>は証明法の一種である。背理法では命題Aを示すのにまずその否定である ¬ A を仮定し、続いて矛盾を導く: </p>
 <table class="slide">
  <colgroup>
   <col width="100%">
  </colgroup>
  <tbody>
   <tr>
    <td><span class="def">背理法</span>
     <!--{type="prop" sci="true" input="forall A:Prop, ((~(~A)) -> A)"}--></td>
   </tr>
  </tbody>
  <tbody>
  </tbody>
 </table>
 <!-- <p> In effect,
	  <!--{type="prop" sci="true" input="~(~A)"}--> can be re-written as
 <!--{type="prop" sci="true" input="(~A -> False)"}--> by definition of negation. Ad absurdium reasoning is therefore a law of elimination of double negation. </p> -->
 <p> しかるに否定の定義より、
  <!--{type="prop" sci="true" input="~(~A)"}--> は
  <!--{type="prop" sci="true" input="(~A -> False)"}--> と書き変えられる。すなわち背理法は二重否定の除去である。</p>
 <!-- <p>This exercise demonstrates that the excluded middle involves ad absurdium reasoning.</p> -->
 <p>この練習問題では排中律が背理法を導くことを示す。</p>
 <!-- <p> <span class="lock">w</span><span class="cons">Constructive logic</span> </p> -->
 <p> <span class="lock">w</span><span class="cons">構成的論理</span> </p>
 <!-- <p>Reciprocal implication is demonstrated in the exercise below. As a result, ad absurdium reasoning is equivalent to the excluded middle, and is therefore not acknowledged by constructive logic:</p> -->
 <p>逆の導出は以下の練習問題で示される。よって、背理法は排中律と同値であって、構成的論理では認められない:</p>
 <p>
  <!--{type="exercise" input="logic_quantifier_ex_le_48"}--> </p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_connector_ex_easy_32">
 <!--{type="ex_title"}-->
	<!-- <p>We can demonstrate that disjunction of two negations is the negation of conjunction of the propositions. This implication is made with constructive logic, but not the inverse implication, as shown in the next exercise.</p> -->
 <p>2つの否定命題の論理和からは論理積の否定が導かれるが、これは構成的論理でも可能である。しかし、次の練習問題が示すように逆は不可能である。</p>
 <p> <span class="lock">w</span><span class="cons">構成的論理</span> </p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_connector_ex_easy_33">
 <!--{type="ex_title"}-->
	<!-- <p>It can be demonstrated that disjunction is distributive <span class="stress">over implication</span>.</p> -->
<p>論理和は <span class="stress">論理包含に対し</span>分配的である。</p>
	
</div>
<div class="custom pedagogic" key="exercise_description_logic_connector_ex_easy_34">
 <!--{type="ex_title"}-->
	<!-- <p>It can be demonstrated that conjunction is "half distributive" over implication.</p> -->
 <p>論理積は論理包含に対して"半分配的"である。</p>
</div>
<div class="pedagogic paper" key="exercise_description_logic_connector_peirce_abs_te">
 <!--{type="ex_title"}-->
 <p><span class="lock">w</span><span class="cons">構成的論理</span></p>
</div>
<div class="pedagogic paper" key="exercise_description_logic_connector_peirce_law">
 <!--{type="ex_title"}-->
 <a href="https://en.wikipedia.org/wiki/Charles_Sanders_Peirce" target="_blank"><img class="txtwrap" src="./img/peirce.jpg" height="30%" width="30%"></a>
 <!-- <p> <span class="exturl"><a href="https://en.wikipedia.org/wiki/Peirce%27s_law" target="_blank">Peirce's law</a></span> is true in classical logic. <span class="exturl"><a href="https://en.wikipedia.org/wiki/Charles_Sanders_Peirce" target="_blank">Charles Sanders Peirce</a></span> was an American philosopher, logician and mathematician. </p> -->
 <p> <span class="exturl"><a href="https://en.wikipedia.org/wiki/Peirce%27s_law" target="_blank">パース(Peirce)の法則</a></span> は構成的論理で正しい。 <span class="exturl"><a href="https://en.wikipedia.org/wiki/Charles_Sanders_Peirce" target="_blank">チャールズ・サンダース・パース(Charles Sanders Peirce)</a></span>はアメリカ人で哲学者、論理学者、および数学者である。</p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_connector_tuto_01">
 <!--{type="ex_title"}-->
	<!-- <p>What can be deduced from the conjunction "A ∧ B"?</p> -->
 <p>論理和 "A ∧ B" から何が導かれるだろうか。</p>
 <!-- <p>Follow the instructions to solve the problem.</p> -->
 <p>案内に従って問題を解け。</p>
 <!-- <p> <span class="light-bulb">A</span>Each exercise has a conclusion and an initial context, which lays out the variables and the hypothesis. </p> -->
 <p> <span class="light-bulb">A</span>各練習問題は結論と初めの条件、変数についての条件および仮定が与えられている。 </p>
 <!-- <p> <span class="light-bulb">A</span>The conclusion and the hypothesis are <span class="exturl"><a href="https://en.wikipedia.org/wiki/Statement_(logic)" target="_blank">mathematical statements</a></span>. The objective is to come up with a series of statements, which make up the <span class="exturl"><a href="https://en.wikipedia.org/wiki/Mathematical_proof" target="_blank">proof</a></span> that the conclusion is true. </p> -->
<p> <span class="light-bulb">A</span>結論と仮定は<span class="exturl"><a href="https://en.wikipedia.org/wiki/Statement_(logic)" target="_blank">数学的言明</a></span>である。目標は言明のならびを作り、それが結論の<span class="exturl"><a href="https://en.wikipedia.org/wiki/Mathematical_proof" target="_blank">証明</a></span>となるようにすることである。 </p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_quantifier_21">
 <!--{type="ex_title"}-->
	<!-- <p>In Scotland, a private club has the following rules:</p>
		 <ul>
		 <li>Every non-Scottish member wears red socks.</li>
		 <li>Every member wears a kilt or doesn't wear red socks.</li>
		 <li>The married members don't go out on Sunday.</li>
		 <li>A member goes out on Sunday if and only if he is Scottish.</li>
		 <li>Every member who wears a kilt is Scottish and married.</li>
		 <li>Every Scottish member wears a kilt.</li>
		 </ul>
		 <p>Now, we show that these rules are so strict that no one can be accepted!</p> -->
 <p>スコットランドのある個人クラブは以下のような規則をもつ:</p>
 <ul>
  <li>いかなるスコットランド人会員も赤い靴下をはいている。</li>
  <li>いかなる会員もキルトスカートをきているまたは赤い靴下をはいていないかである。</li>
  <li>結婚している会員は日曜日には外出しない。</li>
  <li>日曜日に出歩くのはスコットランド人であり、その逆も成り立つ。</li>
  <li>キルトスカートを着ている会員はスコットランド人であり既婚である。</li>
  <li>いかなるスコットランド人会員もキルトスカートを着ている。</li>
 </ul>
 <p>さて、上の規則は厳しすぎ、誰も入ることができないことを示せ!</p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_quantifier_ex_03">
 <!--{type="ex_title"}-->
	<!-- <p>It is demonstrated that the complement of a union is the intersection of the complements.</p>l -->
	<p>合併集合の補集合は補集合の交わりであることが示せる。</p>
	<!-- <p>We call this formula a De Morgan law by analogy with the De Morgan laws established for conjunctions and disjunctions. There are indeed similarities between the properties (distributivity, associativity, commutativity) of the union, of the intersection and of the complement, and those of the disjunction, the conjunction and the negation respectively.</p> -->
	<p>この公式もド・モルガン律といい、論理積と論理和についてのド・モルガン律の類似である。実際に合併集合、交わり、補集合がそれぞれ論理和、論理積、否定に対応し、類似の性質(分配性、結合性、交換性)が成り立つ。</p>
	<!-- <p>This is a consequence of the definition of the set operators: belonging to a union of two sets is the disjunction of membership to each of the two sets.</p> -->
 <p>これは集合作用素の定義による帰結である: 2つの集合の合併に属すことは各集合へ属することの論理和となる</p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_quantifier_ex_07">
 <!--{type="ex_title"}-->
	<!-- <p>The demonstration of the distributivity of the existential quantifier over disjunction is concluded.</p> -->
 <p>存在量化子の論理和に対する分配律が結論される。</p>
 <!-- <p> <span class="light-bulb">ń</span> It is necessary to generate the unknown witness variable <span class="button" style="font-family: 'Times New Roman'; font-weight: bold; font-size: 14px; padding: 3px;">x?</span> within the scope (or a sub-scope) that contains the variable(s) allowing us to figure out this unknown witness value. In this example, the witness value is provided within the scopes created <span class="buttontheo">by using disjunction of cases</span>. This reasoning is therefore used before reasoning <span class="buttontheo">by construction</span>. </p> -->
 <p> <span class="light-bulb">ń</span> It is necessary to generate the unknown witness variable <span class="button" style="font-family: 'Times New Roman'; font-weight: bold; font-size: 14px; padding: 3px;">x?</span> within the scope (or a sub-scope) that contains the variable(s) allowing us to figure out this unknown witness value. In this example, the witness value is provided within the scopes created <span class="buttontheo">by using disjunction of cases</span>. This reasoning is therefore used before reasoning <span class="buttontheo">by construction</span>. </p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_quantifier_ex_09">
 <!--{type="ex_title"}-->
	<!-- <p>It can be shown that the empty set <span class="exturl"><a href="https://en.wikipedia.org/wiki/Subset" target="_blank">subset</a></span> of any set.</p> -->
 <p>空集合は任意の集合の <span class="exturl"><a href="https://en.wikipedia.org/wiki/Subset" target="_blank">部分集合</a></span>となることが示される。</p>
</div>
<div class="pedagogic paper" key="exercise_description_logic_quantifier_ex_easy_08">
 <!--{type="ex_title"}-->
	<!-- <p>What is the logical negation of a universal quantification?</p> -->
 <p>全称量化の否定はなにか?</p>
 <!-- <p>The negation of "for every x, F (x)" is not "for every x, not F (x)", but "there exists x such that F (x)".</p> -->
 <p>"任意のxについて、F(x)" の否定は"任意のxについて、F(x)でない"ではなく、"あるxが存在してF(x)でない".</p>
 <!-- <p>Here, one of the two implications is demonstrated.</p> -->
 <p>ここで2つの論理包含のうち一方が示される。</p>
</div>
<div class="pedagogic paper" key="exercise_description_logic_quantifier_ex_easy_09">
 <!--{type="ex_title"}-->
	<!-- <p>What is the logical negation of an existential quantification?</p> -->
	<p>存在量化の否定はなにか?</p>
	<!-- <p>The negation of "there exists x, such that F (x)" is not "there exists x, such that not F (x)", but “for every value x, not F (x)".</p> -->
 <p>"あるxが存在し、F(x)"の否定は"あるxが存在しF(x)でない"ではなく"任意のxについてF(x)でない"。</p>
</div>
<div class="pedagogic paper" key="exercise_description_logic_quantifier_ex_le_01">
 <!--{type="ex_title"}-->
	<!-- <p>The binary relation on ℕ "is less than", noted
		 <!--{type="prop" sci="true" input="app_rel rel_le x y"}-->, is defined in these exercises by an existential formula:</p> -->
<p> <!--{type="prop" sci="true" input="app_rel rel_le x y"}-->で表されるℕ上の二項関係 "以下である(Is less than)"は、これらの練習問題のなかで存在命題を使って定義される:</p>
 <table class="slide">
  <colgroup>
   <col width="100%">
  </colgroup>
  <tbody>
   <tr>
    <td> <span class="def">Is less than</span>
     <!--{type="prop" sci="true" input="forall (x y:Nvar), equiv (app_rel rel_le x y) (exists (z:Nvar),y=x+z)"}--> </td>
   </tr>
  </tbody>
  <tbody>
  </tbody>
 </table>
 <!-- <p>We can demonstrate that addition is increasing for this relation.</p> -->
 <p>この関係ついて加法は値を増加させることが示せる。</p>
 <!-- <p>"Is less than" exercises:</p> -->
 <p>"Is less than" 練習問題:</p>
 <p>
  <!--{type="exercise" input="logic_quantifier_ex_le_02"}-->
  <!--{type="exercise" input="logic_quantifier_ex_le_03"}--></p>
</div>
<div class="pedagogic paper" key="exercise_description_logic_quantifier_ex_le_02">
 <!--{type="ex_title"}-->
<!-- <p>"Is less than" Exercises:</p> -->
 <p>"Is less than" 練習問題:</p>
 <p>
  <!--{type="exercise" input="logic_quantifier_ex_le_01"}-->
  <!--{type="exercise" input="logic_quantifier_ex_le_03"}--> </p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_quantifier_ex_le_04">
 <!--{type="ex_title"}-->
 <p> <span class="def">source : <span class="exturl"><a href="http://www.lri.fr/~paulin/MathInfo" target="_blank">TP 1 Eléments de logique</a></span></span> </p>
 <!-- <p>There are two kinds of people on a mysterious island. There are so-called honestants who always speak the truth, and the others are swindlecants who always lie.</p> -->
 <p>ある神秘の島には正直者とうそつきの二種類の人間がいる。正直者は常に真実をいい、またうそつきは常に嘘をつく。</p>
 <!-- <p> Show that if <span style="font-weight: bold">a</span> and <span style="font-weight: bold">b</span> are two people on the island and that if <span style="font-weight: bold">a</span> says that <span style="font-weight: bold">b</span> is lying, at least one of the two is a swindlecant. </p> -->
<p> もし <span style="font-weight: bold">a</span> と <span style="font-weight: bold">b</span> の2人が、この島の住人であり <span style="font-weight: bold">a</span> が <span style="font-weight: bold">b</span> はうそつきだと言っていた場合、少くとも1人はうそつきであることを示せ。 </p>
<!-- <p> <span class="light-bulb">ń</span> The axiom <span class="buttontheo">speaking the truth or lying</span> is used to generate two cases: either <span style="font-weight: bold">a</span> is honestant, or <span style="font-weight: bold">a</span> is swindlecant. The theory "Honestants and Swindlecants" is made up of the following axioms: </p> -->
 <p> <span class="light-bulb">ń</span>  <span class="buttontheo">真実または嘘を話す</span>という公理は2つの場合を生みだす: <span style="font-weight: bold">a</span> は正直者である、または <span style="font-weight: bold">a</span> はうそつきである"正直者とうそつき"という理論は以下の公理によって作られる: </p>
 <table class="slide">
  <colgroup>
   <col width="25%">
   <col width="75%">
  </colgroup>
  <tbody>
   <tr>
   </tr>
   <tr>
       <!-- <td style="vertical-align: top"><span class="def" style="padding-top: 20px">Honestants and Swindlecants</span></td> -->
    <td style="vertical-align: top"><span class="def" style="padding-top: 20px">正直者とうそつき</span></td>
    <td style="padding-top: 24px;">
     <!--{type="prop" input="forall (a:gbmember), (or (is_good a) (is_bad a))"}--></td>
   </tr>
   <tr>
    <td style="vertical-align: top; padding-top: 8px"><span class="def">真実は正直者が語る</span></td>
    <td>
     <!--{type="prop" style="padding-top: 20px" input="forall (a:gbmember) (P:Prop), (is_good a) -> (say a P) -> P"}--></td>
   </tr>
   <tr>
    <td style="vertical-align: top; padding-top: 8px"><span class="def">嘘はうそつきがつく</span></td>
    <td>
     <!--{type="prop" input="forall (a:gbmember) (P:Prop), (is_bad a) -> (say a P) -> (~ P)"}--></td>
   </tr>
  </tbody>
  <tbody>
  </tbody>
 </table>
</div>
<div class="custom pedagogic" key="exercise_description_logic_quantifier_ex_le_05">
 <!--{type="ex_title"}-->
 <p> <span class="def">source : <span class="exturl"><a href="http://www.lri.fr/~paulin/MathInfo" target="_blank">TP 1 Eléments de logique</a></span></span> </p>
 <!-- <p> Show that if <span style="font-weight: bold">a</span> says that <span style="font-weight: bold">a</span> and <span style="font-weight: bold">b</span> are both swindlecants, then <span style="font-weight: bold">a</span> is a swindlecant. </p> -->
 <p> もし <span style="font-weight: bold">a</span> が <span style="font-weight: bold">a</span> と <span style="font-weight: bold">b</span> はともにうそつきだと言ったら <span style="font-weight: bold">a</span> はうそつきであることを示せ </p>
 <!-- <p> "Honestants and Swindlecants" exercises: </p> -->
 <p> "正直者とうそつき" 練習問題: </p>
 <!--{type="exercise" input="logic_quantifier_ex_le_04"}-->
 <!--{type="exercise" input="logic_quantifier_ex_le_05"}-->
 <!--{type="exercise" input="logic_quantifier_ex_le_06"}-->
 <!--{type="exercise" input="logic_quantifier_ex_le_07"}-->
</div>
<div class="custom pedagogic" key="exercise_description_logic_quantifier_ex_le_06">
 <!--{type="ex_title"}-->
 <p> <span class="def">source : <span class="exturl"><a href="http://www.lri.fr/~paulin/MathInfo" target="_blank">TP 1 Eléments de logique</a></span></span> </p>
 <p> もし <span style="font-weight: bold">a</span> が
  <!--{type="expr" input="False"}--> と言ったら彼はうそつきであることを示せ。 </p>
 <!-- <p></p> Exercises "Honestants and Swindlecants" : -->
 <p></p>  練習問題 "正直者とうそつき" :
 <p></p>
 <!--{type="exercise" input="logic_quantifier_ex_le_04"}-->
 <!--{type="exercise" input="logic_quantifier_ex_le_05"}-->
 <!--{type="exercise" input="logic_quantifier_ex_le_06"}-->
 <!--{type="exercise" input="logic_quantifier_ex_le_07"}-->
</div>
<div class="custom pedagogic" key="exercise_description_logic_quantifier_ex_le_07">
 <!--{type="ex_title"}-->
 <p> <span class="def">source : <span class="exturl"><a href="http://www.lri.fr/~paulin/MathInfo" target="_blank">TP 1 Eléments de logique</a></span></span> </p>
 <!-- <p>Show that a person living on the island cannot say that he himself is a swindlecant.</p> -->
 <p>この島の住人は自らをうそつきとは言えないことを示せ。</p>
 <!-- <p></p> Exercises "Honestants and Swindlecants" : -->
 <p></p> 練習問題 "正直者とうそつき" :
 <p></p>
 <!--{type="exercise" input="logic_quantifier_ex_le_04"}-->
 <!--{type="exercise" input="logic_quantifier_ex_le_05"}-->
 <!--{type="exercise" input="logic_quantifier_ex_le_06"}-->
 <!--{type="exercise" input="logic_quantifier_ex_le_07"}-->
</div>
<div class="pedagogic paper" key="exercise_description_logic_quantifier_ex_le_13">
 <!--{type="ex_title"}-->
 <!--  <a href="https://fr.wikipedia.org/wiki/Principe_des_tiroirs" target="_blank"><img class="txtwrap" src="http://img.1.im6.fr/03E8000007913469-photo-dressing-tiroir-casiers-chaussettes.jpg" height="30%" width="30%"></img></a> -->
 <span class="def">source : <span class="exturl"><a href="http://www.lri.fr/~paulin/MathInfo" target="_blank">TP 2 Relations et fonctions</a></span></span>
 <!-- <p> In 1834, the German mathematician <span class="exturl"><a href="https://en.wikipedia.org/wiki/Peter_Gustav_Lejeune_Dirichlet" target="_blank">Johann Dirichlet</a></span> announced the <span class="exturl"><a href="https://en.wikipedia.org/wiki/Pigeonhole_principle" target="_blank">pigeonhole principle</a></span>, which applies to the case in which n pigeons occupy m holes: </p> -->
 <p> 1834年、ドイツの数学者である<span class="exturl"><a href="https://en.wikipedia.org/wiki/Peter_Gustav_Lejeune_Dirichlet" target="_blank">ヨハン ディリクレ(Johann Dirichlet)</a></span> は <span class="exturl"><a href="https://en.wikipedia.org/wiki/Pigeonhole_principle" target="_blank">鳩の巣原理</a></span>を発表した。これはn羽の鳩がm個の巣を占めるといった問題に適用される: </p>
 <!-- <p style="align: center; font-style: italic">If n &gt; m, then at least one hole must contain strictly more than one pigeon.</p> -->
 <p style="align: center; font-style: italic">もし n &gt; m であれば2羽以上の鳩を含む巣が少くとも1つはある。</p>
 <!-- <p> In other words, by <span class="exturl"><a href="https://en.wikipedia.org/wiki/Contraposition" target="_blank">contraposition</a></span>, if each hole contains at the most one pigeon, then n &lt;= m. </p> -->
 <p>  <span class="exturl"><a href="https://en.wikipedia.org/wiki/Contraposition" target="_blank">対偶</a></span>を使っていいかえると、もし各巣が高々1羽の鳩しか含まない場合、n &lt;= mとなる。 </p>
 <p> Let’s consider <span class="stress">the storage function</span> of n+1 pigeons, indexed from 0 to n, in holes: this function takes the index of a pigeon as argument, and returns an index of a hole. The assumption that a hole contains at the most one pigeon, translates into f being an <span class="stress">injective function</span> (the fiber of a hole has at most one element). Furthermore, given that by hypothesis, m holes contain the pigeons, there is one pigeon, indexed x, such that f(x)=m. </p>
 <p>Demonstrating the pigeonhole principle therefore consists of demonstrating that if the function f is injective over the set [0 ... n], then there is one pigeon numbered x, such that its hole, f(x), is greater or equal to n.</p>
 <p>To simplify this, we can reason with a notion stronger than injectivity and consider strictly increasing functions:</p>
 <table class="slide">
  <colgroup>
   <col width="100%">
  </colgroup>
  <tbody>
   <tr>
    <td>
     <!--{type="prop" sci="true" input=" forall (n:Nvar) (f:NvarFun), equiv (FFMono n f) (forall (x y:Nvar), ExprLT x y -> ExprLT y n -> ExprLT (app_fun f x) (app_fun f y))"}--></td>
   </tr>
  </tbody>
  <tbody>
  </tbody>
 </table>
 <p>Opposite, it is demonstrated that the strict increase is a stronger condition than injectivity over [0 ... n], which is expressed here in the following way :</p>
 <table class="slide">
  <colgroup>
   <col width="100%">
  </colgroup>
  <tbody>
   <tr>
    <td>
     <!--{type="prop" sci="true" input="forall (n:Nvar) (f:NvarFun), equiv (FFInj n f) (forall (x y:Nvar), ExprLT x n -> ExprLT y n -> app_fun f x = app_fun f y -> nvar x = nvar y)"}--></td>
   </tr>
  </tbody>
  <tbody>
  </tbody>
 </table>
 <p>The pigeonhole principle is demonstrated in the following exercise, following the strict increase of the storage function.</p>
 <p> </p>
 <h3>Solution</h3>
 <p> <span class="light-bulb">ń</span> Use a case base reasoning with the help of
  <!--{type="tag" input="2"}-->. </p>
 <p>Use theorems below on equalities and inequalities:</p>
 <table class="slide">
  <colgroup>
   <col width="100%">
  </colgroup>
  <tbody>
   <tr>
    <td><span class="def">Symmetry</span>
     <!--{type="prop" sci="true" input="forall (x y:O1U), (equiv (x=y) (y=x))"}--><br><br>
     <!--{type="prop" sci="true" input="forall (x y:O1U), (equiv (x<>y) (y<>x))"}--></td>
   </tr>
  </tbody>
  <tbody>
  </tbody>
 </table>
 <table class="slide">
  <colgroup>
   <col width="100%">
  </colgroup>
  <tbody>
   <tr>
    <td><span class="def">Inequality rewritings</span>
     <!--{type="prop" sci="true" input="forall (x y:O1U), (equiv (ExprGT x y) (ExprLT y x))"}--><br><br>
     <!--{type="prop" sci="true" input="forall (x y:O1U), (equiv (ExprGTEQ x y) (ExprLTEQ y x))"}--></td>
   </tr>
  </tbody>
  <tbody>
  </tbody>
 </table>
 <table class="slide">
  <colgroup>
   <col width="100%">
  </colgroup>
  <tbody>
   <tr>
    <td><span class="def">Strict inequality</span>
     <!--{type="prop" sci="true" input="forall (x y:O1U), (ExprGT x y) -> (x <> y)"}--><br><br>
     <!--{type="prop" sci="true" input="forall (x y:O1U), (ExprLT x y) -> (x <> y)"}--></td>
   </tr>
  </tbody>
  <tbody>
  </tbody>
 </table>
</div>
<div class="pedagogic paper" key="exercise_description_logic_quantifier_ex_le_14">
 <!--{type="ex_title"}-->
 <span class="def">source : <span class="exturl"><a href="http://www.lri.fr/~paulin/MathInfo" target="_blank">TP 2 Relations et fonctions</a></span></span>
 <p>The pigeonhole principle is presented in the previous exercise. It is do with demonstrating that if a function is injective over [0 .. n], then there exists x in [0 ... n] such that f(x) ≥ n.</p>
 <p> We have previously demonstrated that a sufficient condition for being injective over [0 ... n] is to be strictly increasing over [0 ... n]. </p>
 <p>The pigeonhole principle is demonstrated opposite, using a strictly increasing function as the hypothesis.</p>
 <div class="slide">
  <p> <span class="light-bulb">ń</span> Use reasoning by recurrence over n. </p>
 </div>
 <p>The theorems below enable us to transform an inequality between two integers to a strcit inequality, and vice versa:</p>
 <table class="slide">
  <colgroup>
   <col width="100%">
  </colgroup>
  <tbody>
   <tr>
    <td><span class="def">Transition to the next integer</span>
     <!--{type="prop" sci="true" input="forall (x y:O1U), (equiv (ExprGT x y) (ExprGTEQ x (y+1)))"}--><br><br>
     <!--{type="prop" sci="true" input="forall (x y:O1U), (equiv (ExprGTEQ x y) (ExprGT (x+1) y))"}--></td>
   </tr>
  </tbody>
  <tbody>
  </tbody>
 </table>
 <p>The different forms of transitivity of comparison operators also enable us to introduce or eliminate strict inequalities from inequalities, and vice versa:</p>
 <table class="slide">
  <colgroup>
   <col width="100%">
  </colgroup>
  <tbody>
   <tr>
    <td><span class="def">Transitivity</span>
     <!--{type="prop" sci="true" input="forall (x y z:O1U), (ExprGT x y) -> (ExprGT y z) -> (ExprGT x z)"}--><br><br>
     <!--{type="prop" sci="true" input="forall (x y z:O1U), (ExprGTEQ x y) -> (ExprGT y z) -> (ExprGT x z)"}--><br><br>
     <!--{type="prop" sci="true" input="forall (x y z:O1U), (ExprGT x y) -> (ExprGTEQ y z) -> (ExprGT x z)"}--><br><br>
     <!--{type="prop" sci="true" input="forall (x y z:O1U), (ExprGTEQ x y) -> (ExprGTEQ y z) -> (ExprGTEQ x z)"}--><br><br>
     <!--{type="prop" sci="true" input="forall (x y z:O1U), (ExprGT x y) -> (ExprGTEQ y z) -> (ExprGTEQ x z)"}--><br><br>
     <!--{type="prop" sci="true" input="forall (x y z:O1U), (ExprGTEQ x y) -> (ExprGT y z) -> (ExprGTEQ x z)"}--></td>
   </tr>
  </tbody>
  <tbody>
  </tbody>
 </table>
</div>
<div class="custom pedagogic" key="exercise_description_logic_quantifier_ex_le_27">
 <!--{type="ex_title"}-->
 <p>This result is available in the other exercises, as <span class="buttontheo">set characterization</span> of a transitive relation.</p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_quantifier_ex_le_31">
 <!--{type="ex_title"}-->
 <p> <span class="light-bulb">ń</span> Use the characterization of a transitive relation, and the conservation of inclusion by composition. </p>
 <p> <span class="light-bulb">A</span>Selecting a term in a proposition with the cursor allows you to replace it with another term; it is therefore necessary to prove that it is equal to the original term. </p>
 <h3>Also see</h3>
 <p>
  <!--{type="exercise" input="logic_quantifier_ex_le_27"}-->
  <!--{type="exercise" input="logic_quantifier_ex_le_47"}--> </p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_quantifier_ex_le_47">
 <!--{type="ex_title"}-->
 <p>Composition conserves inclusion.</p>
 <p> This result is available in other exercises, as "combination by <span class="buttontheo">composition</span>" rule. </p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_quantifier_ex_le_48">
 <!--{type="ex_title"}-->
 <p>The law of excluded middle is demonstrated by assuming ad absurdium rule (double negation elimination).</p>
 <p><span class="lock">w</span><span class="cons">Constructive logic</span></p>
</div>
<div class="pedagogic paper" key="exercise_description_logic_quantifier_ex_le_71">
 <!--{type="ex_title"}-->
 <p>Mrs. Muddled has three children, Alice, Bill, and Carl.</p>
 <p>When asked her 3 children's ages, Mrs. Muddled said that Alice is the youngest unless Bill is, and that if Carl isn't the youngest then Alice is the oldest.</p>
 <p> Who is the oldest and who is the youngest?</p>
 <h3>Theory</h3>
 <p>Information given by Mrs. Muddled is provided by assumptions <span class="propid">4</span> et <span class="propid">5</span></p>
 <p>There’s some implicit meaning in the superlative words “youngest” and “oldest” provided by the following rules : </p>
 <table class="slide">
  <colgroup>
   <col width="100%">
  </colgroup>
  <tbody>
   <tr>
    <td> <span class="def">Antonymy</span>
     <!--{type="prop" input="forall (x:Child), (Youngest x) -> (~(Oldest x))"}--><br><br>
     <!--{type="prop" input="forall (x:Child), (Oldest x) -> (~(Youngest x))"}--> </td>
   </tr>
  </tbody>
  <tbody>
  </tbody>
 </table>
 <p>Finally, “youngest” and “oldest” are opposites. Since there is more than one child, no one can be both.</p>
 <table class="slide">
  <colgroup>
   <col width="100%">
  </colgroup>
  <tbody>
   <tr>
    <td> <span class="def">Uniqueness</span>
     <!--{type="prop" input="forall (x y:Child), (x <> y) -> (Youngest x) -> (~(Youngest y))"}--><br><br>
     <!--{type="prop" input="forall (x y:Child), (x <> y) -> (Oldest x) -> (~(Oldest y))"}--> </td>
   </tr>
  </tbody>
  <tbody>
  </tbody>
 </table>
</div>
<div class="pedagogic paper" key="exercise_description_logic_quantifier_ex_le_72">
 <!--{type="ex_title"}-->
</div>
<div class="pedagogic paper" key="exercise_description_sigma_ex_15">
 <!--{type="ex_title"}-->
</div>
<div class="pedagogic paper" key="exercise_description_sigma_ex_16">
 <!--{type="ex_title"}-->
</div>
<div key="help_description_icon_exercises_check">
 <p>exercise solved. Click 'Start' to load the solution.</p>
</div>
<div key="help_description_icon_exercises_difficulty">
 <p>difficulty level from 0 (easy) -to 3 (hard).</p>
</div>
<div key="help_description_icon_exercises_lighbulb">
 <p>Solution hints (tutorial exercises provide this service)</p>
</div>
<div key="help_description_icon_exercises_lock">
 <p>Lock. Obtain the 'tutorial' cockade of current chapter (and possibly prerequisite chapters) to unblock exercise.</p>
</div>
<div key="help_description_icon_trophy_all">
 <p>The 'universal' cockade is obtained when all exercises of the chapter are solved.</p>
</div>
<div key="help_description_icon_trophy_diagnostic">
 <p>The 'express' cockade is obtained when all exercises marked 'express' are resolved. As a result, chapter theorems are available in the diagnosis window.</p>
</div>
<div key="help_description_icon_trophy_tutorial">
 <p>The 'tutorial' cockade is obtained when all tutorial exercises are solved.</p>
</div>
<div key="help_description_icon_trophy_unavoidable">
 <p>The cockade 'unavoidable' is obtained when all the exercises marked 'unavoidable' of the chapter are solved.</p>
</div>
<div key="help_description_shortcut_browsing_left_scope">
 <p>Display scope to the left of current the scope</p>
</div>
<div key="help_description_shortcut_browsing_lower_prop">
 <p>Move focus to the statement below</p>
</div>
<div key="help_description_shortcut_browsing_open_scope">
 <p>Open justification scope</p>
</div>
<div key="help_description_shortcut_browsing_redo">
 <p>Redo proof step</p>
</div>

<!-- ## Mirai -->

<div key="help_description_shortcut_browsing_right_scope">
 <!-- <p>Display scope to the right of the current scope</p> -->
 <p>現在のスコープの右にスコープを表示</p>
</div>
<div key="help_description_shortcut_browsing_undo">
 <!-- <p>Undo last proof step</p> -->
 <p>直前の証明ステップを戻す</p>
</div>
<div key="help_description_shortcut_browsing_upper_prop">
 <!-- <p>Move focus to the statement above</p> -->
 <p>フォーカスを上に移す</p>
</div>
<div key="help_description_shortcut_commutativity_commut_left">
 <!-- <p>Select term on the left</p> -->
 <p>左の項を選択</p>
</div>
<div key="help_description_shortcut_commutativity_commut_mode">
 <!-- <p>Activate keybaord commutative mode</p> -->
 <p>キーボード交換モード[??]に入る</p>
</div>
<div key="help_description_shortcut_commutativity_commut_right">
 <!-- <p>Select term on the right</p> -->
 <p>右の項を選択</p>
</div>
<div key="help_description_shortcut_commutativity_commut_shift_left">
 <!-- <p>Move selected term to the left</p> -->
 <p>選択した項を左に移す</p>
</div>
<div key="help_description_shortcut_commutativity_commut_shift_right">
 <!-- <p>Move selected term to the right</p> -->
 <p>選択した項を右に移す</p>
</div>
<div key="help_description_shortcut_commutativity_enter_commut">
 <!-- <p>Apply terms reordering</p> -->
 <p>項を整列する</p>
</div>
<div key="help_description_shortcut_commutativity_esc_commut">
 <!-- <p>Exit keyboard commutative mode</p> -->
 <p>キーボード交換モード[??]から抜ける</p>
</div>
<div key="help_description_shortcut_evar_enter_evar">
 <!-- <p>Assign a value to a proof variable</p> -->
 <p>値を証明変数に割り当てる</p>
</div>
<div key="help_description_shortcut_evar_esc_evar">
  <!--<p>Exit keyboard proof variable mode</p>-->
  <p>キーボード証明変数モードから抜ける</p>
</div>
<div key="help_description_shortcut_evar_evar_left">
  <!--<p>Select previous proof variable</p>-->
  <p>前の証明変数を選択</p>
</div>
<div key="help_description_shortcut_evar_evar_mode">
  <!--<p>Activate keyboard proof variable mode</p>-->
  <p>キーボード証明変数モードに入る</p>
</div>
<div key="help_description_shortcut_evar_evar_right">
  <!--<p>Select next proof variable</p>-->
  <p>次の証明変数を選択</p>
</div>
<div key="help_description_shortcut_proof_context">
  <!--<p>Show / hide context (statements from other scopes available for deduction) </p>-->
  <p>コンテキスト(推論に使える他のスコープからのステートメント)を表示する/隠す</p>
</div>
<div key="help_description_shortcut_proof_deduce">
  <!--<p>Open diagnostic window in deduction</p>-->
  <p>推論の診断ウィンドウを開く</p>
</div>
<div key="help_description_shortcut_proof_enter">
  <!--<p>Perform one of the following:</p>-->
  <p>以下のうち一つを実行：</p>
 <ul>
  <!--<li style="font-size:14px">Open diagnostic window in deduction if the statement is justified</li>-->
  <li style="font-size:14px">ステートメントが正当化されれば推論の診断ウィンドウを開く</li>
  <!--<li style="font-size:14px">Open diagnostic window in justification if the statement is not justified</li>-->
  <li style="font-size:14px">ステートメントが正当化されなければ正当化の診断ウィンドウを開く</li>
  <!--<li style="font-size:14px">Unify statement</li>-->
  <li style="font-size:14px">ステートメントを統合する</li>
 </ul>
</div>
<div key="help_description_shortcut_proof_justify">
  <!--<p>Perform one of the following:</p>-->
  <p>以下のうち一つを実行：</p>
 <ul>
  <!--<li style="font-size:14px">Open diagnostic window in justification if the statement is not justified</li>-->
  <li style="font-size:14px">ステートメントが正当化されなければ正当化の診断ウィンドウを開く</li>
  <!--<li style="font-size:14px">Display justification theorem in the toolbox if the proposal is justified</li>-->
  <li style="font-size:14px">提案が正当化されればツールボックス内に正当化の定理を表示</li>
 </ul>
</div>
<div key="help_description_shortcut_selection_enter_select">
  <!--<p>Open diagnostics window to rewrite selected term</p>-->
  <p>選択された項を書き換えるために診断ウィンドウを開く</p>
</div>
<div key="help_description_shortcut_selection_esc_select">
  <!--<p>Exit keybaord selection mode</p>-->
  <p>キーボード選択モードから抜ける</p>
</div>
<div key="help_description_shortcut_selection_group_select">
  <!--<p>Mark selected term as group (keep intact the term during rewriting)</p>-->
  <p>選択された項をグループとしてマークする(書き換えの間項を操作しない)</p>
</div>
<div key="help_description_shortcut_selection_select_down">
  <!--<p>Select first argument</p>-->
  <p>一番目の引数を選択</p>
</div>
<div key="help_description_shortcut_selection_select_left">
  <!--<p>Select previous argument</p>-->
  <p>前の引数を選択</p>
</div>
<div key="help_description_shortcut_selection_select_mode">
  <!--<p>Activate keyboard selection mode</p>-->
  <p>キーボード選択モードに入る</p>
</div>
<div key="help_description_shortcut_selection_select_right">
  <!--<p>Select next argument</p>-->
  <p>次の引数を選択</p>
</div>
<div key="help_description_shortcut_selection_select_shift_left">
  <!--<p>Increase selection with term on the left</p>-->
  <p>左の項へ選択を増やす</p>
</div>
<div key="help_description_shortcut_selection_select_shift_right">
  <!--<p>Increase selection with next terme</p>-->
  <p>次の項へ選択を増やす</p>
</div>
<div key="help_description_shortcut_selection_select_up">
  <!--<p>Select the function whose argument is selected term</p>-->
  <p>引数が選択された項であるような関数を選択</p>
</div>
<div key="help_description_shortcut_unification_enter_union">
  <!--<p>Unify with selected statement</p>-->
  <p>選択されたステートメントと統合する</p>
</div>
<div key="help_description_shortcut_unification_esc_union">
  <!--<p>Exit keyboard unification mode</p>-->
  <p>キーボード統合モードから抜ける</p>
</div>
<div key="help_description_shortcut_unification_left_union">
  <!--<p>Select left statement</p>-->
  <p>左のステートメントを選択</p>
</div>
<div key="help_description_shortcut_unification_right_union">
  <!--<p>Select right statement</p>-->
  <p>右のステートメントを選択</p>
</div>
<div key="help_description_shortcut_unification_union_mode">
  <!--<p>Activate keyboard unfication mode</p>-->
  <p>キーボード統合モードに入る</p>
</div>
<div key="help_section_description_browsing">
  <!--<p>The proof is presented in the style of natural deduction: justified statements are positioned on top of each other; assumptions are on top, and the conclusion is the last statement.</p>-->
  <p>証明は自然演繹によって与えられています。正当化されたステートメントはそうでないステートメントの上に書かれます。仮定は上に置かれ、結論は最後のステートメントとなります。</p>
 <p>[!!]A justification is a theorem applied to statements above justified statement. A justification may also be a proof, which is then in another scope (represented by a tab).</p>
 <!--<p>One can navigate in the paper with the cursor, or with the keyboard thanks to keyboard shortcuts below:</p>-->
 <p>画面の操作はカーソルか、以下のキーボードショートカットを使ってできます：</p>
</div>
<div key="help_section_description_commutativity">
  <!--<p>When choosing commutative rewriting, one can reorder the terms with the curor by drag-and-drop, or with the keyboard thanks to keyboard shortcuts below:</p>-->
  <p>交換書き換えを選択したとき、項の並び換えをドラッグ・アンド・ドロップか以下のキーボードショートカットでできます：</p>
</div>
<div key="help_section_description_evar">
  <!--<p>Proof variables may appear when applying a theorem (a proof varaible is represented with a blue tag)</p>-->
  <p>定理を適用するとき証明変数が現れることがあります(証明変数は青いタグで表示されます)</p>
  <!--<p>On can assign a value to a proof variable by clicking on it, or with keyboard shortcuts below:</p>-->
  <p>証明変数へ値を割り当てるには、証明変数をクリックするか以下のキーボードショートカットを使います：</p>
</div>
<div key="help_section_description_exercises">
 <!--TODO-->
</div>
<div key="help_section_description_proof">
  <!--<p>Several proof actions are possible:</p>-->
  <p>次のような証明の操作ができます：</p>
 <ul>
  <!--<li style="font-size:14px">Justify (if the proposal is not already justified)</li>-->
  <li style="font-size:14px">正当化(提案がまだ正当化されていないとき)</li>
  <!--<li style="font-size:14px">Unify (if unifiable statements are proposed)</li>-->
  <li style="font-size:14px">統合(統合可能なステートメントが提示されているとき</li>
  <!--<li style="font-size:14px">Deduce</li>-->
  <li style="font-size:14px">推論</li>
  <!--<li style="font-size:14px">Delete (if the proposal is not used by any justification)</li>-->
  <li style="font-size:14px">削除(提案がどの正当化にも使われていないとき)</li>
  <!--<li style="font-size:14px">Move by dragging and dropping the index tag of the statement (as long as the deductive style is respected : a statement used by a justification can only be above justified statement)</li>-->
  <li style="font-size:14px">ステートメントのインデックス・タグをドラッグ・アンド・ドロップで移動(正当化で使われるステートメントが上の正当化されたステートメントとしてのみ現れるとき)
 </ul>
 <!--<p>Keyboard shortcuts are available:</p>-->
 <p>次のキーボードショートカットが利用できます：</p>
</div>
<div key="help_section_description_selection">
  <!--<p>Selecting a term allows to rewrite it (development, factoring, ...)</p>-->
  <p>項を選択することで展開や因数分解などでそれを書き換えることができます</p>
  <!--<p>Term selection is done either with the cursor or with keyboard shortcuts below:</p>-->
  <p>項の選択はカーソルか以下のキーボードショートカットでできます：</p>
</div>
<div key="help_section_description_trophy">
 <!--TODO-->
</div>
<div key="help_section_description_unification">
  <!--<p>When several unifications are possible, select the appropriate statement with the cursor or with keyboard shortcuts below:</p>-->
  <p>複数の統合が可能なとき、適切なステートメントをカーソルか以下のキーボードショートカットで選択してください：</p>
</div>
<div key="pager_account"></div>
<div class="pager" key="pager_algebra">
 <a href="https://fr.wikipedia.org/wiki/%C3%89variste_Galois" target="_blank"><img class="txtwrap" src="./img/Evariste_galois.jpg" height="20%" width="20%"></a>
 <!--<p>The <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Structure_alg%C3%A9brique" target="_blank">algebraic structures</a></span> are of this chapter study of objects.</p>-->
 <p><span class="exturl"><a href="https://fr.wikipedia.org/wiki/Structure_alg%C3%A9brique" target="_blank">代数的構造</a></span>はこの章で学ぶ。</p>
 <!--<p> In the early nineteenth <span class="sup">century,</span> <span class="exturl"><a href="https://fr.wikipedia.org/wiki/%C3%89variste_Galois" target="_blank">Evariste Galois</a></span> introduced the concept of <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Groupe_(math%C3%A9matiques)" target="_blank">group</a></span> . </p>-->
 <p>19世紀初頭、<span class="exturl"><a href="https://fr.wikipedia.org/wiki/%C3%89variste_Galois" target="_blank">エヴァリスト・ガロア</a></span>は<span class="exturl"><a href="https://fr.wikipedia.org/wiki/Groupe_(math%C3%A9matiques)" target="_blank">群</a></span>の概念を導入しました。</p>
</div>
<div key="pager_algebra_structures"></div>
<div class="pager" key="pager_analysis">
 <a href="https://fr.wikipedia.org/wiki/Augustin_Louis_Cauchy" target="_blank"><img class="txtwrap" src="./img/Augustin-Louis_Cauchy_1901.jpg" height="12%" width="12%"></a>
 <p> During the <span class="sup">19th</span> century, mathematicians lay the foundations for analyzing the properties of real functions (functions in real terms): continutité, convergence, limits, differentiation, integration, ... </p>
 <p>19世紀、数学者は実関数の性質を解析するための基礎付けに取り組んでいた。</p>
 <!--<p> In France from the beginning of the century, <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Augustin_Louis_Cauchy" target="_blank">Augustin-Louis Cauchy</a></span> in particular studying the convergence properties of the positive increasing sequences, introduced in this chapter. In Germany, <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Bernhard_Riemann" target="_blank">Bernhard Riemann</a></span> , and <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Karl_Weierstrass" target="_blank">Karl Weierstrass</a></span> develop theories of integration and function limits. </p>-->
 <p>19世紀の始めごろからフランスでは、<span class="exturl"><a href="https://fr.wikipedia.org/wiki/Augustin_Louis_Cauchy" target="_blank">オーギュスタン=ルイ・コーシー</a></span>は、この章で導入される、正項増加数列の収束の性質について研究していた。ドイツでは、<span class="exturl"><a href="https://fr.wikipedia.org/wiki/Bernhard_Riemann" target="_blank">ベルンハルト・リーマン</a></span>や<span class="exturl"><a href="https://fr.wikipedia.org/wiki/Karl_Weierstrass" target="_blank">カール・ワイエルシュトラス</a></span>は積分や関数の極限の理論を発展させていた。</p>
</div>
<div class="pager" key="pager_analysis_induction">
 <!--<p> <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Raisonnement_par_r%C3%A9currence" target="_blank">Mathematical induction</a></span> is a simple and yet very powerful theorem. It allows to prove that a proposition P (n) dependent on an index n, is true regardless of the value of the index, which means true for an infinite number of values of the index n. </p>-->
 <p> <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Raisonnement_par_r%C3%A9currence" target="_blank">数学的帰納法</a></span>はシンプルかつ強力な原理である。数学的帰納法を使うことによって、自然数 n に依存した命題 P (n) が n の値に関わらずに真であることを示すことができる。つまり、無限個の値 n に対して証明を与えられる。</p>
 <!--<p> For example, without induction, it would require a very large amount (if not infinite) of calculation steps to get confidant that P is true for any value of n, while induction provides with absolute certainty in a few proof steps. </p>-->
 <p>たとえば、帰納法が数個のステップで証明を与えるのに対し、帰納法なしの証明では非常に多くの計算のステップを必要とすることがある。</p>
</div>
<div class="pager" key="pager_analysis_limits">
  <!--<p>The limit of a function at a point or at infinity is formally introduced. The calculation method by composition of limits is presented : for example under certain conditions, the limit of a sum is the sum of the limits. This method enables to compute the limit of any function by decomposing it into elementary functions with known limits. </p>-->
  <p>関数のある点や無限遠への極限が形式的に導入される。極限の合成による計算方法がいくつかある。たとえば、ある条件の下で、和の極限は極限の和に等しくなる。この法則を使えば、任意の関数を極限の分かっている初等関数の和に分解することで元の関数の極限を計算することができる。</p>
</div>
<div class="pager" key="pager_analysis_series">
 <!--<p> A series is a function of ℕ in ℝ. Here we introduce some fundamental properties of these functions: </p>-->
 <p> 級数はℕ からℝへの関数です。このような関数の基本的な性質には以下のようなものがある：</p>
 <ul>
  <!--<li>increasing decreasing monotonicities</li>-->
  <li>増加・減少の単調性</li>
  <!--<li>upper and lower bounds</li>-->
  <li>上限、下限</li>
  <!--<li>convergence, divergence</li>-->
  <li>収束、発散</li>
 </ul>
</div>
<div key="pager_axiom">
 <!--TODO-->
</div>
<div key="pager_badges"></div>
<div key="pager_credits"></div>
<div key="pager_dashboard"></div>
<div class="custom pager" key="pager_demo_seg">
  <!--<p>Calculus is about transforming an equality relation (or inequality), between real numbers or vectors for example. The challenge is to work out a sequence of algebraic manipulations (factorize, expand, ...) from assumption(s) to conclusion.</p>-->
  <p>微積分学は実数や実ベクトルなどの間の等式や不等式の変換について扱う。微積分学の中ですることは、因数分解や展開などの代数的操作の列によって仮定から結論を導くことである。
</div>
<div key="pager_double_inequality">
 <!--<p>The double inequality
  {type="expr" input="is_bounded ExprLTLT a b c"} is equivalent to the two inequalities :
  {type="expr" input="ExprLT a b"} and
  {type="expr" input="ExprLT b c"}. Hence double Inequality properties are the same as inequality properties.</p>-->
 <p>二重不等式
  <!--{type="expr" input="is_bounded ExprLTLT a b c"}--> は次の二つの不等式と同値：
  <!--{type="expr" input="ExprLT a b"}-->,
  <!--{type="expr" input="ExprLT b c"}-->. よって二重不等式は不等式と同じ性質を持つ。
</div>
<div class="pager" key="pager_eq_seg">
  <!--<p>A equality can be transformed, especially with the operations introduced in this chapter:</p>-->
  <p>等式は、特にこの章で導入される操作によって変形できる：</p>
 <ul>
  <!--<li>left and right operations that can "pass a term to the other side" by changing its sign</li>-->
  <li>項を左辺から右辺(または右辺から左辺)に移す。ただし、このとき項の符号は反転する。(移項)</li>
  <!--<li>combinations of equalities, typically to solve systems of equations</li>-->
  <li>等式の合成。特に方程式を解くときに使われる。</li>
  <!--<li>squaring, root squaring (if the value is positive), ...</li>-->
  <li>二乗、平方根(値が正のとき)等</li>
 </ul>
</div>
<div class="pager" key="pager_ineq_seg">
  <!--<p>Inequalities compare two real numbers. They transform similarly to the equations with:</p>-->
  <p>不等式は二つの実数を比較します。等式と同様に以下の変形がある：</p>
 <ul>
  <!--<li>operations to left and right sides</li>-->
  <li>移項</li>
  <!--<li>combinations (addition, subtraction)</li>-->
  <li>合成(加法、減法)</li>
  <!--<li>functions (opposite, square root, ...)</li>-->
  <li>関数(-1倍、平方根、……)</li>
  <li>...</li>
 </ul>
 <!--<p>If the function applied to the left and right sides of an inequality is decreasing, then the sense of the inequality is reversed.</p>-->
 <p>もし不等式の両辺に適用された関数が単調減少なら、不等式の左辺と右辺は入れ替わる。</p>
</div>
<div key="pager_internal">
 <!--TODO-->
</div>
<div class="pager" key="pager_logic">
 <!--<p> The grammar of <span class="exturl"><a href="https://en.wikipedia.org/wiki/Propositional_calculus" target="_blank">propositions</a></span>, and associated reasoning rules, form a logical system called <span class="exturl"><a href="https://en.wikipedia.org/wiki/Natural_deduction" target="_">natural deduction</a></span>, notably used for developing mathematical <span class="exturl"><a href="https://en.wikipedia.org/wiki/Mathematical_proof" target="_blank">demonstrations</a></span>. </p>-->
 <p><span class="exturl"><a href="https://ja.wikipedia.org/wiki/%E5%91%BD%E9%A1%8C%E8%AB%96%E7%90%86" target="_blank">命題</a></span>の文法とそれに付随した推論規則は、数学の<span class="exturl"><a href="https://ja.wikipedia.org/wiki/%E8%A8%BC%E6%98%8E#.E6.95.B0.E5.AD.A6.E3.80.81.E8.A8.98.E5.8F.B7.E8.AB.96.E7.90.86.E5.AD.A6.E3.81.AB.E3.81.8A.E3.81.91.E3.82.8B.E8.A8.BC.E6.98.8E" target="_blank">証明</a></span>について形式的に考えるときに使う、<span class="exturl"><a href="https://ja.wikipedia.org/wiki/%E5%91%BD%E9%A1%8C%E8%AB%96%E7%90%86" target="_">自然演繹</a></span>と呼ばれる論理体系を成す。</p>
 <!--<p>This system is valuable because it is independent from the theory studied. A theory is the set of axioms (acknowledged theorems) defining objects and their properties.</p>-->
 <p>自然演繹は扱う理論と独立している。理論とは数学的対象やその性質を定義するような公理の集合である。</p>
</div>
<div class="pager" key="pager_logic_connector">
 <!--<p>Logical connectors are fundamental elements for forming mathematical propositions from two propositions, whatever A and B are:</p>-->
 <p>論理結合子とは二つの数学的命題から別の命題を作るための基本的な要素である。命題 A と B に対して、</p>
 <ul>
  <!--<li>implication, A implies B, noted "A ⇒ B"</li>-->
  <li>含意：A ならば B (A ⇒ B)</li>
  <!--<li>conjunction, A and B, noted "A ∧ B"</li>-->
  <li>論理積：A または B (A ∧ B)</li>
  <!--<li>disjunction, A or B, noted "A ∨ B"</li>-->
  <li>i論理和：A または B (A ∨ B)</li>
  <!--<li>negation, not A, noted "¬ A"</li>-->
  <li>否定：A でない (¬ A)</li>
 </ul>
 <!--<p>Each of these connectors is associated with two rules:</p>-->
 <p>それぞれの結合子は二つの規則に結び付いている：</p>
 <ul>
   <!--<li>a rule to justify (or demonstrate) the proposition: how can we justify "A ∧ B" ?</li>-->
   <li>命題を証明するための規則："A ∧ B" をどうやって示すか？</li>
   <!--<li>a rule to deduce a new proposition: what can we deduce from "A ∧ B" ?</li>-->
   <li>新しい命題を推論するための規則："A ∧ B" から何が推論されるか？</li>
 </ul>
</div>
<div class="pager" key="pager_logic_function">
  <!--<p>A function f is a formula that has a value x, such that the proposition "y=f(x)" is a functional relation of x and y.</p>-->
  <p>関数 f は命題 "y=f(x)"が x と y の関数関係[??]であるような、変数 x を持つ論理式である。</p>
</div>
<div class="pager" key="pager_logic_quantifier">
  <!--<p>Mathematical propositions can also be formulae with variables taking on certain values: for example "3 is a prime number" can be considered as the formula "x is a prime number" where the variable "x" is replaced by "3".</p>-->
  <p>数学的命題は特定の値を取る論理式と見なせる。たとえば、「3は素数である」は論理式「xは素数である」の変数 x を3に置き換えたものと考えられる。</p>
 <!--<p> For a formula with a variable, we need to express that the proposition is true <span class="stress" style="font-size: 16px">for every</span> value the variable assumes, or that <span class="stress" style="font-size: 16px">there exists</span> at least one value for which the proposition is true. These new elements language are the quantifiers. </p>-->
 <p>変数を一つ取る論理式に対して、命題が<span class="stress" style="font-size: 16px">任意の</span>値について真であることや、少くとも一つの<span class="stress" style="font-size: 16px">ある</span>値に対して命題が真であることを表現する必要がある。これを実現するのが量化子である。</p>
</div>
<div class="pager" key="pager_logic_relation">
  <!--<p>Relations, omnipresent in mathematics, are formulae that relate two values belonging to two, potentially different, universes. We talk about binary relation when the values belong to the same universe.</p>-->
 <p>関係とは二つの世界に属する二つの値を関連付けるような論理式であり、数学のいたるところに現れる。二つの値が同じ世界に属するとき二項関係について述べる。</p>
 <!--<p>The characterization of relations, as well as their properties, are presented.</p>-->
 <p>関係の特徴付けは、その性質と同様に与えられる。</p>
</div>
<div class="pager" key="pager_rewrite_seg">
 <!--<p>Rewriting operations allow to deduce a new equality, almost identical, in which a term-->
  <!--{type="expr" input="a"}--><!-- is replaced by a term-->
  <!--{type="expr" input="b"}--><!-- , provided-->
  <!--{type="prop" sci="true" style="vertical-align:-3px;" input="a = b"}--><!-- . Rewriting of a to b is given by the algebraic calculation:</p>-->
 <p>Rewriting operations allow to deduce a new equality, almost identical, in which a term
  <!--{type="expr" input="a"}--> is replaced by a term
  <!--{type="expr" input="b"}--> , provided
  <!--{type="prop" sci="true" style="vertical-align:-3px;" input="a = b"}--> . 書き換えは以下のような代数的計算によって与えられる：</p>
 <ul>
  <!--<li>factoring, expansion</li>-->
  <li>因数分解、展開</li>
  <!--<li>remarkable identities</li>-->
  <li>恒等式</li>
  <!--<li>simplifications</li> ...-->
  <li>簡単化</li>
 </ul>
 <!--<p>For example, one can deduce from-->
  <!--{type="prop" sci="true" style="vertical-align:-3px;" input="x=(2*(x-1))"}--><!-- the statement-->
  <!--{type="prop" sci="true" style="vertical-align:-3px;" input="x= (2*x) - 2"}--><!-- by replacing the term-->
  <!--{type="expr" input="2*(x-1)"}--><!-- by-->
  <!--{type="expr" input="minus (2*x) 2"}--><!-- ; we known that-->
  <!--{type="prop" sci="true" style="vertical-align:-3px;" input="(2*(x-1)) = ((2*x)-2)"}--><!-- by expansion.</p>-->
 <p>たとえば、式
  <!--{type="prop" sci="true" style="vertical-align:-3px;" input="x=(2*(x-1))"}-->から式
  <!--{type="prop" sci="true" style="vertical-align:-3px;" input="x= (2*x) - 2"}-->は項
  <!--{type="expr" input="2*(x-1)"}-->を
  <!--{type="expr" input="minus (2*x) 2"}-->で置き換えることで得られる。恒等式
  <!--{type="prop" sci="true" style="vertical-align:-3px;" input="(2*(x-1)) = ((2*x)-2)"}-->は展開によって得られる。</p>
</div>
<div class="pager" key="pager_set_operators">
 <p>A set E is a collection of objects that are called <span class="stress" style="font-size:16px">the elements</span> of E.</p>
 <p>The proposition that an element x belongs to E, or is an element of E, is noted <span class="stress" style="font-size:16px">
   <!--{type="prop" sci="true" input="sis_element x E"}--></span>. The negation of membership, ¬(
  <!--{type="prop" sci="true" input="sis_element x E"}-->), is noted <span class="stress" style="font-size:16px">
   <!--{type="prop" sci="true" input="~sis_element x E"}--></span>. </p>
 <!--<p>A <span class="exturl"><a href="https://en.wikipedia.org/wiki/Set_(mathematics)" target="blank">set operator</a></span> allows us to construct one set from other sets.</p>-->
 <p><span class="exturl"><a href="https://ja.wikipedia.org/wiki/%E9%9B%86%E5%90%88" target="blank">集合演算</a></span>は集合から別の集合を作る。</p>
</div>
<div class="pager" key="pager_set_rewoperators">
  <!--<p>Algebraic calculations on sets resemble calculations on numbers because: </p>-->
  <p>集合上の代数的計算は以下のように数の計算に似ている：</p>
 <ul>
   <!--<li>set operations (intersection, union, ...) have properties similar to operations on reals (addition, multiplication, ...): these operations are associative, commutative, distributive, ... </li>-->
  <li>共通部分、和などの集合演算は実数の和、積などの演算に似た性質を持つ。具体的には、これらの演算はそれぞれ結合律、可換律、分配律などをみたす。</li>
  <!--<li>set equality and real equality are equivalence relations that are transitive, symmetric and reflexive (see next section)</li>-->
  <li>集合のイコールと実数のイコールはそれぞれ同値関係である。つまり、推移律、対称律、反射律をみたす(次章を参照)。</li>
 </ul>
 <!--<p>Set algebra is equivalent to the <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Alg%C3%A8bre_de_Boole_(logique)" target="_blank">Boolean algebra</a></span> : either an element belongs to a set, or it does not. This algebra is central in computer science, in software development and in the design of electronic circuits. </p>-->
 <p>集合代数は<span class="exturl"><a href="https://ja.wikipedia.org/wiki/%E3%83%96%E3%83%BC%E3%83%AB%E4%BB%A3%E6%95%B0" target="_blank">ブール代数</a></span>に同値である。要素は集合に属しているか、そうでないかのどちらかである。この代数系は計算機科学、ソフトウェア開発、電子回路設計において中心的な役割を果たす。 </p>
</div>
<div class="pager" key="pager_settheory">
 <a href="https://ja.wikipedia.org/wiki/%E3%82%B2%E3%82%AA%E3%83%AB%E3%82%AF%E3%83%BB%E3%82%AB%E3%83%B3%E3%83%88%E3%83%BC%E3%83%AB" target="_blank"><img class="txtwrap" src="./img/cantor.jpg" height="12%" width="12%"></a>
 <!--<p> At the end of the 19<span class="sup">th</span> Century, the German mathematician <span class="exturl"><a href="https://en.wikipedia.org/wiki/Georg_Cantor" target="_blank">Georg Cantor</a></span> developed the <span class="exturl"><a href="https://en.wikipedia.org/wiki/Set_theory" target="_blank">set theory</a></span>. This theory allows us to define fundamental elements of mathematics, notably integers, real numbers, functions ... </p>-->
 <p>19世紀後半、ドイツの数学者<span class="exturl"><a href="https://ja.wikipedia.org/wiki/%E3%82%B2%E3%82%AA%E3%83%AB%E3%82%AF%E3%83%BB%E3%82%AB%E3%83%B3%E3%83%88%E3%83%BC%E3%83%AB" target="_blank">ゲオルグ・カントール</a></span>は<span class="exturl"><a href="https://ja.wikipedia.org/wiki/%E9%9B%86%E5%90%88%E8%AB%96" target="_blank">集合論</a></span>を確立した。整数、実数、関数などの数学の基本的対象は集合論によって定義される。</p>
 <!--<p>In 1930, The Austro-Hungarian mathematician, <span class="exturl"><a href="https://en.wikipedia.org/wiki/Kurt_G%C3%B6del" target="_blank">Kurt Gödel</a></span> even demonstrated that any theory can be translated into the set theory. </p>-->
 <p>1930年、オーストリア・ハンガリー二重帝国生まれの数学者<span class="exturl"><a href="https://ja.wikipedia.org/wiki/%E3%82%AF%E3%83%AB%E3%83%88%E3%83%BB%E3%82%B2%E3%83%BC%E3%83%87%E3%83%AB" target="_blank">クルト・ゲーデル</a></span>は任意の理論が集合論に翻訳できることを示した。</p>
</div>
<div class="pager" key="pager_sigma_seg">
 <!--<p>Sigma notation used to sum a series of indexed terms noted-->
  <!--{type="expr" input="app_series a i"}--><!-- (with the index i from 1 to n typically). This sum is noted:-->
  <!--{type="expr" style="vertical-align: -4px;" input="(sigma(k,1,n,(app_series a k)))"}--><!-- .</p>-->
 <p>添字付きの項の和を表現するとき、シグマ記法と呼ばれる以下の表記法がある。
  <!--{type="expr" input="app_series a i"}--> (添字 i は 1 から n の範囲を動く)の和は、
  <!--{type="expr" style="vertical-align: -4px;" input="(sigma(k,1,n,(app_series a k)))"}-->と書く。</p>
 <!--<p>In this notation, the index k is a dummy variable: it is not declared in the context and is valid only for the summed expression.</p>-->
 <p>この記法において、k はダミー変数であり、和の式内においてのみ有効である。</p>
 <!--<p>Sigma properties are those of the addition (associativity, distributivity of multiplication, ...) and those of index shits.</p>-->
 <p>シグマの性質には、結合律、積の分配律などの和の性質と、添字の書き換えに関する性質がある。</p>
</div>
<div key="slide_demo_tuto_app_(integer 3 * x - integer 6 = zero,lradd,0)">
 <!-- 	(integer 3 * x - integer 6 = zero,lradd,0)
	by Forward lradd)
 -->
 <div expr="(integer 3 * x - integer 6 = zero,lradd,0)" class="pedagogic slide" exercise="demo_tuto_app">
  <!--<p>The objective is to <span class="stress">isolate the term-->
   <!--{type="expr" input="pow x 2"}--></span><!-- on the left. Start by isolating x on the left as in the previous exercise, and then square left and right sides of the resulting equality.</p>-->
  <p>目標は項<span class="stress">
    <!--{type="expr" input="pow x 2"}-->を独立させる</span>ことである。まず x を前の演習問題のように左に独立させ、最終的な等式の両辺に二乗を適用する。</p>
 </div>
</div>
<div key="slide_demo_tuto_app_(integer 3 * x = integer 6,lrdiv,0)">
 <!-- 	(integer 3 * x = integer 6,lrdiv,0)
	by Forward lrdiv)
 -->
 <div expr="(integer 3 * x = integer 6,lrdiv,0)" class="pedagogic slide" exercise="demo_tuto_app">
   <!--<p>Divide by 3 on the left and right sides in order to isolate x.</p>-->
   <p>x を独立させるために両辺を3で割る。</p>
 </div>
</div>
<div key="slide_demo_tuto_app_(x = integer 2,app_square,0)">
 <!-- 	(x = integer 2,app_square,0)
	by Forward app_square)
 -->
 <div expr="(x = integer 2,app_square,0)" class="pedagogic slide" exercise="demo_tuto_app">
   <!--<p>The square function is applied on the left and right sides.</p>-->
   <p>両辺に二乗関数が適用される。</p>
 </div>
</div>
<div key="slide_demo_tuto_comb_(integer 3 * x - y = zero,combadd,0)">
 <!-- 	(integer 3 * x - y = zero,combadd,0)
	by Forward combadd)
 -->
 <div expr="(integer 3 * x - y = zero,combadd,0)" class="pedagogic slide" exercise="demo_tuto_comb">
  <!--A<p>The objective is to isolate x by first <span class="stress">eliminating y.</span> We note that y shows on the left hand side of statement-->
   <!--{type="tag" input="s0"}--><!-- and that the opposite of y shows on the left side of-->
   <!--{type="tag" input="s1"}--><!-- .</p>-->
  <p>目標はまず<span class="stress">y を消去</span>することで x を独立させることである。今、y は
   <!--{type="tag" input="s0"}--> の左辺にあり、また -y が
   <!--{type="tag" input="s1"}--> の左辺にある。</p>
  <!--<p>We can eliminate y by adding sides to sides-->
   <!--{type="tag" input="s1"}--><!-- and-->
   <!--{type="tag" input="s0"}--><!-- .</p>-->
  <p>よって、
   <!--{type="tag" input="s1"}--> と
   <!--{type="tag" input="s0"}--> の辺同士を足すことによって y が消去できる。</p>
 </div>
</div>
<div key="slide_demo_tuto_comb_(integer 4 * x = integer 4,lrdiv,0)">
 <!-- 	(integer 4 * x = integer 4,lrdiv,0)
	by Forward lrdiv)
 -->
 <div expr="(integer 4 * x = integer 4,lrdiv,0)" class="pedagogic slide" exercise="demo_tuto_comb">
   <!--<p>Variable x is isolated by removing the coefficient 4 with a left and right division by 4.</p>-->
   <p>変数 x は両辺を4で割って係数の4をなくすことで独立する。</p>
 </div>
</div>
<div key="slide_demo_tuto_first_(integer 2 * x + integer 1 = integer 5,lrsub,0)">
 <!-- 	(integer 2 * x + integer 1 = integer 5,lrsub,0)
	by Forward lrsub)
 -->
 <div expr="(integer 2 * x + integer 1 = integer 5,lrsub,0)" class="pedagogic slide" exercise="demo_tuto_first">
  <!--<p>The objective is to <span class="stress">isolate-->
   <!--{type="expr" input="x"}--></span><!-- on the left side, that is to say to obtain, by successive operations, an equality of the form x = ....</p>-->
  <p>目標は左辺の<span class="stress">
    <!--{type="expr" input="x"}-->を独立させる</span>することである。これは、いくつかの操作によって x = ... という形の式を得るということである。</p>
  <!--<p>Start by isolating-->
   <!--{type="expr" input="2*x"}--><!-- by eliminating 1 on the left with left and right subtraction of 1.</p>-->
  <p>まず
   <!--{type="expr" input="2*x"}-->を両辺から1を引いて左辺の1を消去することから始める。</p>
 </div>
</div>
<div key="slide_demo_tuto_first_(integer 2 * x = integer 4,lrdiv,0)">
 <!-- 	(integer 2 * x = integer 4,lrdiv,0)
	by Forward lrdiv)
 -->
 <div expr="(integer 2 * x = integer 4,lrdiv,0)" class="pedagogic slide" exercise="demo_tuto_first">
  <!--<p> Isolate-->
  <!--{type="expr" input="x"}--><!-- by eliminating 2 on left right sides with a division by 2 (trivially diffreemnt from 0). </p>-->
  <p>両辺を2で割り左辺の2を消去することで
   <!--{type="expr" input="x"}--> を独立させる。</p>
 </div>
</div>
<div key="slide_demo_tuto_neq_(integer 2 * x <> integer 4,lrsub_neq,0)">
 <!-- 	(integer 2 * x <> integer 4,lrsub_neq,0)
	by Forward lrsub_neq)
 -->
 <div expr="(integer 2 * x <> integer 4,lrsub_neq,0)" class="pedagogic slide" exercise="demo_tuto_neq">
  <!--<p>Subtract 4 on left and right sides of-->
   <!--{type="tag" input="s2"}--><!-- . </p>-->
  <p>4を
   <!--{type="tag" input="s2"}-->の両辺から引く。</p>
 </div>
</div>
<div key="slide_demo_tuto_neq_(x <> integer 2,lrmul_neq,0)">
 <!-- 	(x <> integer 2,lrmul_neq,0)
	by Forward lrmul_neq)
 -->
 <div expr="(x <> integer 2,lrmul_neq,0)" class="pedagogic slide" exercise="demo_tuto_neq">
  <!--<p>The objective is to get the left member of-->
   <!--{type="tag" input="s1"}--><!-- with the left and right operations.</p>-->
  <p>目標は
   <!--{type="tag" input="s1"}--> の左辺の要素を得ることである。</p>
  <!--<p> Multiply by 2 on left and right sides of-->
   <!--{type="tag" input="s1"}--><!-- .</p>-->
  <p>2を
   <!--{type="tag" input="s1"}--> の両辺にかける。</p>
 </div>
</div>
<div key="slide_demo_tuto_rel_(integer 3 = x + integer 3,lrsub,0)">
 <!-- 	(integer 3 = x + integer 3,lrsub,0)
	by Forward lrsub)
 -->
 <div expr="(integer 3 = x + integer 3,lrsub,0)" class="pedagogic slide" exercise="demo_tuto_rel">
  <!--<p>Subtract 3 on the left and right sides of-->
   <!--{type="tag" input="s4"}--><!-- .</p>-->
  <p>3を
   <!--{type="tag" input="s4"}--> の両辺から引く。</p>
 </div>
</div>
<div key="slide_demo_tuto_rel_(x + integer 1 = y,lradd,0)">
 <!-- 	(x + integer 1 = y,lradd,0)
	by Forward lradd)
 -->
 <div expr="(x + integer 1 = y,lradd,0)" class="pedagogic slide" exercise="demo_tuto_rel">
  <!--<p>The objective is to isolate x by eliminating y+2 by transitivity. Start by forming y+2 on the right hand side of-->
   <!--{type="tag" input="s0"}--><!--, by adding 2 on the left and right side.</p>-->
  <p>目標は推移律から y+2 を消去して x を独立させることである。まず両辺に2を足し、y+2 を
   <!--{type="tag" input="s0"}--> の右辺に作る。</p>
 </div>
</div>
<div key="slide_demo_tuto_rel_(x + integer 3 = y + integer 2,eq_trans,1)">
 <!-- 	(x + integer 3 = y + integer 2,eq_trans,1)
	by Forward eq_trans)
 -->
 <div expr="(x + integer 3 = y + integer 2,eq_trans,1)" class="pedagogic slide" exercise="demo_tuto_rel">
   <!--<p>Eliminate y+2 by transitivity.</p>-->
   <p>推移律により y+2 を消去する。</p>
 </div>
</div>
<div key="slide_demo_tuto_rel_(zero = x,eq_symmetry,0)">
 <!-- 	(zero = x,eq_symmetry,0)
	by Forward eq_symmetry)
 -->
 <div expr="(zero = x,eq_symmetry,0)" class="pedagogic slide" exercise="demo_tuto_rel">
 </div>
</div>
<div key="slide_logic_connector_tuto_01_(and A B)">
 <!-- 	(and A B)
	by Backward (conj)
 -->
 <div expr="(and A B)" class="pedagogic slide" exercise="logic_connector_tuto_01">
 </div>
</div>
<div key="slide_logic_connector_tuto_02_(and A B,elim_conj_left,0)">
 <!--   (and A B,elim_conj_left,0)
  by Forward elim_conj_left)
 -->
 <div class="pedagogic slide" expr="(and A B,elim_conj_left,0)" exercise="logic_connector_tuto_02">
 </div>
</div>
<div key="slide_logic_connector_tuto_02_(and A B,elim_conj_right,0)">
 <!--   (and A B,elim_conj_right,0)
  by Forward elim_conj_right)
 -->
 <div class="pedagogic slide" expr="(and A B,elim_conj_right,0)" exercise="logic_connector_tuto_02">
 </div>
</div>
<div key="slide_logic_connector_tuto_02_(and B A)">
 <!--   (and B A)
  by Backward (conj)
 -->
 <div class="pedagogic slide" expr="(and B A)" exercise="logic_connector_tuto_02">
  <!--<p>-->
   <!--<span class="light-bulb">ń</span>--><!-- As in the previous example, we justify conjunction-->
   <!--{type="tag" input="s1"}--><!-- by invoking <span class="buttontheo">conjunction by</span> rule. </p>-->
  <p>
   <!--<span class="light-bulb">ń</span>-->直前の例のように、論理積
   <!--{type="tag" input="s1"}--> を<span class="buttontheo">conjunction by</span>規則によって示す。</p>
 </div>
</div>
<div key="slide_logic_connector_tuto_03_(or A B)">
 <!--   (or A B)
  by Backward (intro_or_right)
 -->
 <div class="pedagogic slide" expr="(or A B)" exercise="logic_connector_tuto_03">
  <!--<p>-->
   <!--<span class="light-bulb">ń</span>--><!-- The choice between A and B to prove-->
   <!--{type="tag" input="s1"}--><!-- <span class="buttontheo">by disjunction</span> is simple, because statement B is provided as an assumption-->
   <!--{type="tag" input="s0"}--><!-- . </p>-->
  <p>
   <!--<span class="light-bulb">ń</span>-->
   <!--{type="tag" input="s1"}--> (<span class="buttontheo">by disjunction</span>)を示すための A か B の選択は、B が仮定
   <!--{type="tag" input="s0"}--> として与えられているため単純である。</p>
 </div>
</div>
<div key="slide_logic_connector_tuto_04_(case P (or Q P))">
 <!--   (case P (or Q P))
  by Section
 -->
 <div class="pedagogic slide" expr="(case P (or Q P))" exercise="logic_connector_tuto_04">
  <!--<p>-->
  <!--<span class="light-bulb">ń</span>--><!--To Prove Q ∨ P if <span class="stress">P is true</span>, we need to open a <span class="stress">logical scope</span> with the --><!--{type="button_section"}--><!-- button. In this scope, P is a hypothesis and Q ∨ P is the conclusion, . </p>-->
  <p>
   <!--<span class="light-bulb">ń</span>--><span class="stress">P が真</span>ならば Q ∨ P であることを示すために、<span class="stress">論理スコープ</span>を <!--{type="button_section"}--> ボタンによって開かなければいけない。このスコープでは、P は仮定であり Q ∨ P は結論である。 </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_04_(case P (or Q P),or Q P)">
 <!--   (case P (or Q P),or Q P)
  by Backward (intro_or_right)
 -->
 <div class="pedagogic slide" expr="(case P (or Q P),or Q P)" exercise="logic_connector_tuto_04">
  <!--<p>-->
   <!--<span class="light-bulb">ń</span>--><!-- In this scope, the situation is the same as in the previous exercise. The proof of the disjunction-->
   <!--{type="tag" input="s2_1"}--><!-- is by choosing P, which is true by hypothesis-->
   <!--{type="tag" input="s2_0"}--><!-- . </p>-->
  <p>
   <!--<span class="light-bulb">ń</span>-->このスコープでは、状況は直前の演習問題と同じである。論理和
   <!--{type="tag" input="s2_1"}--> の証明は、仮定
   <!--{type="tag" input="s2_0"}--> により真であることが分かっている P を選ぶことで得られる。 </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_04_(case Q (or Q P))">
 <!--   (case Q (or Q P))
  by Section
 -->
 <div class="pedagogic slide" expr="(case Q (or Q P))" exercise="logic_connector_tuto_04">
  <!--<p>-->
  <!--<span class="light-bulb">ń</span>--><!--To Prove Q ∨ P if <span class="stress">Q is true</span>, we need to open a <span class="stress">logical scope</span> with the --><!--{type="button_section"}--><!-- button. In this scope, Q is a hypothesis and Q ∨ P is the conclusion, . </p>-->
  <p>
   <!--<span class="light-bulb">ń</span>--><span class="stress">Q が真</span>ならば Q ∨ P であることを示すために、<span class="stress">論理スコープ</span>を <!--{type="button_section"}--> ボタンによって開かなければいけない。このスコープでは、Q は仮定でありQ ∨ P は結論である。 </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_04_(case Q (or Q P),or Q P)">
 <!--   (case Q (or Q P),or Q P)
  by Backward (intro_or_left)
 -->
 <div class="pedagogic slide" expr="(case Q (or Q P),or Q P)" exercise="logic_connector_tuto_04">
  <!--<p>-->
   <!--<span class="light-bulb">ń</span>--><!-- In this scope, the situation is the same as in the previous exercise. The proof of the disjunction-->
   <!--{type="tag" input="s3_1"}--><!-- is by choosing P, which is true by hypothesis-->
   <!--{type="tag" input="s3_0"}--><!-- . </p>-->
  <p>
   <!--<span class="light-bulb">ń</span>--> このスコープでは、状況は直前の演習問題と同じである。論理和
   <!--{type="tag" input="s3_1"}-->の証明は、仮定
   <!--{type="tag" input="s3_0"}--> により真であることが分かっている P を選ぶことで得られる。 </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_04_(or Q P)">
 <!--   (or Q P)
  by Backward (case_base)
 -->
 <div class="pedagogic slide" expr="(or Q P)" exercise="logic_connector_tuto_04">
  <!--<p>-->
   <!--<span class="light-bulb">ń</span>--><!-- The reasoning by <span class="buttontheo">disjunction of cases</span> is available to justify any statement when a disjunction is available. </p>-->
  <p>
   <!--<span class="light-bulb">ń</span>--> <span class="buttontheo">disjunction of cases</span> による推論は、論理和が利用できるとき任意のステートメントを示すために利用できる。</p>
  <!--<p> It is shown that-->
   <!--{type="tag" input="s1"}--><!-- by using the disjunction-->
   <!--{type="tag" input="s0"}--><!-- by disjunction of cases. </p>-->
  <p>論理和
   <!--{type="tag" input="s1"}--> を場合分け
   <!--{type="tag" input="s0"}--> を使うことによって示される。 </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_06_(A -> (B -> and A B))">
 <!--   (A -> (B -> and A B))
  by Section
 -->
 <div class="pedagogic slide" expr="(A -> (B -> and A B))" exercise="logic_connector_tuto_06">
  <!--<p>-->
   <!--<span class="light-bulb">ń</span>--><!-- button-->
   <!--{type="button_section"}--><!-- opens the logical scope with assumption A and conclusion-->
   <!--{type="prop" input="(B -> (and A B))"}--><!--. </p>-->
  <p>
   <!--<span class="light-bulb">ń</span>--> ボタンは
   <!--{type="button_section"}--> 仮定 A と結論
   <!--{type="prop" input="(B -> (and A B))"}--> の論理スコープを開く。 </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_06_(A -> (B -> and A B),B -> and A B)">
 <!--   (A -> (B -> and A B),B -> and A B)
  by Section
 -->
 <div class="pedagogic slide" expr="(A -> (B -> and A B),B -> and A B)" exercise="logic_connector_tuto_06">
  <!--<p>-->
   <!--<span class="light-bulb">ń</span>--><!-- Again button-->
   <!--{type="button_section"}--><!-- creates the logical scope with A and B assumptions and "A ∧ B" in conclusion. </p>-->
  <p>
   <!--<span class="light-bulb">ń</span>--> ボタン
   <!--{type="button_section"}--> は仮定 A と B、結論 "A ∧ B" の論理スコープを作る。</p>
 </div>
</div>
<div key="slide_logic_connector_tuto_06_(B -> and A B,A -> (B -> and A B),and A B)">
 <!--   (B -> and A B,A -> (B -> and A B),and A B)
  by Backward (conj)
 -->
 <div class="pedagogic slide" expr="(B -> and A B,A -> (B -> and A B),and A B)" exercise="logic_connector_tuto_06">
   <!--<p>-->
   <!--<span class="light-bulb">ń</span>--><!-- We find ourselves in the situation of the first exercise of this tutorial (to prove a conjunction). We prove-->
   <!--{type="tag" input="s3_1"}--><!-- by conjunction with assumptions-->
   <!--{type="tag" input="s2_0"}--><!-- and-->
   <!--{type="tag" input="s3_0"}--><!-- . </p>-->
  <p>
   <!--<span class="light-bulb">ń</span>-->論理積を証明するため、このチュートリアルの最初の演習問題の状況にいることが分かる。
   <!--{type="tag" input="s3_1"}--> を論理積によって仮定
   <!--{type="tag" input="s2_0"}--> と
   <!--{type="tag" input="s3_0"}--> によって示す。</p>
 </div>
</div>
<div key="slide_logic_connector_tuto_07_(A -> B,modus_ponens,0)">
 <!-- 	(A -> B,modus_ponens,0)
	by Forward modus_ponens)
 -->
 <div expr="(A -> B,modus_ponens,0)" class="pedagogic slide" exercise="logic_connector_tuto_07">
  <!--<p>-->
  <!--<span class="light-bulb">ń</span>--><!-- We deduce B from implication-->
   <!--{type="tag" input="s0"}--><!-- if A is true. </p>-->
  <p>
   <!--<span class="light-bulb">ń</span>--> A が真のとき、B は含意
   <!--{type="tag" input="s0"}--> から導かれる。</p>
 </div>
</div>
<div key="slide_logic_connector_tuto_085_(A -> False,modus_ponens,0)">
 <!--   (A -> False,modus_ponens,0)
  by Forward modus_ponens)
 -->
 <div class="pedagogic slide" expr="(A -> False,modus_ponens,0)" exercise="logic_connector_tuto_085">
  <!--<p>-->
   <!--<span class="light-bulb">ń</span>--><!-- <span class="stress">Modus ponens</span> allows us to deduce a contradiction-->
   <!--{type="tag" input="s3"}--><!-- . </p>-->
  <p>
   <!--<span class="light-bulb">ń</span>--> <span class="stress">モーダス・ポネンス</span>は矛盾
   <!--{type="tag" input="s3"}--> を導くのに利用できる。</p>
 </div>
</div>
<div key="slide_logic_connector_tuto_085_(~ A,elim_negation,0)">
 <!--   (~ A,elim_negation,0)
  by Forward elim_negation)
 -->
 <div class="pedagogic slide" expr="(~ A,elim_negation,0)" exercise="logic_connector_tuto_085">
  <!--<p>-->
   <!--<span class="light-bulb">ń</span>--><!-- Translate negation-->
   <!--{type="tag" input="s0"}--><!-- into an implication of the false, by definition of negation. </p>-->
  <p>
   <!--<span class="light-bulb">ń</span>--> 否定
   <!--{type="tag" input="s0"}--> を否定の定義より偽への含有として書き換える。</p>
 </div>
</div>
<div key="slide_logic_connector_tuto_08_(A -> False)">
 <!--   (A -> False)
  by Section
 -->
 <div class="pedagogic slide" expr="(A -> False)" exercise="logic_connector_tuto_08">
  <!--<p>-->
   <!--<span class="light-bulb">ń</span>--><!-- The --><!--{type="button_section"}--><!-- button allows to create a scope in which A is a hypothesis.</p>-->
  <p>
   <!--<span class="light-bulb">ń</span>--><!--{type="button_section"}--> ボタンは A が仮定であるスコープを作ることができる。</p>
 </div>
</div>
<div key="slide_logic_connector_tuto_08_(A -> False,B)">
 <!--   (A -> False,B)
  by Backward (modus_ponens)
 -->
 <div class="pedagogic slide" expr="(A -> False,B)" exercise="logic_connector_tuto_08">
  <!--<p>-->
   <!--<span class="light-bulb">ń</span>--><!-- <span class="stress">Modus ponens</span> allows to justify the assumption B by using A-->
   <!--{type="tag" input="s0"}--><!-- . </p>-->
  <p>
   <!--<span class="light-bulb">ń</span>--> <span class="stress">モーダス・ポネンス</span>は仮定 B を A 
   <!--{type="tag" input="s0"}--> を使うことによって示す。 </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_08_(B -> False,modus_ponens,0)">
 <!-- 	(B -> False,modus_ponens,0)
	by Forward modus_ponens)
 -->
 <div expr="(B -> False,modus_ponens,0)" class="pedagogic slide" exercise="logic_connector_tuto_08">
  <!--<p>-->
   <!--<span class="light-bulb">ń</span>--><!-- <span class="stress">Modus ponens</span> allows to justify the false assumption by B using-->
   <!--{type="tag" input="s2"}--><!-- . </p>-->
  <p>
   <!--<span class="light-bulb">ń</span>--> <span class="stress">モーダス・ポネンス</span>は偽を
   <!--{type="tag" input="s2"}--> を使って B により示す。 </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_08_(~ A)">
 <!--   (~ A)
  by Backward (elim_negation)
 -->
 <div class="pedagogic slide" expr="(~ A)" exercise="logic_connector_tuto_08">
  <!--<p>-->
   <!--<span class="light-bulb">ń</span>--><!-- Translate negation-->
   <!--{type="tag" input="s0"}--><!-- into an implication of the false, by definition of negation. </p>-->
  <p>
   <!--<span class="light-bulb">ń</span>--> 否定
   <!--{type="tag" input="s0"}--> を定義により偽への含意に書き換える。</p>
 </div>
</div>
<div key="slide_logic_connector_tuto_09_(False,falseall,0)">
 <!-- 	(False,falseall,0)
	by Forward falseall)
 -->
 <div expr="(False,falseall,0)" class="pedagogic slide" exercise="logic_connector_tuto_09">
  <!--<p>-->
   <!--<span class="light-bulb">ń</span>--><!-- Exercise is solved with <span class="buttontheo">Ex Falso Quodlibet</span>. </p>-->
  <p>
   <!--<span class="light-bulb">ń</span>--> 演習問題は<span class="buttontheo">Ex Falso Quodlibet</span>によって証明される。</p>
 </div>
</div>
<div key="slide_logic_connector_tuto_09_(~ A,intro_false,0)">
 <!-- 	(~ A,intro_false,0)
	by Forward intro_false)
 -->
 <div expr="(~ A,intro_false,0)" class="pedagogic slide" exercise="logic_connector_tuto_09">
  <!--<p>-->
   <!--<span class="light-bulb">ń</span>--><!-- The obvious contradiction between-->
   <!--{type="tag" input="s0"}--><!-- and-->
   <!--{type="tag" input="s2"}--><!-- invites to use the axiom <span class="buttontheo">non-contradiction</span>, proved in the last exercise.</p>-->
  <p>
   <!--<span class="light-bulb">ń</span>-->
   <!--{type="tag" input="s0"}--> と
   <!--{type="tag" input="s2"}--> の間の明白な矛盾は、最後の演習問題で示される公理 <span class="buttontheo">non-contradiction</span>を使うことを許す。</p>
 </div>
</div>

<!-- ## Haochen -->

<div key="slide_logic_connector_tuto_10_(case (~ A) (or A B))">
 <!--   (case (~ A) (or A B))
  by Section
 -->
 <div class="pedagogic slide" expr="(case (~ A) (or A B))" exercise="logic_connector_tuto_10">
  <!-- <p> -->
  <!--  <\!--<span class="light-bulb">ń</span>-\-> When ¬A is true, we prove "A ∨ B" by selecting B, obtained by deduction from obtained ¬A using -->
  <!--  <\!--{type="tag" input="s0"}-\-> . </p> -->
  <p>
   <!--<span class="light-bulb">ń</span>--> ¬Aが真であるとき、Bを選ぶことで"A ∨ B"を証明する。これは¬Aより<!--{type="tag" input="s0"}-->で演繹することで得られる。 </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_10_(case (~ A) (or A B),or A B)">
 <!--   (case (~ A) (or A B),or A B)
  by Backward (intro_or_right)
 -->
 <div class="pedagogic slide" expr="(case (~ A) (or A B),or A B)" exercise="logic_connector_tuto_10">
  <!-- <p> -->
  <!--  <\!--<span class="light-bulb">ń</span>-\-> When ¬A is true, we prove "A ∨ B" by selecting B, obtained by deduction from ¬A using -->
  <!--  <\!--{type="tag" input="s0"}-\-> . </p> -->
  <!-- <p> -->
   <!--<span class="light-bulb">ń</span>--> ¬Aが真であるとき、Bを選ぶことで"A ∨ B"を証明する。これは¬Aより<!--{type="tag" input="s0"}-->で演繹することで得られる。 </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_10_(case A (or A B))">
 <!--   (case A (or A B))
  by Section
 -->
 <div class="pedagogic slide" expr="(case A (or A B))" exercise="logic_connector_tuto_10">
  <!-- <p> -->
  <!--  <\!--<span class="light-bulb">ń</span>-\-> If A is true, we prove "A ∨ B" by choosing A. </p> -->
  <p>
   <!--<span class="light-bulb">ń</span>--> Aが真であるとき、Aを選ぶことで"A ∨ B"を証明する。 </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_10_(case A (or A B),or A B)">
 <!--   (case A (or A B),or A B)
  by Backward (intro_or_left)
 -->
 <div class="pedagogic slide" expr="(case A (or A B),or A B)" exercise="logic_connector_tuto_10">
  <!-- <p> -->
  <!--  <\!--<span class="light-bulb">ń</span>-\-> If A is true, we prove "A ∨ B" by choosing A. </p> -->
  <p>
   <!--<span class="light-bulb">ń</span>--> Aが真であるとき、Aを選ぶことで"A ∨ B"を証明する。 </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_10_(or A B)">
 <!--   (or A B)
  by Backward (case_base_binary)
 -->
 <div class="pedagogic slide" expr="(or A B)" exercise="logic_connector_tuto_10">
  <!-- <p> -->
  <!--  <\!--<span class="light-bulb">ń</span>-\-> The law of <span class="buttontheo">the excluded middle</span> allows to consider two cases to prove -->
  <!--  <\!--{type="tag" input="s1"}-\-> : if A is true and when ¬ A is true. </p> -->
  <p>
   <!--<span class="light-bulb">ń</span>--> <span class="buttontheo">排中律</span>を用いれば<!--{type="tag" input="s1"}-->を証明するためにAが真のときと¬ Aが真でときそれぞれ<!--{type="tag" input="s1"}-->を証明すればよい。 </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_10_(~ A -> B,modus_ponens,0)">
 <!--   (~ A -> B,modus_ponens,0)
  by Forward modus_ponens)
 -->
 <div class="pedagogic slide" expr="(~ A -> B,modus_ponens,0)" exercise="logic_connector_tuto_10">
  <p>
   <!--<span class="light-bulb">ń</span>--> Implication
   <!-- <\!--{type="tag" input="s0"}-\-> is available to justify B as <span class="buttontheo">local theorem.</span> It is noted that this justification acts here as modus ponens. The only difference is that the notion of local theorem extends the modus ponens to expressions containing quantifiers "for every ..." (see next chapter). </p> -->
  <p>
   <!--<span class="light-bulb">ń</span>--> <!--{type="tag" input="s0"}-->が<span class="buttontheo">ローカル定理</span>としてBの証明に使える。注意としてこの証明手法はモーダスポネンスとおおよそ同じ機能を果しているが、ローカル定理は全称量化子に対しても使える(詳細は次章にある)。 </p>
 </div>
</div>
<div key="slide_rew_tuto_develop_(((x ^ integer 2 + integer 3 * x) + integer 2) + integer 3 * x = x ^ integer 2,lrsub,0)">
 <!-- 	(((x ^ integer 2 + integer 3 * x) + integer 2) + integer 3 * x = x ^ integer 2,lrsub,0)
	by Forward lrsub)
 -->
 <div expr="(((x ^ integer 2 + integer 3 * x) + integer 2) + integer 3 * x = x ^ integer 2,lrsub,0)" class="pedagogic slide" exercise="rew_tuto_develop">
  <!-- <p>Note that the term -->
  <!--  <\!--{type="expr" input="pow x 2"}-\-> is present on the left and right sides of equality.</p> -->
  <!-- <p>We can therefore eliminate it by left and right subtraction.</p> -->
  <p><!--{type="expr" input="pow x 2"}-->が等号の左右両辺に出現しているので、</p>
  <p>消すことができる(等号左右両辺に同時にこれを引けばよい)。</p>
 </div>
</div>
<div key="slide_rew_tuto_develop_((x + integer 1) * (x + integer 2) + integer 3 * x = x ^ integer 2,expand,0)">
 <!-- 	((x + integer 1) * (x + integer 2) + integer 3 * x = x ^ integer 2,expand,0)
	by Forward select of select ((x + integer 1) * (x + integer 2)) + integer 3 * x = x ^ integer 2 (expand)
 -->
 <div expr="((x + integer 1) * (x + integer 2) + integer 3 * x = x ^ integer 2,expand,0)" class="pedagogic slide" exercise="rew_tuto_develop">
  <!-- <p>The goal is to isolate x on the left.</p> -->
  <!-- <p>Expand the products of factors to obtain a polynomial form.</p> -->
  <p>目標は左辺のxを分離することである。</p>
  <p>式を展開すればxに関する多項式が得られる。</p>
 </div>
</div>
<div key="slide_rew_tuto_develop_(integer 6 * x + integer 2 = zero,lrsub,0)">
 <!-- 	(integer 6 * x + integer 2 = zero,lrsub,0)
	by Forward lrsub)
 -->
 <div expr="(integer 6 * x + integer 2 = zero,lrsub,0)" class="pedagogic slide" exercise="rew_tuto_develop">
  <!-- <p>The situation is now well known : the objective is to isolate, on the left side, the variable of a polynomial form of degree 1.</p> -->
  <!-- <p>Left and right operations allow to conclude.</p> -->
  <p>ここまで来れば状況が明白になっている。つまり左辺の式にある次数が1の変数を分離すればよい。</p>
  <p>そうすれば方程式の両辺に足したり引いたりすれば完結できる。</p>
 </div>
</div>
<div key="slide_rew_tuto_develop_(integer 6 * x = - integer 2,lrdiv,0)">
 <!-- 	(integer 6 * x = - integer 2,lrdiv,0)
	by Forward lrdiv)
 -->
 <div expr="(integer 6 * x = - integer 2,lrdiv,0)" class="pedagogic slide" exercise="rew_tuto_develop">
  <!-- <p>Conclude by division by 6 on left and right sides.</p> -->
  <p>両辺6で割れば終わる。</p>
 </div>
</div>
<div key="slide_rew_tuto_fact1_(x <> zero,lrmul_neq,0)">
 <!-- 	(x <> zero,lrmul_neq,0)
	by Forward lrmul_neq)
 -->
 <div expr="(x <> zero,lrmul_neq,0)" class="pedagogic slide" exercise="rew_tuto_fact1">
  <!-- <p>The objective is to factorize by -->
  <!--  <\!--{type="expr" input="pow x 2"}-\-> .</p> -->
  <p>目標は<!--{type="expr" input="pow x 2"}-->を因数分解することである。</p>
 </div>
</div>
<div key="slide_rew_tuto_fact1_(x ^ integer 2 + integer 1 = zero,gen_factorize,0)">
 <!-- 	(x ^ integer 2 + integer 1 = zero,gen_factorize,0)
	by Forward select of select (x ^ integer 2 + integer 1) = zero (gen_factorize)
 -->
 <div expr="(x ^ integer 2 + integer 1 = zero,gen_factorize,0)" class="pedagogic slide" exercise="rew_tuto_fact1">
 </div>
</div>
<div key="slide_rew_tuto_group_(E = (x + integer 1) * (integer 2 * x + (integer 3 + (y - integer 1))),expand,0)">
 <!-- 	(E = (x + integer 1) * (integer 2 * x + (integer 3 + (y - integer 1))),expand,0)
	by Forward select of E =select  (UIGroup (x + integer 1) *   (UIGroup (integer 2 * x + integer 3) + UIGroup (y - integer 1))) (expand)
 -->
 <div expr="(E = (x + integer 1) * (integer 2 * x + (integer 3 + (y - integer 1))),expand,0)" class="pedagogic slide" exercise="rew_tuto_group">
  <!-- <p>The objective is to expand the right hand side of -->
  <!--  <\!--{type="tag" input="s0"}-\-> and to keep intact the terms:</p> -->
  <!-- <p>The objective is to expand the right hand side of -->
  <!--  <\!--{type="tag" input="s0"}-\-> and to keep intact the terms:</p> -->
  <p>目標はこの項をばらさずに右辺を展開することである<!--{type="tag" input="s0"}-->：</p>
  <ul>
   <li>
    <!--{type="expr" input="plus x 1"}--></li>
   <li>
    <!--{type="expr" input="plus (mult 2 x) 3"}--></li>
   <li>
    <!--{type="expr" input="minus y 1"}--></li>
  </ul>
  <!-- <p>The solution is to specify three groups. You create a group by selecting a term and <span class="stress">pressing the <span style="font-family:'Courier New';font-weight:bold;padding-left:8px;padding-right:8px">g</span> button.</span></p> -->
  <!-- <p>Once the three groups created, develop in the usual manner.</p> -->
  <p>解決法は3つのグループを作ることである。項を選んで<span class="stress"><span style="font-family:'Courier New';font-weight:bold;padding-left:8px;padding-right:8px">g</span>を押せば</span>グループが作れる。</p>
  <p>グループが作れたら通常通り進めばよい。</p>
 </div>
</div>
<div key="slide_rew_tuto_idrem1_((x ^ integer 2 + integer 2 * x) + integer 1 = integer 4,polysquare,0)">
 <!-- 	((x ^ integer 2 + integer 2 * x) + integer 1 = integer 4,polysquare,0)
	by Forward select of select ((x ^ integer 2 + integer 2 * x) + integer 1) = integer 4 (polysquare)
 -->
 <div expr="((x ^ integer 2 + integer 2 * x) + integer 1 = integer 4,polysquare,0)" class="pedagogic slide" exercise="rew_tuto_idrem1">
  <!-- <p>Conclude by factorising the left hand side with the remarkable formula of polynomial square.</p> -->
  <p>[!!]remarkable formula of polynomial squareで左辺を因数分解して完結すればよい。</p>
 </div>
</div>
<div key="slide_rew_tuto_idrem1_(x ^ integer 2 + (integer 2 * x - integer 3) = zero,lradd,0)">
 <!-- 	(x ^ integer 2 + (integer 2 * x - integer 3) = zero,lradd,0)
	by Forward lradd)
 -->
 <div expr="(x ^ integer 2 + (integer 2 * x - integer 3) = zero,lradd,0)" class="pedagogic slide" exercise="rew_tuto_idrem1">
  <!-- <p>The objective is to factorize on the left side.</p> -->
  <!-- <p>Note that the left-hand side term is almost the development of -->
  <!--  <\!--{type="expr" input="pow (x+1) 2"}-\-> , according to the remarkable formula.</p> -->
  <!-- <p>Therefore form the development of the perfect square -->
  <!--  <\!--{type="expr" input="((pow x 2)+(2*x))+1"}-\-> by adding 4 left and right.</p> -->
  <p>目標は左辺を因数分解することである。</p>
  <p>左辺が[!!]remarkable formulaによれば<!--{type="expr" input="pow (x+1) 2"}-->の[??]展開(development)とほぼ同じであることに注目せよ。</p>
  <p>なので両辺に4を足し、[??]完全平方<!--{type="expr" input="((pow x 2)+(2*x))+1"}-->の形を作ればよい。</p>
 </div>
</div>
<div key="slide_rew_tuto_misc1_((x + integer 3) * ((x + integer 2) * (x + integer 1)) = zero,commutativity,0)">
 <!-- 	((x + integer 3) * ((x + integer 2) * (x + integer 1)) = zero,commutativity,0)
	by Forward select of select (((x + integer 3) * (x + integer 2)) * (x + integer 1)) = zero (commutativity)
 -->
 <div expr="((x + integer 3) * ((x + integer 2) * (x + integer 1)) = zero,commutativity,0)" class="pedagogic slide" exercise="rew_tuto_misc1">
  <!-- <p>Select the terms to reorder by commutative operation.</p> -->
  <!-- <p>Rearrange the term directly in the diagnostics window by dragging and dropping terms of the product.</p> -->
  <p>順序を変えたい項を選び、[!!]diagnostics windowのなかで項をマウスでドラッグすれば順序が変えられる。</p>
 </div>
</div>
<div key="slide_rew_tuto_misc2_(x = integer 2 * (x + integer 1),rewriting,0)">
 <!-- 	(x = integer 2 * (x + integer 1),rewriting,0)
	by Forward select of x = integer 2 * select (x + integer 1) (rewriting)
 -->
 <div expr="(x = integer 2 * (x + integer 1),rewriting,0)" class="pedagogic slide" exercise="rew_tuto_misc2">
  <p>The goal is to isolate x on the left. Note in assumption
   <!--{type="tag" input="s2"}--> that one factor on the right hand side right
   <!--{type="expr" input="x+1"}--> , is equal to 4 under the assumption
   <!--{type="tag" input="s0"}--> .</p>
  <p>So just replace
   <!--{type="expr" input="x+1"}--> by 4 using
   <!--{type="tag" input="s0"}--> as justification.</p>
  <p>Start by selecting <span class="stress"> with the mouse</span> the term
   <!--{type="expr" input="x+1"}--> in
   <!--{type="tag" input="s2"}--> .</p>
  <p>目標は左辺のxを分離することである。前提<!--{type="tag" input="s2"}-->では右辺の項<!--{type="expr" input="x+1"}-->が前提<!--{type="tag" input="s0"}-->のもと4になっていることに注意せよ。</p>
  <p>なので<!--{type="expr" input="x+1"}-->を4で書き換えればよい。証明として<!--{type="tag" input="s0"}-->が使える。</p>
  <p>それをするためにマウスで<!--{type="tag" input="s2"}-->の中の項<!--{type="expr" input="x+1"}-->を選択すればよい。</p>
 </div>
</div>
<div key="slide_rew_tuto_op_((x + integer 1) / ((y + integer 2) - integer 2) = zero,rewriting,0)">
 <!-- 	((x + integer 1) / ((y + integer 2) - integer 2) = zero,rewriting,0)
	by Forward select of (x + integer 1) / (select (y + integer 2) - integer 2) = zero (rewriting)
 -->
 <div expr="((x + integer 1) / ((y + integer 2) - integer 2) = zero,rewriting,0)" class="pedagogic slide" exercise="rew_tuto_op">
  <!-- <p>Conclude by replacing y+2 in <\!--{type="tag" input="s3"}-\-> by x by <\!--{type="tag" input="s0"}-\->.</p> -->
  <p><!--{type="tag" input="s0"}-->より<!--{type="tag" input="s3"}-->の中のy+2をxで書き換えれば完結できる。</p>
 </div>
</div>
<div key="slide_rew_tuto_op_((x + integer 1) / y = zero,addsub,0)">
 <!-- 	((x + integer 1) / y = zero,addsub,0)
	by Forward select of (x + integer 1) / select y = zero (addsub)
 -->
 <div expr="((x + integer 1) / y = zero,addsub,0)" class="pedagogic slide" exercise="rew_tuto_op">
  <!-- <p>The objective is to get statement -->
  <!--  <\!--{type="tag" input="s1"}-\-> by transforming y at the denominator of -->
  <!--  <\!--{type="tag" input="s2"}-\-> into -->
  <!--  <\!--{type="expr" input="x-2"}-\-> .</p> -->
  <!-- <p>Rewrite -->
  <!--  <\!--{type="expr" input="y"}-\-> into -->
  <!--  <\!--{type="expr" input="y-2+2"}-\-> , term in which -->
  <!--  <\!--{type="expr" input="y-2"}-\-> is then replaced by -->
  <!--  <\!--{type="expr" input="x"}-\-> according to -->
  <!--  <\!--{type="tag" input="s0"}-\->.</p> -->
  <p>目標は<!--{type="tag" input="s2"}-->の分母の中のyを<!--{type="expr" input="x-2"}-->に変形して<!--{type="tag" input="s1"}-->を得ることである。</p>
  <p><!--{type="expr" input="y"}-->を<!--{type="expr" input="y-2+2"}-->に書き換えればよい。そうすれば<!--{type="tag" input="s0"}-->より<!--{type="expr" input="y-2"}-->が<!--{type="expr" input="x"}-->に書き換えられる。</p>
 </div>
</div>
<div key="slide_rew_tuto_simpl2_(((x + integer 1) + integer 2 * (x - integer 2)) /((x + integer 1) * (x - integer 2)) = zero,lrmul,0)">
 <!-- 	(((x + integer 1) + integer 2 * (x - integer 2)) /((x + integer 1) * (x - integer 2)) = zero,lrmul,0)
	by Forward lrmul)
 -->
 <div expr="(((x + integer 1) + integer 2 * (x - integer 2)) /((x + integer 1) * (x - integer 2)) = zero,lrmul,0)" class="pedagogic slide" exercise="rew_tuto_simpl2">
 </div>
</div>
<div key="slide_rew_tuto_simpl2_((x + integer 2 * (x - integer 2)) + integer 1 = zero,linearsimpl,0)">
 <!-- 	((x + integer 2 * (x - integer 2)) + integer 1 = zero,linearsimpl,0)
	by Forward select of select ((integer 2 * (x - integer 2) + x) + integer 1) = zero (linearsimpl)
 -->
 <div expr="((x + integer 2 * (x - integer 2)) + integer 1 = zero,linearsimpl,0)" class="pedagogic slide" exercise="rew_tuto_simpl2">
 </div>
</div>
<div key="slide_rew_tuto_simpl2_(integer 2 / (x + integer 1) + integer 1 / (x - integer 2) = zero,reducedenom,0)">
 <!-- 	(integer 2 / (x + integer 1) + integer 1 / (x - integer 2) = zero,reducedenom,0)
	by Forward select of select (integer 2 / (x + integer 1) + integer 1 / (x - integer 2)) = zero (reducedenom)
 -->
 <div expr="(integer 2 / (x + integer 1) + integer 1 / (x - integer 2) = zero,reducedenom,0)" class="pedagogic slide" exercise="rew_tuto_simpl2">
  <!-- <p>The goal is to isolate x on the left.</p> -->
  <!-- <p>Start by reducing polynomial fractions to the same denominator, -->
  <!--  <\!--{type="expr" input="(x+1)*(x-2)"}-\-> .</p> -->
  <p>目標は左辺のxを分離することである。</p>
  <p>先ずは分母を<!--{type="expr" input="(x+1)*(x-2)"}-->に統一すればよい。</p>
 </div>
</div>
<div key="slide_rew_tuto_simpl2_(integer 3 * x - integer 3 = zero,lradd,0)">
 <!-- 	(integer 3 * x - integer 3 = zero,lradd,0)
	by Forward lradd)
 -->
 <div expr="(integer 3 * x - integer 3 = zero,lradd,0)" class="pedagogic slide" exercise="rew_tuto_simpl2">
  <!-- <p>The situation is increasingly simple. Use left and right operations to isolate x.</p> -->
  <p>状況はだんだん簡単になってきた。方程式の変形でxを分離すればよい。</p>
 </div>
</div>
<div key="slide_rew_tuto_simpl2_(integer 3 * x = integer 3,lrdiv,0)">
 <!-- 	(integer 3 * x = integer 3,lrdiv,0)
	by Forward lrdiv)
 -->
 <div expr="(integer 3 * x = integer 3,lrdiv,0)" class="pedagogic slide" exercise="rew_tuto_simpl2">
  <!-- <p>Concluded by dividing by 3 on the left and right sides.</p> -->
  <p>両辺を3で割れば完結できる。</p>
 </div>
</div>
<div key="slide_rew_tuto_simpl_(integer 3 * x + integer 4 = integer 10,lrsub,0)">
 <!-- 	(integer 3 * x + integer 4 = integer 10,lrsub,0)
	by Forward lrsub)
 -->
 <div expr="(integer 3 * x + integer 4 = integer 10,lrsub,0)" class="pedagogic slide" exercise="rew_tuto_simpl">
  <!-- <p>The objective of isolation of x is achieved with the left and right operations introduced in the previous chapter.</p> -->
  <!-- <p>Subtract 4 on the left and right sides to isolate -->
  <!--  <\!--{type="expr" input="3*x"}-\-> .</p> -->
  <p>前章で紹介した方程式の変形を使えばxを分離できる。</p>
  <p>左右両辺を4で引いて<!--{type="expr" input="3*x"}-->を分離すばよい。</p>
 </div>
</div>
<div key="slide_rew_tuto_simpl_(integer 3 * x = integer 6,lrdiv,0)">
 <!-- 	(integer 3 * x = integer 6,lrdiv,0)
	by Forward lrdiv)
 -->
 <div expr="(integer 3 * x = integer 6,lrdiv,0)" class="pedagogic slide" exercise="rew_tuto_simpl">
  <!-- <p>Divide by 3 on te left and right sides in order to conclude.</p> -->
  <p>左右両辺を3で割ればよい。</p>
 </div>
</div>
<div key="slide_rew_tuto_simpl_(x + (integer 1 + (integer 2 * x + integer 3)) = integer 10,linearsimpl,0)">
 <!-- 	(x + (integer 1 + (integer 2 * x + integer 3)) = integer 10,linearsimpl,0)
	by Forward select of select (((x + integer 1) + integer 2 * x) + integer 3) = integer 10 (linearsimpl)
 -->
 <div expr="(x + (integer 1 + (integer 2 * x + integer 3)) = integer 10,linearsimpl,0)" class="pedagogic slide" exercise="rew_tuto_simpl">
  <!-- <p>The goal is to isolate x on the left. Note that the left term of assumption -->
  <!--  <\!--{type="tag" input="s0"}-\-> is a sum of first degree polynomial form in x, -->
  <!--  <\!--{type="expr" input="x+1"}-\-> and -->
  <!--  <\!--{type="expr" input="2*x+1"}-\-> .</p> -->
  <!-- <p>Simplify these terms into a polynomial form.</p> -->
  <p>目標は左辺のxを分離することである。前提<!--{type="tag" input="s0"}-->の左辺は一次式<!--{type="expr" input="x+1"}-->と<!--{type="expr" input="2*x+1"}-->の和であることに注意せよ。</p>
  <p>これらの項を多項式に簡約すればよい。</p>
 </div>
</div>
<div key="slide_rew_tuto_varchange_((a - integer 3) ^ integer 2 = zero,rewriting,0)">
 <!-- 	((a - integer 3) ^ integer 2 = zero,rewriting,0)
	by Forward select of (select a - integer 3) ^ integer 2 = zero (rewriting)
 -->
 <div expr="((a - integer 3) ^ integer 2 = zero,rewriting,0)" class="pedagogic slide" exercise="rew_tuto_varchange">
  <!-- <p>Conclude by replacing a by -->
  <!--  <\!--{type="expr" input="pow x 2"}-\-> .</p> -->
  <p>aを<!--{type="expr" input="pow x 2"}-->で書き換えればよい。</p>
 </div>
</div>
<div key="slide_rew_tuto_varchange_((a ^ integer 2 - integer 6 * a) + integer 9 = zero,polysquare,0)">
 <!-- 	((a ^ integer 2 - integer 6 * a) + integer 9 = zero,polysquare,0)
	by Forward select of select ((a ^ integer 2 - integer 6 * a) + integer 9) = zero (polysquare)
 -->
 <div expr="((a ^ integer 2 - integer 6 * a) + integer 9 = zero,polysquare,0)" class="pedagogic slide" exercise="rew_tuto_varchange">
  <!-- <p>On the left hand side is the square of -->
  <!--  <\!--{type="expr" input="a-3"}-\-> .</p> -->
  <p>左辺は<!--{type="expr" input="a-3"}-->の平方になっている。</p>
 </div>
</div>
<div key="slide_rew_tuto_varchange_((x ^ integer 4 - integer 6 * a) + integer 9 = zero,rewriting,1)">
 <!-- 	((x ^ integer 4 - integer 6 * a) + integer 9 = zero,rewriting,1)
	by Forward select of (select (x ^ integer 4) - integer 6 * a) + integer 9 = zero (rewriting)
 -->
 <div expr="((x ^ integer 4 - integer 6 * a) + integer 9 = zero,rewriting,1)" class="pedagogic slide" exercise="rew_tuto_varchange">
  <!-- <p>Replace -->
  <!--  <\!--{type="expr" input="pow x 4"}-\-> by -->
  <!--  <\!--{type="expr" input="pow a 2"}-\-> in -->
  <!--  <\!--{type="expr" input="s3"}-\-> .</p> -->
  <p><!--{type="expr" input="s3"}-->の中の<!--{type="expr" input="pow x 4"}-->を<!--{type="expr" input="pow a 2"}-->で書き換えればよい。</p>
 </div>
</div>
<div key="slide_rew_tuto_varchange_((x ^ integer 4 - integer 6 * x ^ integer 2) + integer 9 = zero,varchange,0)">
 <!-- 	((x ^ integer 4 - integer 6 * x ^ integer 2) + integer 9 = zero,varchange,0)
	by Forward select of (x ^ integer 4 - integer 6 * select (x ^ integer 2)) + integer 9 = zero (varchange)
 -->
 <div expr="((x ^ integer 4 - integer 6 * x ^ integer 2) + integer 9 = zero,varchange,0)" class="pedagogic slide" exercise="rew_tuto_varchange">
  <!-- <p>The objective is to factorize the left-hand side of assumption -->
  <!--  <\!--{type="tag" input="s0"}-\-> .</p> -->
  <!-- <p>At first glance it is just a degree 4 polynomial form, but looking more closely, it is a polynomial form of degree 2 in -->
  <!--  <\!--{type="expr" input="pow x 2"}-\-> .</p> -->
  <!-- <p>Change variable accordingly.</p> -->
  <p>目標は前提<!--{type="tag" input="s0"}-->の左辺を因数分解することである。</p>
  <p>一見にして4次式に見えるが、実際<!--{type="expr" input="pow x 2"}-->の2次しきになっている。</p>
  <p>なので変数変換すればよい。</p>
 </div>
</div>
<div key="slide_rew_tuto_varchange_(a = x ^ integer 2)">
 <!-- 	(a = x ^ integer 2)
	by Backward (replacement)
 -->
 <div expr="(a = x ^ integer 2)" class="pedagogic slide" exercise="rew_tuto_varchange">
 </div>
</div>
<div key="slide_rew_tuto_varchange_(a = x ^ integer 2,app_square,0)">
 <!-- 	(a = x ^ integer 2,app_square,0)
	by Forward app_square)
 -->
 <div expr="(a = x ^ integer 2,app_square,0)" class="pedagogic slide" exercise="rew_tuto_varchange">
  <!-- <p>Definition of a is squareed to get -->
  <!--  <\!--{type="expr" input="pow x 4"}-\-> as a function of a.</p> -->
  <p><!--{type="expr" input="pow x 4"}-->がaの平方と同値であることが分かる。</p>
 </div>
</div>
<div class="toolbox-text custom pedagogic confuse" key="text_Antonym1">
 <!-- <p>If a child is the youngest, then he/she is not the oldest. </p> -->
 <p>もしとある子供が最も年少であれば、この子が最も年長ではない。</p>
</div>
<div class="toolbox-text custom pedagogic confuse" key="text_Antonym2">
 <!-- <p>If a child is the oldest, then he/she is not the youngest. </p> -->
 <p>もしとある子供が最も年長であれば、この子が最も年少ではない。</p>
</div>
<div class="toolbox-text custom pedagogic confuse" key="text_Superlative1">
 <!-- <p>If a child is the youngest, then any other child is not the youngest. </p> -->
 <p>もしとある子供が最も年少であれば、他のどの子も最も年少ではない。</p>
</div>
<div class="toolbox-text custom pedagogic confuse" key="text_Superlative2">
 <!-- <p>If a child is the oldest then any other child is not the oldest. </p> -->
 <p>もしとある子供が最も年長であれば、他のどの子も最も年長ではない。</p>
</div>
<div class="toolbox-text custom pedagogic" key="text_adabsurdium">
 <!-- <p> <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Raisonnement_par_l%27absurde" target="_blank">Reductio ad absurdum</a></span> is -->
 <!-- proves statement A by showing that, if its negation, ¬ A is true, then we get a contradiction: </p> -->
 <!-- <p> Indeed, -->
 <!--  <\!--{type="prop" sci="true" input="~(~A)"}-\-> rewrites into -->
 <!--  <\!--{type="prop" sci="true" input="(~A -> False)"}-\-> by definition of negation. Reduction ad absurdum is thus an elimination rule of double negation. </p> -->
 <p> <span class="exturl"><a href="https://ja.wikipedia.org/wiki/%E8%83%8C%E7%90%86%E6%B3%95" target="_blank">背理法</a></span>は¬Aが真であれば矛盾が生じることを示すことで命題Aを証明する手法である。</p>
 <p>実際<!--{type="prop" sci="true" input="~(~A)"}-->が<!--{type="prop" sci="true" input="(~A -> False)"}-->の意味そのままなので、背理法は二重否定の除去として考えられる。</p>
</div>
<div key="text_addsub">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic appdef" key="text_app_def">
 <!-- <p>One can apply a function to a value that belongs to its domain, as exampled below: </p> -->
 <p>関数がその定義域の値で適用されることができる。例えば：</p>
</div>
<div key="text_app_def_rewrite">
 <!--TODO-->
</div>
<div key="text_app_inverse_bounded">
 <!--TODO-->
</div>
<div key="text_app_opposite_bounded">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic lrapply" key="text_app_sqrt">
 <!-- <p>Applies square root, if the value is positive.</p> -->
 <p>もし値が正であれば、ルートを取る。</p>
</div>
<div key="text_app_sqrt_bounded">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic lrapply" key="text_app_square">
 <!-- <p>Squaring left and right.</p> -->
 <p>左右両辺の平方を取る。</p>
</div>
<div key="text_app_square_bounded">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic appdef" key="text_appdef">
 <!-- <p>A function is defined by the formula "Let f be defined on ... by f (x) = ...", as in the example below: </p> -->
 <p>関数が「f(x)=...を...の上の関数とする」の様な形で定義されている。例えば：</p>
</div>
<div key="text_apply_forall">
 <!--TODO-->
</div>
<div key="text_apply_fun_lr">
 <!--TODO-->
</div>
<div key="text_apply_ineq_inverse">
 <!--TODO-->
</div>
<div key="text_apply_ineq_sqrt">
 <!--TODO-->
</div>
<div key="text_apply_ineq_square">
 <!--TODO-->
</div>
<div key="text_arith_def">
 <!--TODO-->
</div>
<div key="text_arith_pro">
 <!--TODO-->
</div>
<div key="text_arith_series">
 <!--TODO-->
</div>
<div key="text_ax_bad">
 <!--TODO-->
</div>
<div key="text_ax_good">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_back_elim_equiv">
 <!-- <p>Several versions of equivalence are available, in deduction and justification:</p> -->
 <p>証明や演繹を行う時使える同値関係が何通りもある。例えば：</p>
 <p> </p>
</div>
<div class="toolbox-text custom pedagogic" key="text_binrel">
 <!-- <p> A binary relation connects two elements of the same set. </p> -->
 <p> [??]同じ集合の要素の間の二項関係 </p>
</div>
<div class="toolbox-text custom pedagogic" key="text_bound_conj">
 <!-- <p>Double inequaliy is translated to two inequality statements.</p> -->
 <p>二重不等式が二つの通常の不等式に相当する。</p>
</div>
<div key="text_bound_to_eq">
 <!--TODO-->
</div>
<div key="text_bounded_elim">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_case_base">
 <!-- <p> If "A ∨ B" is true, we just know that one of the two statements is true, without knowing which one. One can not deduce anything directly. However, when we want to prove a statement C knowing that "A ∨ B" is true, it suffices to prove C if A is true, and prove C if B is true. In such a case, we know that C is true in all cases, without knowing which of the two propositions, A or B is true. . </p> -->
 <p> "A ∨ B"が真であるというのはAとBの何方が真であることを意味している。但し、具体的に何方が正しいかは又分からない。なので"A ∨ B"から直接では何も証明できない。しかしもし例えばAのみが真であるときもBのみが真であるときもCが証明できれば"A ∨ B"ならばCが真であることが証明されることになる。つまりCがAとBの何れが真であるとき真であることが証明されることになる。 </p>
</div>
<div class="toolbox-text custom pedagogic" key="text_case_base_binary">
 <!-- <p>The excluded middle rule expresses the fact that, whatever the statement A, either A is true or A is false, excluding any other value of A than true and false. </p> -->
 <p>排中律は任意の命題Aが真か偽かの何方かに決まっているということを主張している。全ての命題について真でもなければ偽でもないということが決してないということを意味している。</p>
</div>
<div key="text_case_good_or_bad">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_comb_comp_lt">
 <p>[!!]Composition preserves the inclusion relation.</p>
</div>
<div class="toolbox-text custom pedagogic comb" key="text_combadd">
 <p></p>
</div>
<div class="toolbox-text custom pedagogic comb" key="text_combinaison">
 <!-- <p>Two equalities can be combined by addition or subtraction of left and right sides.</p> -->
 <p>二つの等式が左辺同士と右辺同士をそれぞれ足し合せることで組み合わせることができる。</p>
</div>
<div class="toolbox-text custom pedagogic" key="text_combine_cmp_minus">
 <p> </p>
</div>
<div class="toolbox-text custom pedagogic" key="text_combine_cmp_plus">
 <p> </p>
</div>
<div class="toolbox-text custom pedagogic comb" key="text_combsub">
 <p></p>
</div>
<div class="toolbox-text custom pedagogic" key="text_commutativity">
 <!-- <p>Multiplication and addition are commutative operations: you can reorder the terms as necessary.</p> -->
 <p>足し算と掛け算が交換律を満しているので、必要に応じて項の順番を変えることができる。</p>
</div>
<div class="toolbox-text custom pedagogic" key="text_conj">
 <!-- <p> To prove "A ∧ B" is to provide two proofs: one A and one B. </p> -->
 <p>"A ∧ B"を証明するためにAとBと両方を証明しなければならない。</p>
</div>
<div key="text_conjunction" class="toolbox-text custom pedagogic">
 <!-- <p>The conjonction of two statements A and B, noted "A ∧ B" and read "A and B", is true if A is true and B is true.</p> -->
 <p>命題AとBがあれば「A且つB」という命題が作れる。それはAとBの連言と呼ばれ、"A ∧ B"と書く。"A ∧ B"がAとBが同時に真になるときのみ真になる。</p>
</div>
<div key="text_converge">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic appdef" key="text_deduce_not_color">
 <!-- <p>Since there are only two white hats, if a hat wearer sees his two friends each carry a white hat, then he/she can infer that he/she is necessarily wearing a black hat.</p> -->
 <!-- <p>By contraposition, if a hat wearer does not know the color of his hat, then at least one of his two comrades is wearing a black hat.</p> -->
 <p>白い帽子が二つしかないので、もし帽子を被ってる人がいて、その人が他の二人が白い帽子を被っていることを見たら、自分が黒い帽子を被っているに違いないことが分かる。</p>
 <p>逆にもしその人が自分が被っている帽子の色が分からなければ、他の二人に少なくとも一人が黒い帽子を被っていることが分かる。</p>
</div>
<div class="toolbox-text custom pedagogic" key="text_def_fbij">
 <!-- <p> A function f of A to B is <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Bijection" target="_blank">bijective</a></span> if it is both injective and surjective: any element of B is the image by f of one and only one element of A. </p> -->
 <p>AからBの関数が<span class="exturl"><a href="https://ja.wikipedia.org/wiki/%E5%85%A8%E5%8D%98%E5%B0%84" target="_blank">全単射</a></span>であることはつまりこの関数は全射でもあり単射でもあることである。</p>
</div>
<div class="toolbox-text custom pedagogic" key="text_def_fcomp">
 <!-- <p>The composition of two functions f: A → B and g: B → C, denoted "f ∘ g" and read "f round g", is a function of A to C so that the image of an element x of A is the image under g of the image under f of x. </p> -->
 <p>[!!]関数f: A → Bとg: B → Cの合成は"g∘f"と書き、「g丸f」と呼ぶ。"g∘f"がAからCの関数であり、"g∘f(x) = g(f(x))"として定まれている。</p>
 <!-- <p> The composition operator provides with a function of type (A → C) from two of functions of types (A → B) and (B → C). A form of similarity is noted with the proof of a <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Syllogisme" target="_blank">syllogism</a></span> that provides proof of -->
 <!--  <\!--{type="prop" sci="true" input="A -> C"}-\-> assuming -->
 <!--  <\!--{type="prop" sci="true" input="A -> B"}-\-> and -->
 <!--  <\!--{type="prop" sci="true" input="B -> C"}-\-> ... </p> -->
 <p>関数の合成が<span class="exturl"><a href="https://ja.wikipedia.org/wiki/%E4%B8%89%E6%AE%B5%E8%AB%96%E6%B3%95" target="_blank">三段論法</a></span>と似た様な形をしている。実際三段論法は<!--{type="prop" sci="true" input="A -> B"}-->と<!--{type="prop" sci="true" input="B -> C"}-->が成り立てばば<!--{type="prop" sci="true" input="A -> C"}-->も成り立つことを主張している。</p>
</div>
<div class="toolbox-text custom pedagogic" key="text_def_finj">
 <!-- <p> A function is <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Injection_(math%C3%A9matiques)" target="_blank">injective</a></span> if the corresponding relation is injective. Thus the function f of A to B is injective iif an element of B is the image of one and only one element of A. or in other words, if two elements x and z have the same image under f, then these elements are the same. </p> -->
 <p>ある関数が<span class="exturl"><a href="https://ja.wikipedia.org/wiki/%E5%8D%98%E5%B0%84" target="_blank">単射</a></span>であるというのは値域の任意の元が高々一つの原像を持つことである。これはつまりもしxとyのfによる像が等しければxとyも等しいということである。</p>
 <!-- <p>Note that to prove that a function f is not injective, just find two distinct elements that have the same image by f. </p> -->
 <p>関数fが単射ではないことを証明したければ、単に像が等しくなるような二つの等しくない元を探せばよい。</p>
</div>
<div class="toolbox-text custom pedagogic" key="text_def_finvol">
 <!-- <p> If f is a function from E to E, it is <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Involution_(math%C3%A9matiques)" target="_blank">involutive</a></span> if the image of the image of an element x, is x itself. </p> -->
 <!-- <p>Examples:</p> -->
 <p>EからEの関数fが<span class="exturl"><a href="https://ja.wikipedia.org/wiki/%E5%AF%BE%E5%90%88" target="_blank">対合的</a></span>というのは、任意のxについて"f(f(x)) = x"が満たしているということである。</p>
 <p>例えば：</p>
 <ul>
  <!-- <li>the symmetry in a mirror</li> -->
  <!-- <li>in <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Logique_classique" target="_blank">classical logic</a></span> , the negation of a proposition is involutive, allowing the <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Raisonnement_par_l%27absurde" target="_blank">reduction ad absurdum</a></span></li> -->
  <!-- <li>the encryption algorithm <span class="exturl"><a href="https://fr.wikipedia.org/wiki/ROT13" target="_blank">ROT13</a></span></li> -->
  <li>鏡の写し</li>
  <li><span class="exturl"><a href="https://ja.wikipedia.org/wiki/%E5%8F%A4%E5%85%B8%E8%AB%96%E7%90%86" target="_blank">古典論理</a></span>では、命題の否定は対合的である。これのお陰で<span class="exturl"><a href="https://ja.wikipedia.org/wiki/%E8%83%8C%E7%90%86%E6%B3%95" target="_blank">背理法</a></span>が成り立っている。</li>
  <li>暗号<span class="exturl"><a href="https://ja.wikipedia.org/wiki/ROT13" target="_blank">ROT13</a></span></li>
 </ul>
 <p></p>
</div>
<div class="toolbox-text custom pedagogic" key="text_def_fsurj">
 <!-- <p>A function f of A to B is surjective if all elements of B are the image of at least one element of A. </p> -->
 <p>AからBまでの関数fが全射というのはBの任意の要素がAに一つ以上の原像を持つことである。</p>
</div>
<div class="toolbox-text custom pedagogic" key="text_def_rantisym">
 <!-- <p>A binary relation on E is antisymmetric if, for any elements x y of E, if the pairs (x, y) and (y, x) belong to the graph of the relationship, then x is the same element as y.</p> -->
 <p>Eの上の二項関係Rが反対称関係であるというのはEの任意の要素x, yに対してもし xRy 且つ yRx であればxとyが必ず等しいということである。</p>
</div>
<div class="toolbox-text custom pedagogic" key="text_def_rcomp">
 <!-- <p> If A B and C are sets, if -->
 <!--  <\!--{type="expr" input="R1"}-\-> a relation on A×B, and if -->
 <!--  <\!--{type="expr" input="R2"}-\-> a relation on B×C, then composition of -->
 <!--  <\!--{type="expr" input="R1"}-\-> and -->
 <!--  <\!--{type="expr" input="R2"}-\->, noted -->
 <!--  <\!--{type="expr" input="RComp R1 R2"}-\->, is the relation on A×C such that an élément x of A is in relation with an element z of C by -->
 <!--  <\!--{type="expr" input="RComp R1 R2"}-\->, if x and z are in relation with an element y of B, respectively on the left y by -->
 <!--  <\!--{type="expr" input="R1"}-\-> and on the left by -->
 <!--  <\!--{type="expr" input="R2"}-\-> : </p> -->
 <p>AとBを集合として、もし<!--{type="expr" input="R1"}-->はA×Bの上の関係であり、<!--{type="expr" input="R2"}-->がB×Cの上の関係であれば<!--{type="expr" input="R1"}-->と<!--{type="expr" input="R2"}-->の合成ができる。その合成は<!--{type="expr" input="RComp R1 R2"}-->と書き、(x, z)がこの合成関係に満すということは存在Bの要素y、(x, y)が<!--{type="expr" input="R1"}-->を満し、かつ(y, z)が<!--{type="expr" input="R2"}-->を満していることである。</p>
</div>
<div class="toolbox-text custom pedagogic" key="text_def_rfun">
 <!-- <p>A relation of A×B is functional if an element of A is related to at most one element of B. </p> -->
 <p>[??]もしとあるA×Bの上の関係が関数であれば、任意のAの要素が高々Bの要素の一つと関係している。</p>
</div>
<div class="toolbox-text custom pedagogic" key="text_def_rident">
 <p>[!!]The graph of the identity relation on set E, noted
  <!--{type="expr" input="RIdent U E"}--> is all couples
  <!--{type="expr" input="upair x x"}--> where x belongs to E. </p>
</div>
<div class="toolbox-text custom pedagogic" key="text_def_rinj">
 <p>[!!]A relation of A×B is injective if an element of B is related to at most one element of A. In other words, an element of B in relation by R, is in relation with only one element of A. In other words again, if two elements of a are in relation with an element of B by an injective relation, then these two elements are the same. </p>
</div>
<div class="toolbox-text custom pedagogic" key="text_def_rinv">
 <!-- <p>The inverse relation of a relation R defined on A×B, denoted R⁻¹, is defined on B × A by: </p> -->
 <p>A×Bの上の関係Rの逆関係R⁻¹はB×Aの上の関係となり、以下の様に定義されている。</p>
</div>
<div class="toolbox-text custom pedagogic" key="text_def_rrefl">
 <!-- <p>A binary relation on E is reflexive if any element of E is related to itself.</p> -->
 <p>Eの上の二項関係Rが反射律を満すというのはEの任意の要素xに対して xRx が成り立つということである。</p>
</div>
<div class="toolbox-text custom pedagogic" key="text_def_rsurj">
 <p>[!!]A relation of A × B is surjective, or right-total, if all elements of B are in relation with an element of A. </p>
</div>
<div class="toolbox-text custom pedagogic" key="text_def_rsym">
 <!-- <p>A binary relation on E is symmetric if, for every elements x and y of E, the pairs (x, y) and (y, x) belong to the graph of the relation.</p> -->
 <p>Eの上の二項関係Rが対称律を満すというのはEの任意の要素x, yに対して xRy が成り立てば yRx も必ず成り立つということである。</p>
</div>
<div class="toolbox-text custom pedagogic" key="text_def_rtotleft">
 <p>[!!]A relation on A × B is left-total if all elements of A are in relation with an element of B. </p>
</div>
<div class="toolbox-text custom pedagogic" key="text_def_rtrans">
 <!-- <p>A binary relation is transitive if:</p> -->
 <p>二項関係が推移律を満すというのは以下のことである：</p>
</div>
<div class="toolbox-text custom pedagogic" key="text_disjonction">
 <!-- <p>The disjunction of two propositions A and B, denoted "A ∨ B" and read "A or B" is true if A is true or B is true.</p> -->
 <p>命題AとBがあれば「A又はB」という命題が作れる。それはAとBの選言と呼ばれ、"A ∨ B"と書く。"A ∨ B"がAとBの何方か、或いは両方が真になるとき真になる。</p>
</div>
<div class="toolbox-text custom pedagogic" key="text_distrib">
 <!-- <p>The multiplication is distributive over addition.</p> -->
 <p>掛け算は足し算について分配律が成り立っている。</p>
</div>
<div key="text_elim_comp">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_elim_conj_left">
 <!-- <p> If "A ∧ B" is true, then A is true. </p> -->
 <p>"A ∧ B"が真であればAが真である。</p>
</div>
<div class="toolbox-text custom pedagogic" key="text_elim_conj_right">
 <!-- <p>If "A ∧ B" is true, then B is true.</p> -->
 <p>"A ∧ B"が真であればBが真である。</p>
</div>
<div key="text_elim_eqfun">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_elim_eqset">
 <!-- <p>Two sets A and B are equal if being element of A involves be element of B, and vice versa; that is to say that A is included in B and conversely B is included in A (by definition of inclusion). Equality is simply noté "A = B". </p> -->
 <p>集合AとBが等しいというのはAの要素が全てBの要素であり、逆にBの要素も全てAの要素であることとして定義されている。これはつまりAがBを含み、かつBがAを含むことである。集合AとBが等しいということは"A = B"と書く。</p>
</div>
<div key="text_elim_even_def">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_elim_false_exset">
 <!-- <p> By definition, <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Ensemble_vide" target="_blank">the empty set</a></span> , denoted by ∅, is the set that is included in any set. </p> -->
 <p><span class="exturl"><a href="https://ja.wikipedia.org/wiki/%E7%A9%BA%E9%9B%86%E5%90%88" target="_blank">空集合</a></span>というのは一つも要素のない集合として定義されている。空集合は∅と書く。</p>
</div>
<div class="toolbox-text custom pedagogic" key="text_elim_gen_app_rel">
 <p>[!!]In the following, a relation R is equated with its graph in order to keep formulas and notations simple. </p>
</div>
<div key="text_elim_has_finite_limit_decr">
 <!--TODO-->
</div>
<div key="text_elim_has_finite_limit_incr">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_elim_is_elem_universe">
 <!-- <p> By definition, the universe, noted U, is the set that contains all elements. The universe is the largest set in the sense of inclusion (any set is included in the universe). </p> -->
 <p>宇宙(universe) Uというのは全ての集合の全ての要素を集った集合として定義されている。宇宙が任意の集合を含むという意味では最も大きい集合である。</p>
</div>
<div key="text_elim_multiple">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_elim_negation">
 <!-- <p> The negation of a statement A is defined using the constant <span style="font-weight:bold">contradiction</span> as follows: </p> -->
 <p>命題Aの否定は<span style="font-weight:bold">矛盾</span>という定数を用いて以下の様に定義されている。</p>
</div>
<div key="text_elim_pprod">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_elim_requiv">
 <p>An <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Relation_d%27%C3%A9quivalence" target="_blank">equivalence relation</a></span> is reflexive, symmetric, and transitive. For example, equality and equivalence are equivalence relations. </p>
 <p><span class="exturl"><a href="https://ja.wikipedia.org/wiki/%E5%90%8C%E5%80%A4%E9%96%A2%E4%BF%82" target="_blank">同値関係</a></span>というのは反射律、対称律、及び推移律を満す二項関係のことである。例えば等号と論理的同値が同値関係である。</p>
</div>
<div class="toolbox-text custom pedagogic" key="text_elim_scomp">
 <!-- <p> The complement of a set A in the universe U, denoted " -->
 <!--  <\!--{type="expr" input="scomp (sall U) A"}-\-> " and read "complement of A in U" or simply "complement of A", contains elements that are not in A: </p> -->
 <p>集合Aの補集合というのは集合Aの要素ではないものを全て集った集合である。この集合は<!--{type="expr" input="scomp (sall U) A"}-->と書く。実際補集合は宇宙(universe) Uに対して定義されており、Aの補集合は全てのAの要素でないUの要素が成す集合を指している。</p>
 <span style="position:relative;left:-20px;display:inherit;width:110%;text-align:center;padding-bottom:0px;background-color:rgba(0,172,231,1)"> <img src="./svg/complement.svg" style="width:auto;height:150px;position:relative"> </span>
</div>
<div class="toolbox-text custom pedagogic" key="text_elim_sdiff">
 <!-- <p> The relative complement of two sets A and B, denoted " -->
 <!--  <\!--{type="expr" input="sdiff A B"}-\->" contains the elements that are in A and not in B: </p> -->
 <p>集合AとBの差集合というのはBの要素ではない全てのAの要素を集った集合である。この集合は<!--{type="expr" input="sdiff A B"}-->と書く。</p>
 <span style="display:inherit;width:100%;text-align:center;padding-bottom:0px;position:relative"> <img src="./svg/diff.svg" style="width:auto;height:150px"> </span>
</div>
<div class="toolbox-text custom pedagogic" key="text_elim_sequiv">
 <!-- <p>The equivalence class of an element x by a relation R on a set E, denoted -->
 <!--  <\!--{type="expr" input="sequiv x R"}-\-> , is the set of elements related to x by R.</p> -->
 <p>Eの要素xのRによる同値類というのはRによってxと関係が結ばれている全てのEの要素を集った集合である。この集合は<!--{type="expr" input="sequiv x R"}-->と書く。</p>
</div>
<div class="toolbox-text custom pedagogic" key="text_elim_set_lteq">
 <!-- <p>A set is included in another if and only if being an element of it implies being element of the other.</p> -->
 <p>集合Aが集合Bに含まれるというのはAの全ての要素が同時にBの要素でもあるということである。</p>
 <span style="display:inherit;width:100%;text-align:center;padding-bottom:0px"> <img src="./svg/subset.svg" style="width:auto;height:150px"> </span>
</div>
<div key="text_elim_shas_lower_bound">
 <!--TODO-->
</div>
<div key="text_elim_shas_upper_bound">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_elim_sinter">
 <!-- <p> The intersection of two sets A and B, denoted " -->
 <!--  <\!--{type="expr" input="sinter A B"}-\-> " and read "A inter B" contains the elements that are in both A and B: </p> -->
 <p>集合AとBの共通部分が<!--{type="expr" input="sinter A B"}-->と書き、"AキャップB"と呼ぶ。</p>
 <span style="display:inherit;width:100%;text-align:center;padding-bottom:0px;position:relative"> <img src="./svg/inter.svg" style="width:auto;height:150px"> </span>
</div>
<div key="text_elim_sis_decreasing">
 <!--TODO-->
</div>
<div key="text_elim_sis_gt_zero">
 <!--TODO-->
</div>

<!-- ## Daisuke -->

<div key="text_elim_sis_increasing">
 <!--TODO-->
</div>
<div key="text_elim_sis_lt_zero">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_elim_subset">
 <p> <a href="https://fr.wikipedia.org/wiki/Ensemble_des_parties_d%27un_ensemble" target="_blank">The power set</a> of a set A, denoted
  <!--{type="expr" input="ssubset A"}--> , is the set of subsets of A. </p>
 <p> In particular we deduce that
  <!--{type="prop" sci="true" input="sis_element A (ssubset A)"}--> since
  <!--{type="prop" sci="true" input="set_lteq A A"}--> by definition of inclusion. </p>
</div>
<div class="toolbox-text custom pedagogic" key="text_elim_sunion">
 <p> The union of two sets A and B, denoted "
  <!--{type="expr" input="sunion A B"}--> " and read "A union B" contains the elements that either A or B in: </p>
 <span style="display:inherit;width:100%;text-align:center;padding-bottom:0px;position:relative"> <img src="./svg/union.svg" style="width:auto;height:150px"> </span>
</div>
<div class="toolbox-text custom pedagogic" key="text_elim_true_at_rank">
 <p>The first step of the induction defines a statement P of an index n, as in the example below: </p>
</div>
<div key="text_eq_inverse">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic lrapply" key="text_eq_reverse">
 <p>Taking the opposite on left and right sides.</p>
</div>
<div class="toolbox-text custom pedagogic eqrel" key="text_eq_symmetry">
 <p>If a = b then b = a.</p>
</div>
<div class="toolbox-text custom pedagogic eqrel" key="text_eq_trans">
 <p>If a = b and b = c then a = c.</p>
</div>
<div key="text_eqfun">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic eqrel" key="text_eqrel">
 <p>Equality is a transitive and symmetrical relation.</p>
</div>
<div class="toolbox-text custom pedagogic" key="text_eqset">
 <p>Two sets A and B are equal if being element of A involves be element of B, and vice versa; that is to say that A is included in B and conversely B is included in A (by definition of inclusion). Equality is simply noté "A = B". </p>
</div>
<div class="toolbox-text custom pedagogic" key="text_equiv">
 <p>When statements "A ⇒ B" and "B ⇒ A" are both true, ie when "(A ⇒ B) ∧ (B ⇒ A)" is true, we say that A is equivalent to B and we note "A ⇔ B". </p>
</div>
<div class="toolbox-text custom pedagogic" key="text_equiv_rtrans">
 <p>Set formulation of a transitive relation:</p>
</div>
<div class="toolbox-text custom pedagogic" key="text_ex_elim">
 <p> The deduction from an existence
  <!--{type="prop" sci="true" input="exists x, app_prop F x"}--> <span class="stress">declares an element</span> x that verifies the proposition
  <!--{type="prop" sci="true" input="app_prop F x"}--> . </p>
</div>
<div class="toolbox-text custom pedagogic" key="text_ex_intro">
 <p> Proving existence is about <span class="stress">finding an element</span> for which the statement is true. Such an element is called a <span class="stress">witness</span> of the proof
  <!--{type="prop" sci="true" input="exists (x:O1U), app_prop F x"}--> . </p>
 <!-- <p>Trouver un témoin consiste à trouver une valeur pour l'<span class="stress">inconnue de raisonnement</span> <span class="evar" style="font-size:15px">x?</span> </p> -->
</div>
<div class="toolbox-text custom pedagogic" key="text_exists">
 <p> The statement that F is true for an element x is denoted
  <!--{type="prop" sci="true" input="app_prop F x"}--> and read "F of x". </p>
 <p> The existence of an element x such that F (x) is true, denoted
  <!--{type="prop" sci="true" input="exists (x:O1U), app_prop F x"}--> and read "there exists x such that x F" is true if, for a value t, we can prove
  <!--{type="prop" sci="true" input="app_prop F t"}--> . The operator ∃ is called <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Quantificateur_(logique)" target="_blank">existential quantifier</a></span> . </p>
</div>
<div class="toolbox-text custom pedagogic" key="text_expand">
 <p>Full development of product of factors.</p>
</div>
<div key="text_fact">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_factorize">
 <p>'Remarkable' factorization detects a common factor in a sum of terms, and factorize it.</p>
</div>
<div class="toolbox-text custom pedagogic" key="text_falseall">
 <p>"False results from what you want." This rule enable to justify any statement with the constant <span style="font-weight:bold">contradiction.</span></p>
 <p>This rule is very useful especially in the reasoning by disjunction of cases: indeed if a contradiction is obtained in a case, it can be concluded directly with this rule.</p>
 <p>You find this logical principle in popular expressions:</p>
 <ul>
  <li>With "if", we would put Paris in a bottle (french).</li>
  <li>When Pigs Fly ...</li>
 </ul>
</div>
<div class="toolbox-text custom pedagogic" key="text_forall">
 <p> The statement that F is true for every value x, denoted
  <!--{type="prop" sci="true" input="forall (x:O1U), (app_prop F x)"}--> and read "for every x, F x" is true if we can prove
  <!--{type="prop" sci="true" input="app_prop F x"}--> for any element x. The operator ∀ is called <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Quantificateur_(logique)" target="_blank">universal quantifier</a></span> . </p>
</div>
<div key="text_funop">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_gen_factorize">
 <p>Factorization by any value <span class="stress">other than zero.</span></p>
</div>
<div key="text_geo_def">
 <!--TODO-->
</div>
<div key="text_geo_pro">
 <!--TODO-->
</div>
<div key="text_geo_series">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_implication">
 <p>Implication from A to B, denoted "A ⇒ B" and read "A implies B" or "if A then B" means that B can not be false when A is true.</p>
</div>
<div class="toolbox-text custom pedagogic" key="text_inclusionsimpl">
 <p> One can simplify the intersection (or the union) of two sets if one of two sets is included in the other. </p>
</div>
<div class="toolbox-text custom pedagogic" key="text_ind_basic_forall">
 <p>The justification by induction uses the <span class="stress">initialization</span> statement and the <span class="stress">heredity</span> statement. </p>
</div>
<div key="text_ind_init">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_induction">
 <p>In general statetments beginning with "For every integer n ..." is proved by induction. </p>
</div>
<div class="toolbox-text custom pedagogic" key="text_ineq_sym_rew">
 <p>A comparison can be rewritten by changing the order of values ​​and replacing the comparison by its reciprocal. For example
  <!--{type="prop" sci="true" style="vertical-align:-3px;" input="ExprLT a b"}--> rewrites to
  <!--{type="prop" sci="true" style="vertical-align:-3px;" input="ExprGT b a"}--> . </p>
</div>
<div class="toolbox-text custom pedagogic appdef" key="text_ineqapp">
 <p>A function can be applied to the left and right sides of an inequality, without changing its sense, if the left and right sides values belong to the domain of definition of f, and if f is increasing on this domain.</p>
</div>
<div key="text_ineqbound_application" class="toolbox-text custom pedagogic">
 <p>A function can be applied to the left, right and center of a double inequality, without changing its sens, if the left and right values belong to the domain of definition of f, and if f is increasing on this domain.</p>
</div>
<div key="text_ineqbound_comb_add">
 <!--TODO-->
</div>
<div key="text_ineqbound_comb_mul">
 <!--TODO-->
</div>
<div key="text_ineqbound_comb_sub">
 <!--TODO-->
</div>
<div key="text_ineqbound_combination" class="toolbox-text custom pedagogic">
 <p>Two double inequalities may be combined by addition subtraction or multiplication.</p>
</div>
<div key="text_ineqbound_conversion">
 <!--TODO-->
</div>
<div key="text_ineqbound_operations" class="toolbox-text custom pedagogic">
 <p>Operations on the left, right and center allow to tranform a double inequality by adding, subtracting, multiplying or dividing by a value. </p>
</div>
<div key="text_ineqbound_relation" class="toolbox-text custom pedagogic">
 <p>The transitivity property of inequality is available for double inequality.</p>
</div>
<div key="text_ineqbound_trans">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_ineqcomb">
 <p>Two inequalities can be combined by addition or subtraction of left and right sides.</p>
</div>
<div key="text_ineqconv">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_ineqrel">
 <p>Comparisons are transitive relations. The reciprocal relation allows to rewrite inequality by changing the order of compared values. </p>
</div>
<div class="toolbox-text custom pedagogic" key="text_intro_false">
 <p> We can deduce a contradiction from a statement and its negation.</p>
</div>
<div class="toolbox-text custom pedagogic" key="text_intro_or_left">
 <p>To prove "A ∨ B", it suffices to prove A.</p>
</div>
<div class="toolbox-text custom pedagogic" key="text_intro_or_right">
 <p>To prove "A ∨ B", it suffices to prove B.</p>
</div>
<div key="text_intro_sqrt_square">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic leftright" key="text_leftright">
 <p>Equality is preserved by applying an operation to the left and right sides (addition, subtraction, multiplication, division).</p>
</div>
<div class="toolbox-text custom pedagogic" key="text_leftright_ineq">
 <p>The left and right operations (addition, subtraction, multiplication, division) can transform an inequality (or double inequality) on the left and right sides. </p>
 <p>Four forms of comparison (superiority or inferiority, strict or not), and four forms of double inequality are considered.</p>
</div>
<div class="toolbox-text custom pedagogic appdef" key="text_leftright_neq">
 <p>As for equality, inequality is preserved by applying the same operation (addition, subtraction, multiplication, division) to the left and right sides.</p>
</div>
<div key="text_limfinite">
 <!--TODO-->
</div>
<div key="text_limit_finite">
 <!--TODO-->
</div>
<div key="text_limit_inf">
 <!--TODO-->
</div>
<div key="text_limit_neg_inf">
 <!--TODO-->
</div>
<div key="text_limitinf">
 <!--TODO-->
</div>
<div key="text_limitops">
 <!--TODO-->
</div>
<div class="toolbox-text custom simpl" key="text_linearsimpl" style="padding-left:20px;padding-right:20px">
 <p>Simplifications can:</p>
 <ul>
  <li style="font-size:14px">calculate a numerical term (which contains only numbers)</li>
  <li style="font-size:14px">perform simple polynomial operations (addition, subtraction, ...)
   <!-- <span class="stress">de degré 1</span> --></li>
  <li style="font-size:14px">perform linear simplifications (elimination of terms like 'x-x')</li>
  <!--  <li style="font-size:14px;">factoriser les puissances par rapport à la multiplication</li> -->
 </ul>
 <p></p>
</div>
<div class="toolbox-text custom pedagogic" key="text_logicothers">
 <p> In the early 20 <span class="sup">th</span> century, the mathematical current <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Constructivisme_(math%C3%A9matiques)" target="_blank">constructivist</a></span> considered that a valid proof of "A ∨ B" should allow to know which of the two statements is true, and therefore it rejected the use of the excluded middle principle. We speak of <span class="stress">constructivist logic</span> (or intuitionistic) when the excluded middle is not admitted, and <span class="stress">classical logic</span> when admitted. </p>
</div>
<div class="toolbox-text custom pedagogic leftright" key="text_lradd">
 <p>Addition to left and right sides. This allows to pass a term from one side of an equality to the other (with sign change).</p>
</div>
<div key="text_lradd_bounded">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_lradd_ineq">
 <p>Addition to left and right sides. This allows to pass a term from one side of an inequality to the other (with sign change). </p>
</div>
<div key="text_lradd_neq">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic lrapply" key="text_lrapply">
 <p>A function f can be applied to the left and right sides of an equality, if the value belongs to the domain of f. Four major functions are introduced: square, square root, opposite function and inverse function.</p>
</div>
<div class="toolbox-text custom pedagogic leftright" key="text_lrdiv">
 <p>Division by a value of left and right sides. The argument should be different from zero.</p>
</div>
<div key="text_lrdiv_bounded">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_lrdiv_ineq">
 <p>Division by a value of left and right sides. If the is argument is negative, the sense of inequality is changed. </p>
</div>
<div key="text_lrdiv_neq">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic leftright" key="text_lrmul">
 <p>Multiplication by a value of the left and right sides.</p>
</div>
<div key="text_lrmul_bounded">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_lrmul_ineq">
 <p>Multiplication by a value of left and right sides. If this value is negative, the sense of inequality is changed.</p>
</div>
<div key="text_lrmul_neq">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic leftright" key="text_lrsub">
 <p>Subtraction by a value of left and right sides. This allows to pass a term from one side of an equality to the other (with sign change).</p>
</div>
<div key="text_lrsub_bounded">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_lrsub_ineq">
 <p>Subtraction by a value of left and right sides. This allows to pass a term from one side of an inequ to the other (with sign change).</p>
</div>
<div key="text_lrsub_neq">
 <!--TODO-->
</div>
<div key="text_lt_next_int">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_modus_ponens">
 <p> Deducing B from A means that if A is true, one can deduce B. This rule is called <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Modus_ponens" target="_blank">modus ponens</a></span> .</p>
</div>
<div key="text_muldiv">
 <!--TODO-->
</div>
<div key="text_multiple">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_negation">
 <p> The negation of a statement A is noted "¬ A" and reads "not A". </p>
</div>
<div key="text_neq_symmetry">
 <!--TODO-->
</div>
<div key="text_non_zero_gt">
 <!--TODO-->
</div>
<div key="text_non_zero_lt">
 <!--TODO-->
</div>
<div key="text_oldest">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_polysquare">
 <p>The square factorization of the sum of the term
  <!--{type="expr" input="a"}--> and
  <!--{type="expr" input="b"}--> is given by the formula: </p>
 <p>
  <!--{type="prop" sci="true" input=" ((pow a 2) + (2*a*b) + (pow b 2)) = (pow (a+b) 2)"}--></p>
 <p>For example :</p>
</div>
<div key="text_prod">
 <!--TODO-->
</div>
<div key="text_proddecompl">
 <!--TODO-->
</div>
<div key="text_proddef">
 <!--TODO-->
</div>
<div key="text_prodidx">
 <!--TODO-->
</div>
<div key="text_prodinverse">
 <!--TODO-->
</div>
<div key="text_prodlinear">
 <!--TODO-->
</div>
<div key="text_prodrem">
 <!--TODO-->
</div>
<div key="text_prodresult1">
 <!--TODO-->
</div>
<div key="text_prodsimpl">
 <!--TODO-->
</div>
<div key="text_produpshift">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic appdef" key="text_reason_capacity">
 <p>Since hat wearers are endowed with reason, if one can deduce one hat color, so can a hat wearer, and then he knows the color of his/her hat. </p>
</div>
<div key="text_red_true_at_rank">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_reducedenom">
 <p>Getting to the common denominator of a sum of fractions.</p>
 <p></p>
</div>
<div class="toolbox-text custom pedagogic" key="text_relops">
 <p>operators</p>
</div>
<div class="toolbox-text custom pedagogic" key="text_relothers">
 <p>remarkable</p>
</div>
<div class="toolbox-text custom pedagogic" key="text_relprop">
 <p>relations</p>
</div>
<div key="text_relset">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_remid">
 <p>Remarkable identities allow to factorize terms with simple specific forms, common in the calculations. </p>
</div>
<div class="toolbox-text custom pedagogic" key="text_rewops">
 <p> Rewriting operations appy an operation and its reciprocal to rewrite a term into an equal term.</p>
</div>
<div key="text_rewprops">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_rewriting">
 <p> Select a term 'a' in an equation allows to replace the term with 'b' if equality 'a = b' is true. </p>
</div>
<div key="text_sandwich">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_section">
 <p>To prove "A ⇒ B" one creates a new logical scope (a new exercise) in which A is a hypothesis and B is the conclusion.</p>
</div>
<div key="text_series_limitation">
 <!--TODO-->
</div>
<div key="text_series_sign">
 <!--TODO-->
</div>
<div key="text_series_variation">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_set_absorb">
 <p> The empty set is the <span class="exturl"><a href="https://fr.wikipedia.org/wiki/%C3%89l%C3%A9ment_absorbant" target="_blank">absorbent element</a></span> of the intersection operation, and the universe is the absorbent element of the union operation (as 0 is the multiplication of absorbent element). </p>
</div>
<div class="toolbox-text custom pedagogic" key="text_set_adabsurdum">
 <p>The complement of the complement of a set is the set. This rule, elimination of double complement, is called 'ad absurdum', by analogy with the <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Raisonnement_par_l%27absurde" target="_blank">reduction ad absurdum</a></span> of classical logic, which is the rule for the elimination of double negation. </p>
</div>
<div key="text_set_comb">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_set_demorgan">
 <p> The complement of the intersection (resp. union) of two sets is the union (resp. intersection) complements of these sets. </p>
</div>
<div class="toolbox-text custom pedagogic" key="text_set_eq_symmetry">
 <p>The symmetry of set equality is available for set calculations.</p>
</div>
<div class="toolbox-text custom pedagogic" key="text_set_eq_trans">
 <p>Transitivity of set equality is available for set calculations.</p>
</div>
<div class="toolbox-text custom pedagogic" key="text_set_excluded">
 <p> Every element of the universe belong to either a set or to its complement, to the exclusion of any other possibility. </p>
</div>
<div key="text_set_inter_comb">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_set_lteq_transitivity">
 <p>The set inclusion is a transitive relation.</p>
</div>
<div class="toolbox-text custom pedagogic" key="text_set_neutral">
 <p> The empty set is the <span class="exturl"><a href="https://fr.wikipedia.org/wiki/%C3%89l%C3%A9ment_neutre" target="_blank">neutral element</a></span> of the union and the universe is the neutral element of the intersection (as 1 is the neutral element of the multiplication, and 0 is the neutral element of addition ). </p>
</div>
<div class="toolbox-text custom pedagogic" key="text_set_rewriting">
 <p> Rewriting operations allow to replace a term A by another term B, if statement A = B can be proved. Known algebraic properties (commutative, associative, ...) of set operations (intersection, union, ...) are invoked directly, without justification. </p>
</div>
<div key="text_set_union_comb">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_setassociative">
 <p> Intersection and union are associative operations. </p>
</div>
<div class="toolbox-text custom pedagogic" key="text_setcommutative">
 <p> Intersection and union are commutative operations. </p>
</div>
<div class="toolbox-text custom pedagogic" key="text_setdevelopp">
 <p> Intersection and union operations are distributive over one another. </p>
</div>
<div key="text_setexpr">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_setfactorize">
 <p> Intersection and union operations are distributive over one another. </p>
</div>
<div class="toolbox-text custom pedagogic" key="text_setfun">
 <p> A function is a formula with a variable x in a universe A. This formulation is denoted
  <!--{type="expr" input="app_fun f x"}--> and read 'f of x'. A function f maps an element x of A to an element y of B called <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Fonction_(math%C3%A9matiques_%C3%A9l%C3%A9mentaires)#Image.2C_ant.C3.A9c.C3.A9dent" target="_blank">the image</a></span> of x by f. The element x is called <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Ant%C3%A9c%C3%A9dent_(math%C3%A9matiques)" target="_blank">the antecedent</a></span> of y f. Such a function is declared by the formula f: A → B 'read' f is a function from A to B '. </p>
 <!--  <p>
    La nature de cette association est telle que la <span class="exturl">
      <a href="https://fr.wikipedia.org/wiki/Relation_(math%C3%A9matiques)"
   target="_blank">relation</a></span> définie sur A×B par "f(x) = y" est
    fonctionnelle : un élément de A a une et une seule image par f. Une
    fonction peut être assimilée à une relation fonctionnelle.
  </p> -->
</div>
<div class="toolbox-text custom pedagogic" key="text_setgraph">
 <p> The set of couples
  <!--{type="expr" input="upair x y"}--> in relation by R is denoted "
  <!--{type="prop" sci="true" input="gen_app_rel R x y"}--> ". This set is the <span class="stress">graph</span> of the relation R. The graph is a subset of the <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Produit_cart%C3%A9sien" target="_blank">Cartesian product</a></span>
  <!--{type="expr" input="(pprod A B)"}--> . </p>
</div>
<div class="toolbox-text custom pedagogic" key="text_setops">
 <p>If the universe is the set of points of the plane, a set may be represented by a set of all points inside a closed border, ie by a surface. In this case, set operations may be represented by the blue surfaces below. </p>
</div>
<div class="toolbox-text custom pedagogic" key="text_sigma">
 <p>Rewriting properties result from the associative and distributive properties of addition and multiplication.</p>
</div>
<div class="toolbox-text custom pedagogic" key="text_sigmadecompl">
</div>
<div key="text_sigmadef">
 <!--TODO-->
</div>
<div key="text_sigmaidx">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_sigmainverse">
 <p>Summed elements' order can be reversed to add (by commutative property of addition).</p>
</div>
<div class="toolbox-text custom pedagogic" key="text_sigmalinear">
 <p>One can factorize
  <!--{type="expr" input="lambda"}--> below only if
  <!--{type="expr" input="lambda"}--> does not depend on k.</p>
</div>
<div class="toolbox-text custom pedagogic" key="text_sigmarem">
 <p>Remarkable sums are available to solve exercises.</p>
</div>
<div key="text_sigmaresult1">
 <!--TODO-->
</div>
<div key="text_sigmaresult2">
 <!--TODO-->
</div>
<div key="text_sigmaresult3">
 <!--TODO-->
</div>
<div key="text_sigmasimpl">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_sigmaupshift">
 <p>Shifting the index of the summed value.</p>
</div>
<div key="text_simpl"></div>
<div key="text_slim_def_elim">
 <!--TODO-->
</div>
<div key="text_slim_inf_def_elim">
 <!--TODO-->
</div>
<div key="text_slimfinite_inf_elim">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_slteq">
 <p>A set A is included in another set B, if being element of A implies being element of B.</p>
</div>
<div class="toolbox-text custom pedagogic" key="text_somesets">
</div>
<div class="toolbox-text custom pedagogic appdef" key="text_sophiehattheory">
 <p>The protagonists of this story are called hat wearers.</p>
</div>
<div class="toolbox-text custom pedagogic" key="text_square_diff">
 <p>The factorization of the difference of squares is given by the formula: </p>
 <p>
  <!--{type="prop" sci="true" input="((pow a 2)-(pow b 2)) = ((a+b)*(a-b))"}--></p>
 <p>For example :</p>
</div>
<div key="text_subadd">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_trans_lt_gt">
 <p> If a is greater than b, which is greater than c, then a is greater than c. </p>
 <p>These rules are also available for double inequality</p>
</div>
<div key="text_true_at_rank">
 <!--TODO-->
</div>
<div key="text_truthlie">
 <!--TODO-->
</div>
<div key="text_updownsimpl">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_varchange">
 <p>a change of variables is a basic technique used to simplify problems in which the original variables are replaced with functions of other variables</p>
 <p>In the example below, the equation
  <!--{type="expr" input="sqrt(x)"}--> is a second-degree equation in 'a', if
  <!--{type="prop" sci="true" style="vertical-align:-3px;" input="a=sqrt x"}--> : </p>
</div>
<div key="text_youngest">
 <!--TODO-->
</div>
