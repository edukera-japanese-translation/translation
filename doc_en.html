<div class="pedagogic paper" key="exercise_description_demo_bernoulli_1">
 <!--{type="ex_title"}-->
 <p> <span class="txtwrap slide" style="padding-top:15px"> <img src="./img/demo_bernoulli_1.png"> </span> </p>
 <p> The powers of two are bound from above by the values of the exponent, i.e. that
  <!--{type="expr" input="(pow 2 n) >= (plus n 1)"}-->, as is illustrated in the graph opposite. </p>
 <center>
  <table class="borderblue">
   <colgroup>
    <col width="60">
    <col width="60">
    <col width="60">
   </colgroup>
   <tbody>
    <tr>
     <td><span class="bold">
       <!--{type="expr" input="n"}--></span></td>
     <td><span class="bold">
       <!--{type="expr" input="n+1"}--></span></td>
     <td><span class="bold">
       <!--{type="expr" input="2^n"}--></span></td>
    </tr>
    <tr>
     <td>
      <!--{type="expr" input="0"}--></td>
     <td>
      <!--{type="expr" input="1"}--></td>
     <td>
      <!--{type="expr" input="1"}--></td>
    </tr>
    <tr>
     <td>
      <!--{type="expr" input="1"}--></td>
     <td>
      <!--{type="expr" input="2"}--></td>
     <td>
      <!--{type="expr" input="2"}--></td>
    </tr>
    <tr>
     <td>
      <!--{type="expr" input="2"}--></td>
     <td>
      <!--{type="expr" input="3"}--></td>
     <td>
      <!--{type="expr" input="4"}--></td>
    </tr>
    <tr>
     <td>
      <!--{type="expr" input="3"}--></td>
     <td>
      <!--{type="expr" input="4"}--></td>
     <td>
      <!--{type="expr" input="8"}--></td>
    </tr>
    <tr>
     <td>...</td>
     <td>...</td>
     <td>...</td>
    </tr>
   </tbody>
  </table>
 </center>
 <p> This inequality is a specific example of <span class="exturl"><a href="https://en.wikipedia.org/wiki/Bernoulli%27s_inequality" target="_blank">Bernoulli’s inequalities</a></span>, demonstrated in the following exercise: </p>
 <p>
  <!--{type="exercise" input="demo_bernoulli_2"}--> </p>
 <p> <span class="light-bulb">ń</span> Use reasoning <span class="buttontheo">by induction</span>. </p>
</div>
<div class="pedagogic paper" key="exercise_description_demo_bernoulli_2">
 <!--{type="ex_title"}-->
 <p> These inequalities generalize the result see previously. They are attributed to the Swiss mathematician, <span class="exturl"><a href="https://en.wikipedia.org/wiki/Jacob_Bernoulli" target="_blank">Jacques Bernoulli</a></span>. We call them the <span class="exturl"><a href="https://en.wikipedia.org/wiki/Bernoulli%27s_inequality" target="_blank">Bernoulli’s inequality</a></span>. </p>
 <p> <span class="light-bulb">ń</span> Use reasoning by induction. </p>
</div>
<div class="pedagogic paper" key="exercise_description_ineq_ex_8">
 <!--{type="ex_title"}-->
</div>
<div class="pedagogic paper" key="exercise_description_logic_connector_abs_peirce">
 <!--{type="ex_title"}-->
 <p><span class="lock">w</span><span class="cons">Constructive logic</span></p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_connector_ex_easy_01">
 <!--{type="ex_title"}-->
 <p>We can demonstrate that disjunction is distributive <span class="stress">over conjunction</span>.</p>
 <p><span class="lock">w</span><span class="cons">Constructive logic</span></p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_connector_ex_easy_02">
 <!--{type="ex_title"}-->
 <p> It can be shown that conjunction is distributive <span class="stress">over disjunction</span>. </p>
 <p> <span class="lock">w</span><span class="cons">Constructive logic</span> </p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_connector_ex_easy_06">
 <!--{type="ex_title"}-->
 <p> In this exercise, the universe of elements is made up of all <span class="exturl"><a href="https://en.wikipedia.org/wiki/Natural_number" target="_blank">natural numbers</a></span>. </p>
 <p> The formulae are the <span class="stress">propositions defined on ℕ</span>, and the elements are the integers. </p>
 <p> Note "
  <!--{type="prop" sci="true" input="forall (x:Nvar), app_prop U P x"}-->" and "
  <!--{type="prop" sci="true" input="exists (x:Nvar), app_prop U P x"}-->" quantifications on ℕ. </p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_connector_ex_easy_08">
 <!--{type="ex_title"}-->
 <a href="https://en.wikipedia.org/wiki/The_School_of_Athens" target="_blank"><img class="txtwrap" src="./img/aristote-raphael-ecole-d-athenes.jpg" height="30%" width="30%"></a>
 <p> The <span class="exturl"><a href="https://en.wikipedia.org/wiki/Syllogism" target="_blank">syllogism</a></span> is a reasoning formalized in the 4<span class="sup">th</span> Century BC in <span class="exturl"><a href="https://en.wikipedia.org/wiki/Ancient_Greece" target="_blank">Ancient Greece</a></span> par <span class="exturl"><a href="https://en.wikipedia.org/wiki/Aristotle" target="_blank">Aristotle</a></span> who considered it a fundamental element of logic and reasoning. </p>
 <p> The syllogism served, and continues to serve, as a logical foundation to <span class="exturl"><a href="https://en.wikipedia.org/wiki/Law" target="_blank">Legislation</a></span>, born in <span class="exturl"><a href="https://en.wikipedia.org/wiki/Ancient_Rome#Republic" target="_blank">Ancient Rome</a></span>. It is the scheme on which legal judgements are constructed in western tradition. </p>
 <p>Let’s imagine, for example that a tribunal must respond to the question "Is Socrates mortal?". The answer lies in the discovery of un attribute "man". Let’s lay out the definitions:</p>
 <table class="slide">
  <colgroup>
   <col width="150">
   <col width="30">
   <col width="150">
  </colgroup>
  <tbody>
   <tr>
    <td style="padding-top: 10px; border-right: 1px solid whitesmoke; border-bottom: 1px solid whitesmoke;">Minor term</td>
    <td style="padding-top: 10px; border-right: 1px solid whitesmoke; border-bottom: 1px solid whitesmoke;">A</td>
    <td style="padding-top: 10px; border-bottom: 1px solid whitesmoke;">Socrates</td>
   </tr>
   <tr>
    <td style="border-right: 1px solid whitesmoke; border-bottom: 1px solid whitesmoke;">Middle term</td>
    <td style="border-right: 1px solid whitesmoke; border-bottom: 1px solid whitesmoke;">B</td>
    <td style="border-bottom: 1px solid whitesmoke;">being a man</td>
   </tr>
   <tr>
    <td style="border-right: 1px solid whitesmoke;">Major term</td>
    <td style="border-right: 1px solid whitesmoke;">C</td>
    <td>being mortal</td>
   </tr>
  </tbody>
 </table>
 <p>It is therefore judged following the schema below:</p>
 <table class="slide">
  <colgroup>
   <col width="200">
   <col width="90">
   <col width="250">
   <col width="250">
  </colgroup>
  <tbody>
   <tr>
    <td style="padding-top: 10px; border-right: 1px solid whitesmoke; border-bottom: 1px solid whitesmoke; vertical-align: middle;">Major premise</td>
    <td style="border-right: 1px solid whitesmoke; border-bottom: 1px solid whitesmoke; vertical-align: middle;">B ⇒ C</td>
    <td style="border-right: 1px solid whitesmoke; border-bottom: 1px solid whitesmoke; vertical-align: middle;"> All men are mortals. (man ⇒ mortal)</td>
    <td style="border-bottom: 1px solid whitesmoke; vertical-align: middle;">The rule of law</td>
   </tr>
   <tr>
    <td style="border-right: 1px solid whitesmoke; border-bottom: 1px solid whitesmoke; vertical-align: middle;">Minor premise</td>
    <td style="border-right: 1px solid whitesmoke; border-bottom: 1px solid whitesmoke; vertical-align: middle;">A ⇒ B</td>
    <td style="border-right: 1px solid whitesmoke; border-bottom: 1px solid whitesmoke; vertical-align: middle;">Socrates is a man.</td>
    <td style="border-bottom: 1px solid whitesmoke; vertical-align: middle;"> The legal qualification of the minor term (Socrates), which is subject to the proceedings.</td>
   </tr>
   <tr>
    <td style="border-right: 1px solid whitesmoke; border-bottom: 1px solid whitesmoke; vertical-align: middle;">Conclusion</td>
    <td style="border-right: 1px solid whitesmoke; border-bottom: 1px solid whitesmoke; vertical-align: middle;">A ⇒ C</td>
    <td style="border-right: 1px solid whitesmoke; border-bottom: 1px solid whitesmoke; vertical-align: middle;">Socrates is mortal.</td>
    <td style="border-bottom: 1px solid whitesmoke; vertical-align: middle;">The judgement</td>
   </tr>
  </tbody>
 </table>
 <p> The challenge the process presents is therefore qualifying (or not) the minor term (the accused) as a middle term. Learning the spirit of the laws (the meaning given to the laws) allows the judge to decide, by studying <span class="exturl"><a href="https://en.wikipedia.org/wiki/Case_law" target="_blank">case law</a></span> that is the set of court decisions. </p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_connector_ex_easy_12">
 <!--{type="ex_title"}-->
 <p>This implication is only true in classical logic. This poses no problem to its use in electronics : either the current flows or it doesn’t.</p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_connector_ex_easy_13">
 <!--{type="ex_title"}-->
 <a href="./img/Diopsis.jpg" target="_blank"><img class="txtwrap" src="./img/Diopsis.jpg" height="30%" width="30%"></a>
 <p>The <span class="exturl"><a href="https://en.wikipedia.org/wiki/De_Morgan%27s_laws" target="_blank">De Morgan's laws</a></span> are formulae that allow us to calculate the negation of any mathematical proposition.</p>
 <p>We can demonstrate that the negation of a disjunction is the conjunction of the negations of the operands.</p>
 <p>These laws are used in IT within the conception of <span class="exturl"><a href="https://en.wikipedia.org/wiki/Logic_gate" target="_blank">logical functions</a></span> and and their physical materialization, notably in the form of <span class="exturl"><a href="https://en.wikipedia.org/wiki/Integrated_circuit">integrated circuits</a></span>.</p>
 <p><span class="lock">w</span><span class="cons">Constructive logic</span></p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_connector_ex_easy_14">
 <!--{type="ex_title"}-->
 <p> A binary <span class="exturl"><a href="https://en.wikipedia.org/wiki/Operator_(mathematics)" target="_blank">operator</a></span> noted, for example, ★, is <span class="exturl"><a href="https://en.wikipedia.org/wiki/Associative_property" target="_blank">associative</a></span> if, whatever the <span class="exturl"><a href="https://en.wikipedia.org/wiki/Operand" target="_blank">operands</a></span> a b c : </p>
 <p>a ★ (b ★ c) = (a ★ b) ★ c</p>
 <p>Since their position is not important; brackets can be omitted. Hence the value above is written a ★ b ★ c. It is, for example, the associativity of addition that allows us to write 3 + 5 + 8 without the need for brackets.</p>
 <p> <span class="lock">w</span><span class="cons">Constructive logic</span> </p>
 <div class="slide">
  <p> <span class="light-bulb">ń</span> By definition, an equivalence is demonstrated by demonstrating two implications. Definition of <span class="buttontheo">equivalence</span> is chosen to demonstrate
   <!--{type="tag" input="s0"}-->. </p>
 </div>
</div>
<div class="custom pedagogic" key="exercise_description_logic_connector_ex_easy_16">
 <!--{type="ex_title"}-->
 <p> <span class="exturl"><a href="https://en.wikipedia.org/wiki/Contraposition" target="_blank">Contraposition</a></span>, or modus tollens, consists of demonstrating that A implies B, by demonstrating that the negation of B implies the negation of A: if B didn’t stand, A wouldn’t stand, therefore if A stands, then B stands. </p>
 <p> This reasoning only applies within <span class="stress">classical logic</span>. However, the inverse implication,
  <!--{type="prop" sci="true" input="(A -> B) -> (~B -> ~A)"}--> is true in constructive logic, as demonstrated in the following exercise. </p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_connector_ex_easy_17">
 <!--{type="ex_title"}-->
 <p><span class="lock">w</span><span class="cons">Constructive logic</span></p>
 <p>This way, the implication is demonstrated using constructive logic.</p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_connector_ex_easy_27">
 <!--{type="ex_title"}-->
 <p>Associativity of conjunction is demonstrated in a similar way to associativity of disjunction.</p>
 <div class="slide">
  <p> <span class="light-bulb">ń</span> Demonstrating disjunction of
   <!--{type="prop" sci="true" input="or A B"}--> requires <span class="stress">choosing</span> between the demonstration of A or B. </p>
  <p>The method consists of choosing as late as possible, and then exploiting all hypotheses (by disjunction of cases) in order to obtain the maximum amount of information that allows us to make the choice.</p>
 </div>
 <p> <span class="lock">w</span><span class="cons">Constructive logic</span> </p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_connector_ex_easy_31">
 <!--{type="ex_title"}-->
 <p> <span class="exturl"><a href="https://en.wikipedia.org/wiki/Reductio_ad_absurdum" target="_blank">Ad absurdium reasoning</a></span> consists of demonstrating a proposition A by showing that if its negation, ¬ A, is true, then we obtain a contradiction: </p>
 <table class="slide">
  <colgroup>
   <col width="100%">
  </colgroup>
  <tbody>
   <tr>
    <td><span class="def">Ad absurdium reasoning</span>
     <!--{type="prop" sci="true" input="forall A:Prop, ((~(~A)) -> A)"}--></td>
   </tr>
  </tbody>
  <tbody>
  </tbody>
 </table>
 <p> In effect,
  <!--{type="prop" sci="true" input="~(~A)"}--> can be re-written as
  <!--{type="prop" sci="true" input="(~A -> False)"}--> by definition of negation. Ad absurdium reasoning is therefore a law of elimination of double negation. </p>
 <p>This exercise demonstrates that the excluded middle involves ad absurdium reasoning.</p>
 <p> <span class="lock">w</span><span class="cons">Constructive logic</span> </p>
 <p>Reciprocal implication is demonstrated in the exercise below. As a result, ad absurdium reasoning is equivalent to the excluded middle, and is therefore not acknowledged by constructive logic:</p>
 <p>
  <!--{type="exercise" input="logic_quantifier_ex_le_48"}--> </p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_connector_ex_easy_32">
 <!--{type="ex_title"}-->
 <p>We can demonstrate that disjunction of two negations is the negation of conjunction of the propositions. This implication is made with constructive logic, but not the inverse implication, as shown in the next exercise.</p>
 <p> <span class="lock">w</span><span class="cons">Constructive logic</span> </p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_connector_ex_easy_33">
 <!--{type="ex_title"}-->
 <p>It can be demonstrated that disjunction is distributive <span class="stress">over implication</span>.</p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_connector_ex_easy_34">
 <!--{type="ex_title"}-->
 <p>It can be demonstrated that conjunction is "half distributive" over implication.</p>
</div>
<div class="pedagogic paper" key="exercise_description_logic_connector_peirce_abs_te">
 <!--{type="ex_title"}-->
 <p><span class="lock">w</span><span class="cons">Constructive logic</span></p>
</div>
<div class="pedagogic paper" key="exercise_description_logic_connector_peirce_law">
 <!--{type="ex_title"}-->
 <a href="https://en.wikipedia.org/wiki/Charles_Sanders_Peirce" target="_blank"><img class="txtwrap" src="./img/peirce.jpg" height="30%" width="30%"></a>
 <p> <span class="exturl"><a href="https://en.wikipedia.org/wiki/Peirce%27s_law" target="_blank">Peirce's law</a></span> is true in classical logic. <span class="exturl"><a href="https://en.wikipedia.org/wiki/Charles_Sanders_Peirce" target="_blank">Charles Sanders Peirce</a></span> was an American philosopher, logician and mathematician. </p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_connector_tuto_01">
 <!--{type="ex_title"}-->
 <p>What can be deduced from the conjunction "A ∧ B"?</p>
 <p>Follow the instructions to solve the problem.</p>
 <p> <span class="light-bulb">A</span>Each exercise has a conclusion and an initial context, which lays out the variables and the hypothesis. </p>
 <p> <span class="light-bulb">A</span>The conclusion and the hypothesis are <span class="exturl"><a href="https://en.wikipedia.org/wiki/Statement_(logic)" target="_blank">mathematical statements</a></span>. The objective is to come up with a series of statements, which make up the <span class="exturl"><a href="https://en.wikipedia.org/wiki/Mathematical_proof" target="_blank">proof</a></span> that the conclusion is true. </p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_quantifier_21">
 <!--{type="ex_title"}-->
 <p>In Scotland, a private club has the following rules:</p>
 <ul>
  <li>Every non-Scottish member wears red socks.</li>
  <li>Every member wears a kilt or doesn't wear red socks.</li>
  <li>The married members don't go out on Sunday.</li>
  <li>A member goes out on Sunday if and only if he is Scottish.</li>
  <li>Every member who wears a kilt is Scottish and married.</li>
  <li>Every Scottish member wears a kilt.</li>
 </ul>
 <p>Now, we show that these rules are so strict that no one can be accepted!</p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_quantifier_ex_03">
 <!--{type="ex_title"}-->
 <p>It is demonstrated that the complement of a union is the intersection of the complements.</p>
 <p>We call this formula a De Morgan law by analogy with the De Morgan laws established for conjunctions and disjunctions. There are indeed similarities between the properties (distributivity, associativity, commutativity) of the union, of the intersection and of the complement, and those of the disjunction, the conjunction and the negation respectively.</p>
 <p>This is a consequence of the definition of the set operators: belonging to a union of two sets is the disjunction of membership to each of the two sets.</p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_quantifier_ex_07">
 <!--{type="ex_title"}-->
 <p>The demonstration of the distributivity of the existential quantifier over disjunction is concluded.</p>
 <p> <span class="light-bulb">ń</span> It is necessary to generate the unknown witness variable <span class="button" style="font-family: 'Times New Roman'; font-weight: bold; font-size: 14px; padding: 3px;">x?</span> within the scope (or a sub-scope) that contains the variable(s) allowing us to figure out this unknown witness value. In this example, the witness value is provided within the scopes created <span class="buttontheo">by using disjunction of cases</span>. This reasoning is therefore used before reasoning <span class="buttontheo">by construction</span>. </p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_quantifier_ex_09">
 <!--{type="ex_title"}-->
 <p>It can be shown that the empty set <span class="exturl"><a href="https://en.wikipedia.org/wiki/Subset" target="_blank">subset</a></span> of any set.</p>
</div>
<div class="pedagogic paper" key="exercise_description_logic_quantifier_ex_easy_08">
 <!--{type="ex_title"}-->
 <p>What is the logical negation of a universal quantification?</p>
 <p>The negation of "for every x, F (x)" is not "for every x, not F (x)", but "there exists x such that F (x)".</p>
 <p>Here, one of the two implications is demonstrated.</p>
</div>
<div class="pedagogic paper" key="exercise_description_logic_quantifier_ex_easy_09">
 <!--{type="ex_title"}-->
 <p>What is the logical negation of an existential quantification?</p>
 <p>The negation of "there exists x, such that F (x)" is not "there exists x, such that not F (x)", but “for every value x, not F (x)".</p>
</div>
<div class="pedagogic paper" key="exercise_description_logic_quantifier_ex_le_01">
 <!--{type="ex_title"}-->
 <p>The binary relation on ℕ "is less than", noted
  <!--{type="prop" sci="true" input="app_rel rel_le x y"}-->, is defined in these exercises by an existential formula:</p>
 <table class="slide">
  <colgroup>
   <col width="100%">
  </colgroup>
  <tbody>
   <tr>
    <td> <span class="def">Is less than</span>
     <!--{type="prop" sci="true" input="forall (x y:Nvar), equiv (app_rel rel_le x y) (exists (z:Nvar),y=x+z)"}--> </td>
   </tr>
  </tbody>
  <tbody>
  </tbody>
 </table>
 <p>We can demonstrate that addition is increasing for this relation.</p>
 <p>"Is less than" exercises:</p>
 <p>
  <!--{type="exercise" input="logic_quantifier_ex_le_02"}-->
  <!--{type="exercise" input="logic_quantifier_ex_le_03"}--></p>
</div>
<div class="pedagogic paper" key="exercise_description_logic_quantifier_ex_le_02">
 <!--{type="ex_title"}-->
 <p>"Is less than" Exercises:</p>
 <p>
  <!--{type="exercise" input="logic_quantifier_ex_le_01"}-->
  <!--{type="exercise" input="logic_quantifier_ex_le_03"}--> </p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_quantifier_ex_le_04">
 <!--{type="ex_title"}-->
 <p> <span class="def">source : <span class="exturl"><a href="http://www.lri.fr/~paulin/MathInfo" target="_blank">TP 1 Eléments de logique</a></span></span> </p>
 <p>There are two kinds of people on a mysterious island. There are so-called honestants who always speak the truth, and the others are swindlecants who always lie.</p>
 <p> Show that if <span style="font-weight: bold">a</span> and <span style="font-weight: bold">b</span> are two people on the island and that if <span style="font-weight: bold">a</span> says that <span style="font-weight: bold">b</span> is lying, at least one of the two is a swindlecant. </p>
 <p> <span class="light-bulb">ń</span> The axiom <span class="buttontheo">speaking the truth or lying</span> is used to generate two cases: either <span style="font-weight: bold">a</span> is honestant, or <span style="font-weight: bold">a</span> is swindlecant. The theory "Honestants and Swindlecants" is made up of the following axioms: </p>
 <table class="slide">
  <colgroup>
   <col width="25%">
   <col width="75%">
  </colgroup>
  <tbody>
   <tr>
   </tr>
   <tr>
    <td style="vertical-align: top"><span class="def" style="padding-top: 20px">Honestants and Swindlecants</span></td>
    <td style="padding-top: 24px;">
     <!--{type="prop" input="forall (a:gbmember), (or (is_good a) (is_bad a))"}--></td>
   </tr>
   <tr>
    <td style="vertical-align: top; padding-top: 8px"><span class="def">The truth told by the honestant</span></td>
    <td>
     <!--{type="prop" style="padding-top: 20px" input="forall (a:gbmember) (P:Prop), (is_good a) -> (say a P) -> P"}--></td>
   </tr>
   <tr>
    <td style="vertical-align: top; padding-top: 8px"><span class="def">The lie told by the swindlecant</span></td>
    <td>
     <!--{type="prop" input="forall (a:gbmember) (P:Prop), (is_bad a) -> (say a P) -> (~ P)"}--></td>
   </tr>
  </tbody>
  <tbody>
  </tbody>
 </table>
</div>
<div class="custom pedagogic" key="exercise_description_logic_quantifier_ex_le_05">
 <!--{type="ex_title"}-->
 <p> <span class="def">source : <span class="exturl"><a href="http://www.lri.fr/~paulin/MathInfo" target="_blank">TP 1 Eléments de logique</a></span></span> </p>
 <p> Show that if <span style="font-weight: bold">a</span> says that <span style="font-weight: bold">a</span> and <span style="font-weight: bold">b</span> are both swindlecants, then <span style="font-weight: bold">a</span> is a swindlecant. </p>
 <p> "Honestants and Swindlecants" exercises: </p>
 <!--{type="exercise" input="logic_quantifier_ex_le_04"}-->
 <!--{type="exercise" input="logic_quantifier_ex_le_05"}-->
 <!--{type="exercise" input="logic_quantifier_ex_le_06"}-->
 <!--{type="exercise" input="logic_quantifier_ex_le_07"}-->
</div>
<div class="custom pedagogic" key="exercise_description_logic_quantifier_ex_le_06">
 <!--{type="ex_title"}-->
 <p> <span class="def">source : <span class="exturl"><a href="http://www.lri.fr/~paulin/MathInfo" target="_blank">TP 1 Eléments de logique</a></span></span> </p>
 <p> Show that if <span style="font-weight: bold">a</span> says
  <!--{type="expr" input="False"}--> then he is a swindlecant. </p>
 <p></p> Exercises "Honestants and Swindlecants" :
 <p></p>
 <!--{type="exercise" input="logic_quantifier_ex_le_04"}-->
 <!--{type="exercise" input="logic_quantifier_ex_le_05"}-->
 <!--{type="exercise" input="logic_quantifier_ex_le_06"}-->
 <!--{type="exercise" input="logic_quantifier_ex_le_07"}-->
</div>
<div class="custom pedagogic" key="exercise_description_logic_quantifier_ex_le_07">
 <!--{type="ex_title"}-->
 <p> <span class="def">source : <span class="exturl"><a href="http://www.lri.fr/~paulin/MathInfo" target="_blank">TP 1 Eléments de logique</a></span></span> </p>
 <p>Show that a person living on the island cannot say that he himself is a swindlecant.</p>
 <p></p> Exercises "Honestants and Swindlecants" :
 <p></p>
 <!--{type="exercise" input="logic_quantifier_ex_le_04"}-->
 <!--{type="exercise" input="logic_quantifier_ex_le_05"}-->
 <!--{type="exercise" input="logic_quantifier_ex_le_06"}-->
 <!--{type="exercise" input="logic_quantifier_ex_le_07"}-->
</div>
<div class="pedagogic paper" key="exercise_description_logic_quantifier_ex_le_13">
 <!--{type="ex_title"}-->
 <!--  <a href="https://fr.wikipedia.org/wiki/Principe_des_tiroirs" target="_blank"><img class="txtwrap" src="http://img.1.im6.fr/03E8000007913469-photo-dressing-tiroir-casiers-chaussettes.jpg" height="30%" width="30%"></img></a> -->
 <span class="def">source : <span class="exturl"><a href="http://www.lri.fr/~paulin/MathInfo" target="_blank">TP 2 Relations et fonctions</a></span></span>
 <p> In 1834, the German mathematician <span class="exturl"><a href="https://en.wikipedia.org/wiki/Peter_Gustav_Lejeune_Dirichlet" target="_blank">Johann Dirichlet</a></span> announced the <span class="exturl"><a href="https://en.wikipedia.org/wiki/Pigeonhole_principle" target="_blank">pigeonhole principle</a></span>, which applies to the case in which n pigeons occupy m holes: </p>
 <p style="align: center; font-style: italic">If n &gt; m, then at least one hole must contain strictly more than one pigeon.</p>
 <p> In other words, by <span class="exturl"><a href="https://en.wikipedia.org/wiki/Contraposition" target="_blank">contraposition</a></span>, if each hole contains at the most one pigeon, then n &lt;= m. </p>
 <p> Let’s consider <span class="stress">the storage function</span> of n+1 pigeons, indexed from 0 to n, in holes: this function takes the index of a pigeon as argument, and returns an index of a hole. The assumption that a hole contains at the most one pigeon, translates into f being an <span class="stress">injective function</span> (the fiber of a hole has at most one element). Furthermore, given that by hypothesis, m holes contain the pigeons, there is one pigeon, indexed x, such that f(x)=m. </p>
 <p>Demonstrating the pigeonhole principle therefore consists of demonstrating that if the function f is injective over the set [0 ... n], then there is one pigeon numbered x, such that its hole, f(x), is greater or equal to n.</p>
 <p>To simplify this, we can reason with a notion stronger than injectivity and consider strictly increasing functions:</p>
 <table class="slide">
  <colgroup>
   <col width="100%">
  </colgroup>
  <tbody>
   <tr>
    <td>
     <!--{type="prop" sci="true" input=" forall (n:Nvar) (f:NvarFun), equiv (FFMono n f) (forall (x y:Nvar), ExprLT x y -> ExprLT y n -> ExprLT (app_fun f x) (app_fun f y))"}--></td>
   </tr>
  </tbody>
  <tbody>
  </tbody>
 </table>
 <p>Opposite, it is demonstrated that the strict increase is a stronger condition than injectivity over [0 ... n], which is expressed here in the following way :</p>
 <table class="slide">
  <colgroup>
   <col width="100%">
  </colgroup>
  <tbody>
   <tr>
    <td>
     <!--{type="prop" sci="true" input="forall (n:Nvar) (f:NvarFun), equiv (FFInj n f) (forall (x y:Nvar), ExprLT x n -> ExprLT y n -> app_fun f x = app_fun f y -> nvar x = nvar y)"}--></td>
   </tr>
  </tbody>
  <tbody>
  </tbody>
 </table>
 <p>The pigeonhole principle is demonstrated in the following exercise, following the strict increase of the storage function.</p>
 <p> </p>
 <h3>Solution</h3>
 <p> <span class="light-bulb">ń</span> Use a case base reasoning with the help of
  <!--{type="tag" input="2"}-->. </p>
 <p>Use theorems below on equalities and inequalities:</p>
 <table class="slide">
  <colgroup>
   <col width="100%">
  </colgroup>
  <tbody>
   <tr>
    <td><span class="def">Symmetry</span>
     <!--{type="prop" sci="true" input="forall (x y:O1U), (equiv (x=y) (y=x))"}--><br><br>
     <!--{type="prop" sci="true" input="forall (x y:O1U), (equiv (x<>y) (y<>x))"}--></td>
   </tr>
  </tbody>
  <tbody>
  </tbody>
 </table>
 <table class="slide">
  <colgroup>
   <col width="100%">
  </colgroup>
  <tbody>
   <tr>
    <td><span class="def">Inequality rewritings</span>
     <!--{type="prop" sci="true" input="forall (x y:O1U), (equiv (ExprGT x y) (ExprLT y x))"}--><br><br>
     <!--{type="prop" sci="true" input="forall (x y:O1U), (equiv (ExprGTEQ x y) (ExprLTEQ y x))"}--></td>
   </tr>
  </tbody>
  <tbody>
  </tbody>
 </table>
 <table class="slide">
  <colgroup>
   <col width="100%">
  </colgroup>
  <tbody>
   <tr>
    <td><span class="def">Strict inequality</span>
     <!--{type="prop" sci="true" input="forall (x y:O1U), (ExprGT x y) -> (x <> y)"}--><br><br>
     <!--{type="prop" sci="true" input="forall (x y:O1U), (ExprLT x y) -> (x <> y)"}--></td>
   </tr>
  </tbody>
  <tbody>
  </tbody>
 </table>
</div>
<div class="pedagogic paper" key="exercise_description_logic_quantifier_ex_le_14">
 <!--{type="ex_title"}-->
 <span class="def">source : <span class="exturl"><a href="http://www.lri.fr/~paulin/MathInfo" target="_blank">TP 2 Relations et fonctions</a></span></span>
 <p>The pigeonhole principle is presented in the previous exercise. It is do with demonstrating that if a function is injective over [0 .. n], then there exists x in [0 ... n] such that f(x) ≥ n.</p>
 <p> We have previously demonstrated that a sufficient condition for being injective over [0 ... n] is to be strictly increasing over [0 ... n]. </p>
 <p>The pigeonhole principle is demonstrated opposite, using a strictly increasing function as the hypothesis.</p>
 <div class="slide">
  <p> <span class="light-bulb">ń</span> Use reasoning by recurrence over n. </p>
 </div>
 <p>The theorems below enable us to transform an inequality between two integers to a strcit inequality, and vice versa:</p>
 <table class="slide">
  <colgroup>
   <col width="100%">
  </colgroup>
  <tbody>
   <tr>
    <td><span class="def">Transition to the next integer</span>
     <!--{type="prop" sci="true" input="forall (x y:O1U), (equiv (ExprGT x y) (ExprGTEQ x (y+1)))"}--><br><br>
     <!--{type="prop" sci="true" input="forall (x y:O1U), (equiv (ExprGTEQ x y) (ExprGT (x+1) y))"}--></td>
   </tr>
  </tbody>
  <tbody>
  </tbody>
 </table>
 <p>The different forms of transitivity of comparison operators also enable us to introduce or eliminate strict inequalities from inequalities, and vice versa:</p>
 <table class="slide">
  <colgroup>
   <col width="100%">
  </colgroup>
  <tbody>
   <tr>
    <td><span class="def">Transitivity</span>
     <!--{type="prop" sci="true" input="forall (x y z:O1U), (ExprGT x y) -> (ExprGT y z) -> (ExprGT x z)"}--><br><br>
     <!--{type="prop" sci="true" input="forall (x y z:O1U), (ExprGTEQ x y) -> (ExprGT y z) -> (ExprGT x z)"}--><br><br>
     <!--{type="prop" sci="true" input="forall (x y z:O1U), (ExprGT x y) -> (ExprGTEQ y z) -> (ExprGT x z)"}--><br><br>
     <!--{type="prop" sci="true" input="forall (x y z:O1U), (ExprGTEQ x y) -> (ExprGTEQ y z) -> (ExprGTEQ x z)"}--><br><br>
     <!--{type="prop" sci="true" input="forall (x y z:O1U), (ExprGT x y) -> (ExprGTEQ y z) -> (ExprGTEQ x z)"}--><br><br>
     <!--{type="prop" sci="true" input="forall (x y z:O1U), (ExprGTEQ x y) -> (ExprGT y z) -> (ExprGTEQ x z)"}--></td>
   </tr>
  </tbody>
  <tbody>
  </tbody>
 </table>
</div>
<div class="custom pedagogic" key="exercise_description_logic_quantifier_ex_le_27">
 <!--{type="ex_title"}-->
 <p>This result is available in the other exercises, as <span class="buttontheo">set characterization</span> of a transitive relation.</p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_quantifier_ex_le_31">
 <!--{type="ex_title"}-->
 <p> <span class="light-bulb">ń</span> Use the characterization of a transitive relation, and the conservation of inclusion by composition. </p>
 <p> <span class="light-bulb">A</span>Selecting a term in a proposition with the cursor allows you to replace it with another term; it is therefore necessary to prove that it is equal to the original term. </p>
 <h3>Also see</h3>
 <p>
  <!--{type="exercise" input="logic_quantifier_ex_le_27"}-->
  <!--{type="exercise" input="logic_quantifier_ex_le_47"}--> </p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_quantifier_ex_le_47">
 <!--{type="ex_title"}-->
 <p>Composition conserves inclusion.</p>
 <p> This result is available in other exercises, as "combination by <span class="buttontheo">composition</span>" rule. </p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_quantifier_ex_le_48">
 <!--{type="ex_title"}-->
 <p>The law of excluded middle is demonstrated by assuming ad absurdium rule (double negation elimination).</p>
 <p><span class="lock">w</span><span class="cons">Constructive logic</span></p>
</div>
<div class="pedagogic paper" key="exercise_description_logic_quantifier_ex_le_71">
 <!--{type="ex_title"}-->
 <p>Mrs. Muddled has three children, Alice, Bill, and Carl.</p>
 <p>When asked her 3 children's ages, Mrs. Muddled said that Alice is the youngest unless Bill is, and that if Carl isn't the youngest then Alice is the oldest.</p>
 <p> Who is the oldest and who is the youngest?</p>
 <h3>Theory</h3>
 <p>Information given by Mrs. Muddled is provided by assumptions <span class="propid">4</span> et <span class="propid">5</span></p>
 <p>There’s some implicit meaning in the superlative words “youngest” and “oldest” provided by the following rules : </p>
 <table class="slide">
  <colgroup>
   <col width="100%">
  </colgroup>
  <tbody>
   <tr>
    <td> <span class="def">Antonymy</span>
     <!--{type="prop" input="forall (x:Child), (Youngest x) -> (~(Oldest x))"}--><br><br>
     <!--{type="prop" input="forall (x:Child), (Oldest x) -> (~(Youngest x))"}--> </td>
   </tr>
  </tbody>
  <tbody>
  </tbody>
 </table>
 <p>Finally, “youngest” and “oldest” are opposites. Since there is more than one child, no one can be both.</p>
 <table class="slide">
  <colgroup>
   <col width="100%">
  </colgroup>
  <tbody>
   <tr>
    <td> <span class="def">Uniqueness</span>
     <!--{type="prop" input="forall (x y:Child), (x <> y) -> (Youngest x) -> (~(Youngest y))"}--><br><br>
     <!--{type="prop" input="forall (x y:Child), (x <> y) -> (Oldest x) -> (~(Oldest y))"}--> </td>
   </tr>
  </tbody>
  <tbody>
  </tbody>
 </table>
</div>
<div class="pedagogic paper" key="exercise_description_logic_quantifier_ex_le_72">
 <!--{type="ex_title"}-->
</div>
<div class="pedagogic paper" key="exercise_description_sigma_ex_15">
 <!--{type="ex_title"}-->
</div>
<div class="pedagogic paper" key="exercise_description_sigma_ex_16">
 <!--{type="ex_title"}-->
</div>
<div key="help_description_icon_exercises_check">
 <p>exercise solved. Click 'Start' to load the solution.</p>
</div>
<div key="help_description_icon_exercises_difficulty">
 <p>difficulty level from 0 (easy) -to 3 (hard).</p>
</div>
<div key="help_description_icon_exercises_lighbulb">
 <p>Solution hints (tutorial exercises provide this service)</p>
</div>
<div key="help_description_icon_exercises_lock">
 <p>Lock. Obtain the 'tutorial' cockade of current chapter (and possibly prerequisite chapters) to unblock exercise.</p>
</div>
<div key="help_description_icon_trophy_all">
 <p>The 'universal' cockade is obtained when all exercises of the chapter are solved.</p>
</div>
<div key="help_description_icon_trophy_diagnostic">
 <p>The 'express' cockade is obtained when all exercises marked 'express' are resolved. As a result, chapter theorems are available in the diagnosis window.</p>
</div>
<div key="help_description_icon_trophy_tutorial">
 <p>The 'tutorial' cockade is obtained when all tutorial exercises are solved.</p>
</div>
<div key="help_description_icon_trophy_unavoidable">
 <p>The cockade 'unavoidable' is obtained when all the exercises marked 'unavoidable' of the chapter are solved.</p>
</div>
<div key="help_description_shortcut_browsing_left_scope">
 <p>Display scope to the left of current the scope</p>
</div>
<div key="help_description_shortcut_browsing_lower_prop">
 <p>Move focus to the statement below</p>
</div>
<div key="help_description_shortcut_browsing_open_scope">
 <p>Open justification scope</p>
</div>
<div key="help_description_shortcut_browsing_redo">
 <p>Redo proof step</p>
</div>
<div key="help_description_shortcut_browsing_right_scope">
 <p>Display scope to the right of the current scope</p>
</div>
<div key="help_description_shortcut_browsing_undo">
 <p>Undo last proof step</p>
</div>
<div key="help_description_shortcut_browsing_upper_prop">
 <p>Move focus to the statement above</p>
</div>
<div key="help_description_shortcut_commutativity_commut_left">
 <p>Select term on the left</p>
</div>
<div key="help_description_shortcut_commutativity_commut_mode">
 <p>Activate keybaord commutative mode</p>
</div>
<div key="help_description_shortcut_commutativity_commut_right">
 <p>Select term on the right</p>
</div>
<div key="help_description_shortcut_commutativity_commut_shift_left">
 <p>Move selected term to the left</p>
</div>
<div key="help_description_shortcut_commutativity_commut_shift_right">
 <p>Move selected term to the right</p>
</div>
<div key="help_description_shortcut_commutativity_enter_commut">
 <p>Apply terms reordering</p>
</div>
<div key="help_description_shortcut_commutativity_esc_commut">
 <p>Exit keyboard commutative mode</p>
</div>
<div key="help_description_shortcut_evar_enter_evar">
 <p>Assign a value to a proof variable</p>
</div>
<div key="help_description_shortcut_evar_esc_evar">
 <p>Exit keyboard proof variable mode</p>
</div>
<div key="help_description_shortcut_evar_evar_left">
 <p>Select previous proof variable</p>
</div>
<div key="help_description_shortcut_evar_evar_mode">
 <p>Activate keyboard proof variable mode</p>
</div>
<div key="help_description_shortcut_evar_evar_right">
 <p>Select next proof variable</p>
</div>
<div key="help_description_shortcut_proof_context">
 <p>Show / hide context (statements from other scopes available for deduction) </p>
</div>
<div key="help_description_shortcut_proof_deduce">
 <p>Open diagnostic window in deduction</p>
</div>
<div key="help_description_shortcut_proof_enter">
 <p>Perform one of the following:</p>
 <ul>
  <li style="font-size:14px">Open diagnostic window in deduction if the statement is justified</li>
  <li style="font-size:14px">Open diagnostic window in justification if the statement is not justified</li>
  <li style="font-size:14px">Unify statement</li>
 </ul>
</div>
<div key="help_description_shortcut_proof_justify">
 <p>Perform one of the following:</p>
 <ul>
  <li style="font-size:14px">Open diagnostic window in justification if the statement is not justified</li>
  <li style="font-size:14px">Display justification theorem in the toolbox if the proposal is justified</li>
 </ul>
</div>
<div key="help_description_shortcut_selection_enter_select">
 <p>Open diagnostics window to rewrite selected term</p>
</div>
<div key="help_description_shortcut_selection_esc_select">
 <p>Exit keybaord selection mode</p>
</div>
<div key="help_description_shortcut_selection_group_select">
 <p>Mark selected term as group (keep intact the term during rewriting)</p>
</div>
<div key="help_description_shortcut_selection_select_down">
 <p>Select first argument</p>
</div>
<div key="help_description_shortcut_selection_select_left">
 <p>Select previous argument</p>
</div>
<div key="help_description_shortcut_selection_select_mode">
 <p>Activate keyboard selection mode</p>
</div>
<div key="help_description_shortcut_selection_select_right">
 <p>Select next argument</p>
</div>
<div key="help_description_shortcut_selection_select_shift_left">
 <p>Increase selection with term on the left</p>
</div>
<div key="help_description_shortcut_selection_select_shift_right">
 <p>Increase selection with next terme</p>
</div>
<div key="help_description_shortcut_selection_select_up">
 <p>Select the function whose argument is selected term</p>
</div>
<div key="help_description_shortcut_unification_enter_union">
 <p>Unify with selected statement</p>
</div>
<div key="help_description_shortcut_unification_esc_union">
 <p>Exit keyboard unification mode</p>
</div>
<div key="help_description_shortcut_unification_left_union">
 <p>Select left statement</p>
</div>
<div key="help_description_shortcut_unification_right_union">
 <p>Select right statement</p>
</div>
<div key="help_description_shortcut_unification_union_mode">
 <p>Activate keyboard unfication mode</p>
</div>
<div key="help_section_description_browsing">
 <p>The proof is presented in the style of natural deduction: justified statements are positioned on top of each other; assumptions are on top, and the conclusion is the last statement.</p>
 <p>A justification is a theorem applied to statements above justified statement. A justification may also be a proof, which is then in another scope (represented by a tab).</p>
 <p>One can navigate in the paper with the cursor, or with the keyboard thanks to keyboard shortcuts below:</p>
</div>
<div key="help_section_description_commutativity">
 <p>When choosing commutative rewriting, one can reorder the terms with the curor by drag-and-drop, or with the keyboard thanks to keyboard shortcuts below:</p>
</div>
<div key="help_section_description_evar">
 <p>Proof variables may appear when applying a theorem (a proof varaible is represented with a blue tag)</p>
 <p>On can assign a value to a proof variable by clicking on it, or with keyboard shortcuts below:</p>
</div>
<div key="help_section_description_exercises">
 <!--TODO-->
</div>
<div key="help_section_description_proof">
 <p>Several proof actions are possible:</p>
 <ul>
  <li style="font-size:14px">Justify (if the proposal is not already justified)</li>
  <li style="font-size:14px">Unify (if unifiable statements are proposed)</li>
  <li style="font-size:14px">Deduce</li>
  <li style="font-size:14px">Delete (if the proposal is not used by any justification)</li>
  <li style="font-size:14px">Move by dragging and dropping the index tag of the statement (as long as the deductive style is respected : a statement used by a justification can only be above justified statement)</li>
 </ul>
 <p>Keyboard shortcuts are available:</p>
</div>
<div key="help_section_description_selection">
 <p>Selecting a term allows to rewrite it (development, factoring, ...)</p>
 <p>Term selection is done either with the cursor or with keyboard shortcuts below:</p>
</div>
<div key="help_section_description_trophy">
 <!--TODO-->
</div>
<div key="help_section_description_unification">
 <p>When several unifications are possible, select the appropriate statement with the cursor or with keyboard shortcuts below:</p>
</div>
<div key="pager_account"></div>
<div class="pager" key="pager_algebra">
 <a href="https://fr.wikipedia.org/wiki/%C3%89variste_Galois" target="_blank"><img class="txtwrap" src="./img/Evariste_galois.jpg" height="20%" width="20%"></a>
 <p>Les <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Structure_alg%C3%A9brique" target="_blank">structures algébriques</a></span> sont les objets d'étude de ce chapitre.</p>
 <p> Au début du XIX<span class="sup">ème</span> siècle, <span class="exturl"><a href="https://fr.wikipedia.org/wiki/%C3%89variste_Galois" target="_blank">Evariste Galois</a></span> introduit le concept de <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Groupe_(math%C3%A9matiques)" target="_blank">groupe</a></span>. </p>
</div>
<div key="pager_algebra_structures"></div>
<div class="pager" key="pager_analysis">
 <a href="https://fr.wikipedia.org/wiki/Augustin_Louis_Cauchy" target="_blank"><img class="txtwrap" src="./img/Augustin-Louis_Cauchy_1901.jpg" height="12%" width="12%"></a>
 <p> Au cours du 19<span class="sup">ème</span> siècle, les mathématiciens posent les bases de l’analyse des propriétés des fonctions réelles (fonctions à valeur réelle) : continutité, convergence, limite, dérivation, intégration, ... </p>
 <p></p>
 <p> En France dès le début du siècle, <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Augustin_Louis_Cauchy" target="_blank">Augustin Louis Cauchy</a></span> étudie notamment les propriétés de convergence des suites croissantes positives, introduites dans ce chapitre. En Allemagne, <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Bernhard_Riemann" target="_blank">Bernhard Riemann</a></span> et <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Karl_Weierstrass" target="_blank">Karl Weierstrass</a></span> élaborent les théories de l’intégration et des limites de fonction. </p>
</div>
<div class="pager" key="pager_analysis_induction">
 <p> Le <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Raisonnement_par_r%C3%A9currence" target="_blank">raisonnement par récurrence</a></span> est un raisonnement incontournable, simple et puissant. Il permet de démontrer qu’une proposition P(n), dépendant d’un indice n, est vraie quelle que soit la valeur de l’indice, c’est à dire notamment vraie pour une infinité de valeurs de l’indice n. </p>
 <p> Par exemple, sans le raisonnement par récurrence, il faudrait une infinité de calculs (ou une très grande quantité) pour avoir la certitude (ou quasi-certitude) que la proposition “
  <!--{type="expr" input="4^n - 1"}--> est divisible par 3” est vraie quelle que soit la valeur de n, alors qu’un raisonnement par récurrence donne la certitude en quelques lignes de démonstration. </p>
</div>
<div class="pager" key="pager_analysis_limits">
 <p>La limite d’une fonction en un point ou en l’infini est introduite formellement. La méthode de calcul par composition de limites est présentée : par exemple, sous certaines conditions, la limite d’une somme est la somme des limites. Cette méthode permet de calculer la limite de n’importe quelle fonction par décomposition en fonctions élémentaires, dont on connaît les valeurs limites. </p>
</div>
<div class="pager" key="pager_analysis_series">
 <p> Une suite est une fonction de ℕ dans ℝ. On introduit ici quelques propriétés fondamentales des ces fonctions : </p>
 <ul>
  <li>croissance, décroissance</li>
  <li>majoration, minoration</li>
  <li>convergence, divergence</li>
 </ul>
</div>
<div key="pager_badges"></div>
<div key="pager_credits"></div>
<div key="pager_dashboard"></div>
<div class="custom pager" key="pager_demo_seg">
 <p>Calculus is about transforming an equality relation (or inequality), between real numbers or vectors for example. The challenge is to work out a sequence of algebraic manipulations (factorize, expand, ...) from assumption(s) to conclusion.</p>
</div>
<div class="pager" key="pager_eq_seg">
 <p>Une égalité peut se transformer, notamment à l’aide des transformations introduites dans ce chapitre :</p>
 <ul>
  <li>les opérations à gauche et à droite, qui permettent de “passer un terme de l’autre côté” en changeant son signe</li>
  <li>les combinaisons d’égalité, qui permettent typiquement de résoudre des systèmes d’équation</li>
  <li>le passage au carré, ou le passage à la racine carrée (si la valeur est positive), ...</li>
 </ul>
</div>
<div class="pager" key="pager_ineq_seg">
 <p>Les inégalités comparent deux nombres réels. Elles se transforment de manière similaire aux égalités :</p>
 <ul>
  <li>opérations à gauche et à droite</li>
  <li>combinaisons (addition, soustraction)</li>
  <li>applications de fonctions (opposé, carré, racine, …)</li>
  <li>…</li>
 </ul>
 <p>Si la transformation appliquée à gauche et à droite d’une inégalité est une fonction décroissante, le sens de l’inégalité entre les valeurs obtenues est inversé.</p>
</div>
<div class="pager" key="pager_logic">
 <p> The grammar of <span class="exturl"><a href="https://en.wikipedia.org/wiki/Propositional_calculus" target="_blank">propositions</a></span>, and associated reasoning rules, form a logical system called <span class="exturl"><a href="https://en.wikipedia.org/wiki/Natural_deduction" target="_">natural deduction</a></span>, notably used for developing mathematical <span class="exturl"><a href="https://en.wikipedia.org/wiki/Mathematical_proof" target="_blank">demonstrations</a></span>. </p>
 <p>This system is valuable because it is independent from the theory studied. A theory is the set of axioms (acknowledged theorems) defining objects and their properties.</p>
</div>
<div class="pager" key="pager_logic_connector">
 <p>Logical connectors are fundamental elements for forming mathematical propositions from two propositions, whatever A and B are:</p>
 <ul>
  <li>implication, A implies B, noted "A ⇒ B"</li>
  <li>conjunction, A and B, noted "A ∧ B"</li>
  <li>disjunction, A or B, noted "A ∨ B"</li>
  <li>negation, not A, noted "¬ A"</li>
 </ul>
 <p>Each of these connectors is associated with two rules:</p>
 <ul>
  <li>a rule to justify (or demonstrate) the proposition: how can we justify "A ∧ B" ?</li>
  <li>a rule to deduce a new proposition: what can we deduce from "A ∧ B" ?</li>
 </ul>
</div>
<div class="pager" key="pager_logic_function">
 <p>A function f is a formula that has a value x, such that the proposition "y=f(x)" is a functional relation of x and y.</p>
</div>
<div class="pager" key="pager_logic_quantifier">
 <p>Mathematical propositions can also be formulae with variables taking on certain values: for example "3 is a prime number" can be considered as the formula "x is a prime number" where the variable "x" is replaced by "3".</p>
 <p> For a formula with a variable, we need to express that the proposition is true <span class="stress" style="font-size: 16px">for every</span> value the variable assumes, or that <span class="stress" style="font-size: 16px">there exists</span> at least one value for which the proposition is true. These new elements language are the quantifiers. </p>
</div>
<div class="pager" key="pager_logic_relation">
 <p>Relations, omnipresent in mathematics, are formulae that relate two values belonging to two, potentially different, universes. We talk about binary relation when the values belong to the same universe.</p>
 <p>The characterization of relations, as well as their properties, are presented.</p>
</div>
<div class="pager" key="pager_rewrite_seg">
 <p>Les réécritures permettent de déduire d’une égalité, une égalité presque identique dans laquelle un terme
  <!--{type="expr" input="a"}--> est remplacé par un terme
  <!--{type="expr" input="b"}-->, à condition que
  <!--{type="prop" sci="true" style="vertical-align:-3px;" input="a = b"}-->. Les réécritures de a en b sont données par le calcul algébrique :</p>
 <ul>
  <li>factorisation, développement</li>
  <li>idéntitiés remarquables</li>
  <li>simplifications</li> ...
 </ul>
 <p>Par exemple, on peut déduire de
  <!--{type="prop" sci="true" style="vertical-align:-3px;" input="x=(2*(x-1))"}--> la proposition
  <!--{type="prop" sci="true" style="vertical-align:-3px;" input="x= (2*x) - 2"}--> en remplaçant le terme
  <!--{type="expr" input="2*(x-1)"}--> par
  <!--{type="expr" input="minus (2*x) 2"}--> ; on sait en effet que
  <!--{type="prop" sci="true" style="vertical-align:-3px;" input="(2*(x-1)) = ((2*x)-2)"}--> par développement.</p>
</div>
<div class="pager" key="pager_set_operators">
 <p>A set E is a collection of objects that are called <span class="stress" style="font-size:16px">the elements</span> of E.</p>
 <p>The proposition that an element x belongs to E, or is an element of E, is noted <span class="stress" style="font-size:16px">
   <!--{type="prop" sci="true" input="sis_element x E"}--></span>. The negation of membership, ¬(
  <!--{type="prop" sci="true" input="sis_element x E"}-->), is noted <span class="stress" style="font-size:16px">
   <!--{type="prop" sci="true" input="~sis_element x E"}--></span>. </p>
 <p>A <span class="exturl"><a href="https://en.wikipedia.org/wiki/Set_(mathematics)" target="blank">set operator</a></span> allows us to construct one set from other sets.</p>
</div>
<div class="pager" key="pager_set_rewoperators">
 <p>Les calculs algébriques sur les ensembles ressemblent aux calculs sur les nombres parce que : </p>
 <ul>
  <li>les opérations ensemblistes (intersection, union, ...) ont des propriétés similaires aux opérations numériques (addition, multiplication, ...) : associativité, commutativité, distributivité, ... </li>
  <li>l'égalité ensembliste et l'égalité numérique sont des relations d'équivalence qui sont transitives, symétriques et réflexives (voir section suivante)</li>
 </ul>
 <p>L'algèbre ensembliste est équivalente à l'<span class="exturl"><a href="https://fr.wikipedia.org/wiki/Alg%C3%A8bre_de_Boole_(logique)" target="_blank">agèbre booléenne</a></span> : soit un élement appartient à un ensemble, soit il n'y appartient pas. Cette algèbre est centrale en informatique, dans l'écriture des programmes et dans l'élaboration des circuits électroniques. </p>
</div>
<div class="pager" key="pager_settheory">
 <a href="https://en.wikipedia.org/wiki/Georg_Cantor" target="_blank"><img class="txtwrap" src="./img/cantor.jpg" height="12%" width="12%"></a>
 <p> At the end of the 19<span class="sup">th</span> Century, the German mathematician <span class="exturl"><a href="https://en.wikipedia.org/wiki/Georg_Cantor" target="_blank">Georg Cantor</a></span> developed the <span class="exturl"><a href="https://en.wikipedia.org/wiki/Set_theory" target="_blank">set theory</a></span>. This theory allows us to define fundamental elements of mathematics, notably integers, real numbers, functions ... </p>
 <p>In 1930, The Austro-Hungarian mathematician, <span class="exturl"><a href="https://en.wikipedia.org/wiki/Kurt_G%C3%B6del" target="_blank">Kurt Gödel</a></span> even demonstrated that any theory can be translated into the set theory. </p>
</div>
<div class="pager" key="pager_sigma_seg">
 <p>La notation sigma sert à faire la somme des termes d’une série de n nombres indéxés notés
  <!--{type="expr" input="app_series a i"}--> (avec l'indice i compris entre 1 et n typiquement). Cette somme se note :
  <!--{type="expr" style="vertical-align: -4px;" input="(sigma(k,1,n,(app_series a k)))"}-->.</p>
 <p>Dans cette notation, l'indice k est une variable muette : elle n'est pas déclarée dans le contexte et n'est valable que pour l'expression sommée.</p>
 <p>Les propriétés du sigma sont celles de l’addition (associativité, distributivité de la multiplication, …) et celles des changements d’écriture de l’indexation des nombres sommés.</p>
</div>
<div key="slide_demo_tuto_sigma_(( sigma( k, zero, zero, k)) = (zero * (zero + 1)) / 2)">
 <!-- 	(( sigma( k, zero, zero, k)) = (zero * (zero + 1)) / 2)
	by Backward select of select ( sigma( k, zero, zero, k)) = (zero * (zero + 1)) / 2 (sigmasimpl)
 -->
 <div expr="(( sigma( k, zero, zero, k)) = (zero * (zero + 1)) / 2)" class="pedagogic slide" exercise="demo_tuto_sigma">
 </div>
</div>
<div key="slide_demo_tuto_sigma_((forall n : Nvar, ( sigma( k, zero, n, k)) = (n * (n + 1)) / 2))">
 <!-- 	((forall n : Nvar, ( sigma( k, zero, n, k)) = (n * (n + 1)) / 2))
	by Backward (elim_true_at_rank)
 -->
 <div expr="((forall n : Nvar, ( sigma( k, zero, n, k)) = (n * (n + 1)) / 2))" class="pedagogic slide" exercise="demo_tuto_sigma">
 </div>
</div>
<div key="slide_demo_tuto_sigma_((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)))">
 <!-- 	((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)))
	by Section
 -->
 <div expr="((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)))" class="pedagogic slide" exercise="demo_tuto_sigma">
 </div>
</div>
<div key="slide_demo_tuto_sigma_((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)),( sigma( k, zero, n + 1, k)) = ((n * (n + 1)) / 2 + n) + 1,reducedenom,0)">
 <!-- 	((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)),( sigma( k, zero, n + 1, k)) = ((n * (n + 1)) / 2 + n) + 1,reducedenom,0)
	by Forward select of ( sigma( k, zero, n + 1, k)) = select (((n * (n + 1)) / 2 + n) + 1) (reducedenom)
 -->
 <div expr="((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)),( sigma( k, zero, n + 1, k)) = ((n * (n + 1)) / 2 + n) + 1,reducedenom,0)" class="pedagogic slide" exercise="demo_tuto_sigma">
 </div>
</div>
<div key="slide_demo_tuto_sigma_((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)),( sigma( k, zero, n + 1, k)) = ((n + 1) * (n + 2)) / 2,commutativity,0)">
 <!-- 	((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)),( sigma( k, zero, n + 1, k)) = ((n + 1) * (n + 2)) / 2,commutativity,0)
	by Forward select of ( sigma( k, zero, n + 1, k)) = select ((n + 2) * (n + 1)) / 2 (commutativity)
 -->
 <div expr="((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)),( sigma( k, zero, n + 1, k)) = ((n + 1) * (n + 2)) / 2,commutativity,0)" class="pedagogic slide" exercise="demo_tuto_sigma">
 </div>
</div>
<div key="slide_demo_tuto_sigma_((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)),( sigma( k, zero, n + 1, k)) = (n * (n + 1) + 2 * (n + 1)) / 2,factorize,0)">
 <!-- 	((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)),( sigma( k, zero, n + 1, k)) = (n * (n + 1) + 2 * (n + 1)) / 2,factorize,0)
	by Forward select of ( sigma( k, zero, n + 1, k)) = select (n * (n + 1) + 2 * (n + 1)) / 2 (factorize)
 -->
 <div expr="((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)),( sigma( k, zero, n + 1, k)) = (n * (n + 1) + 2 * (n + 1)) / 2,factorize,0)" class="pedagogic slide" exercise="demo_tuto_sigma">
 </div>
</div>
<div key="slide_demo_tuto_sigma_((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)),( sigma( k, zero, n, k)) = (n * (n + 1)) / 2,lradd,0)">
 <!-- 	((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)),( sigma( k, zero, n, k)) = (n * (n + 1)) / 2,lradd,0)
	by Forward lradd)
 -->
 <div expr="((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)),( sigma( k, zero, n, k)) = (n * (n + 1)) / 2,lradd,0)" class="pedagogic slide" exercise="demo_tuto_sigma">
 </div>
</div>
<div key="slide_demo_tuto_sigma_((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)),(( sigma( k, zero, n, k)) + n) + 1 = ((n * (n + 1)) / 2 + n) + 1,sigmadef,0)">
 <!-- 	((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)),(( sigma( k, zero, n, k)) + n) + 1 = ((n * (n + 1)) / 2 + n) + 1,sigmadef,0)
	by Forward select of select ((( sigma( k, zero, n, k)) + n) + 1) = ((n * (n + 1)) / 2 + n) + 1 (sigmadef)
 -->
 <div expr="((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)),(( sigma( k, zero, n, k)) + n) + 1 = ((n * (n + 1)) / 2 + n) + 1,sigmadef,0)" class="pedagogic slide" exercise="demo_tuto_sigma">
 </div>
</div>
<div key="slide_demo_tuto_sigma_((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)),true_at_rank P (n + 1))">
 <!-- 	((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)),true_at_rank P (n + 1))
	by Backward (red_true_at_rank)
 -->
 <div expr="((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)),true_at_rank P (n + 1))" class="pedagogic slide" exercise="demo_tuto_sigma">
 </div>
</div>
<div key="slide_demo_tuto_sigma_((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)),true_at_rank P n,red_true_at_rank,0)">
 <!-- 	((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)),true_at_rank P n,red_true_at_rank,0)
	by Forward red_true_at_rank)
 -->
 <div expr="((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)),true_at_rank P n,red_true_at_rank,0)" class="pedagogic slide" exercise="demo_tuto_sigma">
 </div>
</div>
<div key="slide_demo_tuto_sigma_((forall n : Nvar, true_at_rank P n))">
 <!-- 	((forall n : Nvar, true_at_rank P n))
	by Backward (ind_basic_forall)
 -->
 <div expr="((forall n : Nvar, true_at_rank P n))" class="pedagogic slide" exercise="demo_tuto_sigma">
 </div>
</div>
<div key="slide_demo_tuto_sigma_(true_at_rank P zero)">
 <!-- 	(true_at_rank P zero)
	by Backward (red_true_at_rank)
 -->
 <div expr="(true_at_rank P zero)" class="pedagogic slide" exercise="demo_tuto_sigma">
 </div>
</div>
<div key="slide_logic_connector_tuto_01_(and B A)">
 <!-- 	(and B A)
	by Backward (conj)
 -->
 <div expr="(and B A)" class="pedagogic slide" exercise="logic_connector_tuto_01">
 </div>
</div>
<div key="slide_logic_connector_tuto_02_(and A B,elim_conj_left,0)">
 <!--   (and A B,elim_conj_left,0)
  by Forward elim_conj_left)
 -->
 <div expr="(and A B,elim_conj_left,0)" class="pedagogic slide" exercise="logic_connector_tuto_02">
 </div>
</div>
<div key="slide_logic_connector_tuto_02_(and A B,elim_conj_right,0)">
 <!--   (and A B,elim_conj_right,0)
  by Forward elim_conj_right)
 -->
 <div expr="(and A B,elim_conj_right,0)" class="pedagogic slide" exercise="logic_connector_tuto_02">
 </div>
</div>
<div key="slide_logic_connector_tuto_02_(and B A)">
 <!--   (and B A)
  by Backward (conj)
 -->
 <div expr="(and B A)" class="pedagogic slide" exercise="logic_connector_tuto_02">
  <p>
   <!--<span class="light-bulb">ń</span>--> As in the previous example, the conjunction
   <!--{type="tag" input="s1"}--> is justified by invoking the rule <span class="buttontheo">by conjunction</span>. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_03_(or A B)">
 <!--   (or A B)
  by Backward (intro_or_right)
 -->
 <div expr="(or A B)" class="pedagogic slide" exercise="logic_connector_tuto_03">
  <p>
   <!--<span class="light-bulb">ń</span>--> The choice between using A and B to prove
   <!--{type="tag" input="s1"}--> <span class="buttontheo">by disjonction</span> is simple because only the proposition B is provided in hypothesis
   <!--{type="tag" input="s0"}-->. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_04_(case P (or Q P))">
 <!--   (case P (or Q P))
  by Section
 -->
 <div expr="(case P (or Q P))" class="pedagogic slide" exercise="logic_connector_tuto_04">
  <p> Proving Q ∨ P when <span class="stress">P is true</span> requires creating a <span class="stress">logical scope</span> in which P is a hypothesis and Q ∨ P is a conclusion, with button <span class="buttonscope-wrapper"> <span class="buttonscope">↵</span></span>. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_04_(case P (or Q P),or Q P)">
 <!--   (case P (or Q P),or Q P)
  by Backward (intro_or_right)
 -->
 <div expr="(case P (or Q P),or Q P)" class="pedagogic slide" exercise="logic_connector_tuto_04">
  <p>
   <!--<span class="light-bulb">ń</span>--> Within this scope, we now find ourselves in exactly the same situation as in the previous exercise. The disjunction
   <!--{type="tag" input="s2_1"}--> is demonstrated by choosing P which is true by hypothesis
   <!--{type="tag" input="s2_0"}-->. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_04_(case Q (or Q P))">
 <!--   (case Q (or Q P))
  by Section
 -->
 <div expr="(case Q (or Q P))" class="pedagogic slide" exercise="logic_connector_tuto_04">
  <p> Proving Q ∨ P when <span class="stress">Q is true</span> requires creating a <span class="stress">logical scope</span> in which Q is a hypothesis and Q ∨ P is a conclusion, with button <span class="buttonscope-wrapper"> <span class="buttonscope">↵</span></span>. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_04_(case Q (or Q P),or Q P)">
 <!--   (case Q (or Q P),or Q P)
  by Backward (intro_or_left)
 -->
 <div expr="(case Q (or Q P),or Q P)" class="pedagogic slide" exercise="logic_connector_tuto_04">
  <p>
   <!--<span class="light-bulb">ń</span>--> Within this scope, we now find ourselves in exactly the same situation as in the previous exercise. The disjunction
   <!--{type="tag" input="s3_1"}--> is demonstrated by choosing P which is true by hypothesis
   <!--{type="tag" input="s3_0"}-->. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_04_(or Q P)">
 <!--   (or Q P)
  by Backward (case_base)
 -->
 <div expr="(or Q P)" class="pedagogic slide" exercise="logic_connector_tuto_04">
  <p>
   <!--<span class="light-bulb">ń</span>-->Reasoning <span class="buttontheo">by disjunction of cases</span> can be used to justify a proposition when a disjunction is present. </p>
  <p>
   <!--{type="tag" input="s1"}--> is demonstrated with the help of the disjunction
   <!--{type="tag" input="s0"}--> by disjunction of cases. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_06_(A -> (B -> and A B))">
 <!--   (A -> (B -> and A B))
  by Section
 -->
 <div expr="(A -> (B -> and A B))" class="pedagogic slide" exercise="logic_connector_tuto_06">
  <p>
   <!--<span class="light-bulb">ń</span>--> The button
   <!--{type="button_section"}--> allows you to create the logical scope with A as assumption, and
   <!--{type="prop" input="(B -> (and A B))"}--> as conclusion. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_06_(A -> (B -> and A B),B -> and A B)">
 <!--   (A -> (B -> and A B),B -> and A B)
  by Section
 -->
 <div expr="(A -> (B -> and A B),B -> and A B)" class="pedagogic slide" exercise="logic_connector_tuto_06">
  <p>
   <!--<span class="light-bulb">ń</span>--> Again, the button
   <!--{type="button_section"}--> allows you to create the logical scope with A and B assumed and "A ∧ B" concluded. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_06_(B -> and A B,A -> (B -> and A B),and A B)">
 <!--   (B -> and A B,A -> (B -> and A B),and A B)
  by Backward (conj)
 -->
 <div expr="(B -> and A B,A -> (B -> and A B),and A B)" class="pedagogic slide" exercise="logic_connector_tuto_06">
  <p>
   <!--<span class="light-bulb">ń</span>--> We are now back at the first exercise of this tutorial (prove a conjunction).
   <!--{type="tag" input="s3_1"}--> is proved by conjunction with the help of hypotheses
   <!--{type="tag" input="s2_0"}--> and
   <!--{type="tag" input="s3_0"}-->. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_07_(B)">
 <!--   (B)
  by Backward (modus_ponens)
 -->
 <div expr="(B)" class="pedagogic slide" exercise="logic_connector_tuto_07">
  <p>
   <!--<span class="light-bulb">ń</span>--> B is deduced from the implication
   <!--{type="tag" input="s0"}--> if A is true. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_085_(A -> False,modus_ponens,0)">
 <!--   (A -> False,modus_ponens,0)
  by Forward modus_ponens)
 -->
 <div expr="(A -> False,modus_ponens,0)" class="pedagogic slide" exercise="logic_connector_tuto_085">
  <p>
   <!--<span class="light-bulb">ń</span>--> The <span class="stress">modus ponens</span> allows you to deduce False from
   <!--{type="tag" input="s3"}-->. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_085_(~ A,elim_negation,0)">
 <!--   (~ A,elim_negation,0)
  by Forward elim_negation)
 -->
 <div expr="(~ A,elim_negation,0)" class="pedagogic slide" exercise="logic_connector_tuto_085">
  <p>
   <!--<span class="light-bulb">ń</span>--> Translate the negation
   <!--{type="tag" input="s0"}--> into an implication, by definition of negation. </p>
  <p></p>
 </div>
</div>
<div key="slide_logic_connector_tuto_08_(A -> False)">
 <!--   (A -> False)
  by Section
 -->
 <div expr="(A -> False)" class="pedagogic slide" exercise="logic_connector_tuto_08">
  <p>
   <!--<span class="light-bulb">ń</span>--> The button <span class="buttonscope-wrapper"><span class="buttonscope">↵</span></span> allows you to create a new scope in which A is an assumption. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_08_(A -> False,B)">
 <!--   (A -> False,B)
  by Backward (modus_ponens)
 -->
 <div expr="(A -> False,B)" class="pedagogic slide" exercise="logic_connector_tuto_08">
  <p>
   <!--<span class="light-bulb">ń</span>--> The <span class="stress">modus ponens</span> allows you to justify B by implication
   <!--{type="tag" input="s0"}--> applied to assumption A. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_08_(A -> False,False)">
 <!--   (A -> False,False)
  by Backward (modus_ponens)
 -->
 <div expr="(A -> False,False)" class="pedagogic slide" exercise="logic_connector_tuto_08">
  <p>
   <!--<span class="light-bulb">ń</span>--> The <span class="stress">modus ponens</span> allows you to justify False by implication
   <!--{type="tag" input="s2"}--> applied to assumption B. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_08_(~ A)">
 <!--   (~ A)
  by Backward (elim_negation)
 -->
 <div expr="(~ A)" class="pedagogic slide" exercise="logic_connector_tuto_08">
  <p>
   <!--<span class="light-bulb">ń</span>--> Translate the negation
   <!--{type="tag" input="s0"}--> into an implication, by definition of negation. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_09_(A,intro_false,0)">
 <!--   (A,intro_false,0)
  by Forward intro_false)
 -->
 <div expr="(A,intro_false,0)" class="pedagogic slide" exercise="logic_connector_tuto_09">
  <p> Clicking on <span class="context">Context</span> shows statements from upper scopes.
   <!--<span class="light-bulb">ń</span>-->We find ourselves in exactly the same situation as in the previous exercise. It is possible to directly justify the contradiction
   <!--{type="tag" input="s3"}--> by invoking the principle of <span class="buttontheo">non-contradiction</span>. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_09_(B)">
 <!--   (B)
  by Backward (falseall)
 -->
 <div expr="(B)" class="pedagogic slide" exercise="logic_connector_tuto_09">
  <p>
   <!--<span class="light-bulb">ń</span>--> The clear contradiction of hypotheses
   <!--{type="tag" input="s0"}--> and
   <!--{type="tag" input="s2"}--> leads us to justify B with <span class="buttontheo">ex falso quodlibet</span> rule. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_10_(case (~ A) (or A B))">
 <!--   (case (~ A) (or A B))
  by Section
 -->
 <div expr="(case (~ A) (or A B))" class="pedagogic slide" exercise="logic_connector_tuto_10">
  <p>
   <!--<span class="light-bulb">ń</span>--> When ¬ A is true, "A ∨ B" is demonstrated by choosing B, which is obtained by deduction from ¬ A with the help of
   <!--{type="tag" input="s0"}-->. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_10_(case (~ A) (or A B),or A B)">
 <!--   (case (~ A) (or A B),or A B)
  by Backward (intro_or_right)
 -->
 <div expr="(case (~ A) (or A B),or A B)" class="pedagogic slide" exercise="logic_connector_tuto_10">
  <p>
   <!--<span class="light-bulb">ń</span>--> When ¬ A is true, "A ∨ B" is demonstrated by choosing B, which is obtained by deduction from ¬ A with the help of
   <!--{type="tag" input="s0"}-->. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_10_(case A (or A B))">
 <!--   (case A (or A B))
  by Section
 -->
 <div expr="(case A (or A B))" class="pedagogic slide" exercise="logic_connector_tuto_10">
  <p>
   <!--<span class="light-bulb">ń</span>--> When A is true, "A ∨ B" is demonstrated by choosing A. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_10_(case A (or A B),or A B)">
 <!--   (case A (or A B),or A B)
  by Backward (intro_or_left)
 -->
 <div expr="(case A (or A B),or A B)" class="pedagogic slide" exercise="logic_connector_tuto_10">
  <p>
   <!--<span class="light-bulb">ń</span>--> When A is true, "A ∨ B" is demonstrated by choosing A. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_10_(or A B)">
 <!--   (or A B)
  by Backward (case_base_binary)
 -->
 <div expr="(or A B)" class="pedagogic slide" exercise="logic_connector_tuto_10">
  <p>
   <!--<span class="light-bulb">ń</span>--> The use of <span class="buttontheo">excluded middle</span> allows us to demonstrate
   <!--{type="tag" input="s1"}--> : when A is true and when ¬ A is true. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_10_(~ A -> B,modus_ponens,0)">
 <!--   (~ A -> B,modus_ponens,0)
  by Forward modus_ponens)
 -->
 <div expr="(~ A -> B,modus_ponens,0)" class="pedagogic slide" exercise="logic_connector_tuto_10">
  <p>
   <!--<span class="light-bulb">ń</span>--> We use
   <!--{type="tag" input="s0"}--> as a <span class="buttontheo">local theorem</span>to justify B. This justification acts as the modus ponens. The only difference is that a "local theorem" extends the modus ponens to expressions containing quantifiers like "for every ..." (see the following section). </p>
 </div>
</div>
<div key="slide_logic_quantifier_tuto_01_((forall y : O1U, app_prop O1U A y -> exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x)))">
 <!-- 	((forall y : O1U, app_prop O1U A y -> exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x)))
	by Section
 -->
 <div expr="((forall y : O1U, app_prop O1U A y -> exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x)))" class="pedagogic slide" exercise="logic_quantifier_tuto_01">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_01_((forall y : O1U, app_prop O1U A y -> exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x)),app_prop O1U A b -> exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x))">
 <!-- 	((forall y : O1U, app_prop O1U A y -> exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x)),app_prop O1U A b -> exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x))
	by Section
 -->
 <div expr="((forall y : O1U, app_prop O1U A y -> exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x)),app_prop O1U A b -> exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x))" class="pedagogic slide" exercise="logic_quantifier_tuto_01">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_01_(app_prop O1U A b -> exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x),(forall y : O1U, app_prop O1U A y -> exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x)),(exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x)))">
 <!-- 	(app_prop O1U A b -> exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x),(forall y : O1U, app_prop O1U A y -> exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x)),(exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x)))
	by Backward (ex_intro)
 -->
 <div expr="(app_prop O1U A b -> exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x),(forall y : O1U, app_prop O1U A y -> exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x)),(exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x)))" class="pedagogic slide" exercise="logic_quantifier_tuto_01">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_01_(app_prop O1U A b -> exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x),(forall y : O1U, app_prop O1U A y -> exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x)),or (app_prop O1U A b) (app_prop O1U B b))">
 <!-- 	(app_prop O1U A b -> exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x),(forall y : O1U, app_prop O1U A y -> exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x)),or (app_prop O1U A b) (app_prop O1U B b))
	by Backward (intro_or_left)
 -->
 <div expr="(app_prop O1U A b -> exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x),(forall y : O1U, app_prop O1U A y -> exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x)),or (app_prop O1U A b) (app_prop O1U B b))" class="pedagogic slide" exercise="logic_quantifier_tuto_01">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_02_((exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x)),ex_elim,0)">
 <!-- 	((exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x)),ex_elim,0)
	by Forward ex_elim)
 -->
 <div expr="((exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x)),ex_elim,0)" class="pedagogic slide" exercise="logic_quantifier_tuto_02">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_02_(case (app_prop O1U A a)  (or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z)))">
 <!-- 	(case (app_prop O1U A a)  (or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z)))
	by Section
 -->
 <div expr="(case (app_prop O1U A a)  (or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z)))" class="pedagogic slide" exercise="logic_quantifier_tuto_02">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_02_(case (app_prop O1U A a)  (or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z)),(exists y : O1U, app_prop O1U A y))">
 <!-- 	(case (app_prop O1U A a)  (or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z)),(exists y : O1U, app_prop O1U A y))
	by Backward (ex_intro)
 -->
 <div expr="(case (app_prop O1U A a)  (or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z)),(exists y : O1U, app_prop O1U A y))" class="pedagogic slide" exercise="logic_quantifier_tuto_02">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_02_(case (app_prop O1U A a)  (or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z)),or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z))">
 <!-- 	(case (app_prop O1U A a)  (or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z)),or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z))
	by Backward (intro_or_left)
 -->
 <div expr="(case (app_prop O1U A a)  (or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z)),or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z))" class="pedagogic slide" exercise="logic_quantifier_tuto_02">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_02_(case (app_prop O1U B a)  (or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z)))">
 <!-- 	(case (app_prop O1U B a)  (or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z)))
	by Section
 -->
 <div expr="(case (app_prop O1U B a)  (or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z)))" class="pedagogic slide" exercise="logic_quantifier_tuto_02">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_02_(case (app_prop O1U B a)  (or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z)),(exists z : O1U, app_prop O1U B z))">
 <!-- 	(case (app_prop O1U B a)  (or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z)),(exists z : O1U, app_prop O1U B z))
	by Backward (ex_intro)
 -->
 <div expr="(case (app_prop O1U B a)  (or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z)),(exists z : O1U, app_prop O1U B z))" class="pedagogic slide" exercise="logic_quantifier_tuto_02">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_02_(case (app_prop O1U B a)  (or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z)),or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z))">
 <!-- 	(case (app_prop O1U B a)  (or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z)),or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z))
	by Backward (intro_or_right)
 -->
 <div expr="(case (app_prop O1U B a)  (or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z)),or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z))" class="pedagogic slide" exercise="logic_quantifier_tuto_02">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_02_(or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z))">
 <!-- 	(or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z))
	by Backward (case_base)
 -->
 <div expr="(or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z))" class="pedagogic slide" exercise="logic_quantifier_tuto_02">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_03_((forall x : O1U, and (app_prop O1U A x) (app_prop O1U B x)))">
 <!-- 	((forall x : O1U, and (app_prop O1U A x) (app_prop O1U B x)))
	by Section
 -->
 <div expr="((forall x : O1U, and (app_prop O1U A x) (app_prop O1U B x)))" class="pedagogic slide" exercise="logic_quantifier_tuto_03">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_03_((forall x : O1U, and (app_prop O1U A x) (app_prop O1U B x)),(forall x : O1U, app_prop O1U A x),apply_forall,0)">
 <!-- 	((forall x : O1U, and (app_prop O1U A x) (app_prop O1U B x)),(forall x : O1U, app_prop O1U A x),apply_forall,0)
	by Forward apply_forall)
 -->
 <div expr="((forall x : O1U, and (app_prop O1U A x) (app_prop O1U B x)),(forall x : O1U, app_prop O1U A x),apply_forall,0)" class="pedagogic slide" exercise="logic_quantifier_tuto_03">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_03_((forall x : O1U, and (app_prop O1U A x) (app_prop O1U B x)),(forall x : O1U, app_prop O1U B x),apply_forall,0)">
 <!-- 	((forall x : O1U, and (app_prop O1U A x) (app_prop O1U B x)),(forall x : O1U, app_prop O1U B x),apply_forall,0)
	by Forward apply_forall)
 -->
 <div expr="((forall x : O1U, and (app_prop O1U A x) (app_prop O1U B x)),(forall x : O1U, app_prop O1U B x),apply_forall,0)" class="pedagogic slide" exercise="logic_quantifier_tuto_03">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_03_((forall x : O1U, and (app_prop O1U A x) (app_prop O1U B x)),and (app_prop O1U A a) (app_prop O1U B a))">
 <!-- 	((forall x : O1U, and (app_prop O1U A x) (app_prop O1U B x)),and (app_prop O1U A a) (app_prop O1U B a))
	by Backward (conj)
 -->
 <div expr="((forall x : O1U, and (app_prop O1U A x) (app_prop O1U B x)),and (app_prop O1U A a) (app_prop O1U B a))" class="pedagogic slide" exercise="logic_quantifier_tuto_03">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_03_(and (forall x : O1U, app_prop O1U A x) (forall x : O1U, app_prop O1U B x),elim_conj_left,0)">
 <!-- 	(and (forall x : O1U, app_prop O1U A x) (forall x : O1U, app_prop O1U B x),elim_conj_left,0)
	by Forward elim_conj_left)
 -->
 <div expr="(and (forall x : O1U, app_prop O1U A x) (forall x : O1U, app_prop O1U B x),elim_conj_left,0)" class="pedagogic slide" exercise="logic_quantifier_tuto_03">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_03_(and (forall x : O1U, app_prop O1U A x) (forall x : O1U, app_prop O1U B x),elim_conj_right,0)">
 <!-- 	(and (forall x : O1U, app_prop O1U A x) (forall x : O1U, app_prop O1U B x),elim_conj_right,0)
	by Forward elim_conj_right)
 -->
 <div expr="(and (forall x : O1U, app_prop O1U A x) (forall x : O1U, app_prop O1U B x),elim_conj_right,0)" class="pedagogic slide" exercise="logic_quantifier_tuto_03">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_04_((forall x : O1U, and (app_prop O1U A x) (app_prop O1U B x)),apply_forall,0)">
 <!-- 	((forall x : O1U, and (app_prop O1U A x) (app_prop O1U B x)),apply_forall,0)
	by Forward apply_forall)
 -->
 <div expr="((forall x : O1U, and (app_prop O1U A x) (app_prop O1U B x)),apply_forall,0)" class="pedagogic slide" exercise="logic_quantifier_tuto_04">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_04_((forall x : O1U, app_prop O1U A x))">
 <!-- 	((forall x : O1U, app_prop O1U A x))
	by Section
 -->
 <div expr="((forall x : O1U, app_prop O1U A x))" class="pedagogic slide" exercise="logic_quantifier_tuto_04">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_04_((forall x : O1U, app_prop O1U A x),and (app_prop O1U A a) (app_prop O1U B a),elim_conj_left,0)">
 <!-- 	((forall x : O1U, app_prop O1U A x),and (app_prop O1U A a) (app_prop O1U B a),elim_conj_left,0)
	by Forward elim_conj_left)
 -->
 <div expr="((forall x : O1U, app_prop O1U A x),and (app_prop O1U A a) (app_prop O1U B a),elim_conj_left,0)" class="pedagogic slide" exercise="logic_quantifier_tuto_04">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_04_((forall x : O1U, app_prop O1U B x))">
 <!-- 	((forall x : O1U, app_prop O1U B x))
	by Section
 -->
 <div expr="((forall x : O1U, app_prop O1U B x))" class="pedagogic slide" exercise="logic_quantifier_tuto_04">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_04_((forall x : O1U, app_prop O1U B x),and (app_prop O1U A a) (app_prop O1U B a),elim_conj_right,0)">
 <!-- 	((forall x : O1U, app_prop O1U B x),and (app_prop O1U A a) (app_prop O1U B a),elim_conj_right,0)
	by Forward elim_conj_right)
 -->
 <div expr="((forall x : O1U, app_prop O1U B x),and (app_prop O1U A a) (app_prop O1U B a),elim_conj_right,0)" class="pedagogic slide" exercise="logic_quantifier_tuto_04">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_04_(and (forall x : O1U, app_prop O1U A x) (forall x : O1U, app_prop O1U B x))">
 <!-- 	(and (forall x : O1U, app_prop O1U A x) (forall x : O1U, app_prop O1U B x))
	by Backward (conj)
 -->
 <div expr="(and (forall x : O1U, app_prop O1U A x) (forall x : O1U, app_prop O1U B x))" class="pedagogic slide" exercise="logic_quantifier_tuto_04">
 </div>
</div>
<div class="toolbox-text custom pedagogic confuse" key="text_Antonym1">
 <p>If a child is the youngest, then he/she is not the oldest. </p>
</div>
<div class="toolbox-text custom pedagogic confuse" key="text_Antonym2">
 <p>If a child is the oldest, then he/she is not the youngest. </p>
</div>
<div class="toolbox-text custom pedagogic confuse" key="text_Superlative1">
 <p>If a child is the youngest, then any other child is not the youngest. </p>
</div>
<div class="toolbox-text custom pedagogic confuse" key="text_Superlative2">
 <p>If a child is the oldest then any other child is not the oldest. </p>
</div>
<div class="toolbox-text custom pedagogic" key="text_adabsurdium">
 <p> <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Raisonnement_par_l%27absurde" target="_blank">Reductio ad absurdum</a></span> is proves statement A by showing that, if its negation, ¬ A is true, then we get a contradiction: </p>
 <p> Indeed,
  <!--{type="prop" sci="true" input="~(~A)"}--> rewrites into
  <!--{type="prop" sci="true" input="(~A -> False)"}--> by definition of negation. Reduction ad absurdum is thus an elimination rule of double negation. </p>
</div>
<div key="text_addsub">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic appdef" key="text_app_def">
 <p>One can apply a function to a value that belongs to its domain, as exampled below: </p>
</div>
<div class="toolbox-text custom pedagogic lrapply" key="text_app_sqrt">
 <p>Applies square root, if the value is positive.</p>
</div>
<div key="text_app_sqrt_bounded">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic lrapply" key="text_app_square">
 <p>Squaring left and right.</p>
</div>
<div key="text_app_square_bounded">
 <!--TODO-->
</div>
<div key="text_appdef"></div>
<div key="text_apply_forall">
 <!--TODO-->
</div>
<div key="text_apply_fun_lr">
 <!--TODO-->
</div>
<div key="text_apply_ineq_inverse">
 <!--TODO-->
</div>
<div key="text_apply_ineq_sqrt">
 <!--TODO-->
</div>
<div key="text_apply_ineq_square">
 <!--TODO-->
</div>
<div key="text_arith_def">
 <!--TODO-->
</div>
<div key="text_arith_pro">
 <!--TODO-->
</div>
<div key="text_arith_series">
 <!--TODO-->
</div>
<div key="text_ax_bad">
 <!--TODO-->
</div>
<div key="text_ax_good">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_back_elim_equiv">
 <p>Several versions of equivalence are available, in deduction and justification:</p>
 <p> </p>
</div>
<div key="text_binrel"></div>
<div class="toolbox-text custom pedagogic" key="text_bound_conj">
 <p>Double inequaliy is translated to two inequality statements.</p>
</div>
<div key="text_bound_to_eq">
 <!--TODO-->
</div>
<div key="text_bounded_elim">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_case_base">
 <p> If "A ∨ B" is true, we just know that one of the two statements is true, without knowing which one. One can not deduce anything directly. However, when we want to prove a statement C knowing that "A ∨ B" is true, it suffices to prove C if A is true, and prove C if B is true. In such a case, we know that C is true in all cases, without knowing which of the two propositions, A or B is true. . </p>
</div>
<div class="toolbox-text custom pedagogic" key="text_case_base_binary">
 <p>The excluded middle rule expresses the fact that, whatever the statement A, either A is true or A is false, excluding any other value of A than true and false. </p>
</div>
<div key="text_case_good_or_bad">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_comb_comp_lt">
 <p>Composition preserves the inclusion relation.</p>
</div>
<div class="toolbox-text custom pedagogic comb" key="text_combadd">
 <p></p>
</div>
<div key="text_combinaison"></div>
<div class="toolbox-text custom pedagogic" key="text_combine_cmp_minus">
 <p> </p>
</div>
<div class="toolbox-text custom pedagogic" key="text_combine_cmp_plus">
 <p> </p>
</div>
<div class="toolbox-text custom pedagogic comb" key="text_combsub">
 <p></p>
</div>
<div class="toolbox-text custom pedagogic" key="text_commutativity">
 <p>Multiplication and addition are commutative operations: you can reorder the terms as necessary.</p>
</div>
<div class="toolbox-text custom pedagogic" key="text_conj">
 <p> To prove "A ∧ B" is to provide two proofs: one A and one B. </p>
</div>
<div key="text_conjunction">
 <p>Text in english</p>
</div>
<div key="text_converge">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic appdef" key="text_deduce_not_color">
 <p>Since there are only two white hats, if a hat wearer sees his two friends each carry a white hat, then he/she can infer that he/she is necessarily wearing a black hat.</p>
 <p>By contraposition, if a hat wearer does not know the color of his hat, then at least one of his two comrades is wearing a black hat.</p>
</div>
<div class="toolbox-text custom pedagogic" key="text_def_fbij">
 <p> A function f of A to B is <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Bijection" target="_blank">bijective</a></span> if it is both injective and surjective: any element of B is the image by f of one and only one element of A. </p>
</div>
<div class="toolbox-text custom pedagogic" key="text_def_fcomp">
 <p>The composition of two functions f: A → B and g: B → C, denoted "f ∘ g" and read "f round g", is a function of A to C so that the image of an element x of A is the image under g of the image under f of x. </p>
 <p> The composition operator provides with a function of type (A → C) from two of functions of types (A → B) and (B → C). A form of similarity is noted with the proof of a <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Syllogisme" target="_blank">syllogism</a></span> that provides proof of
  <!--{type="prop" sci="true" input="A -> C"}--> assuming
  <!--{type="prop" sci="true" input="A -> B"}--> and
  <!--{type="prop" sci="true" input="B -> C"}--> ... </p>
</div>
<div class="toolbox-text custom pedagogic" key="text_def_finj">
 <p> A function is <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Injection_(math%C3%A9matiques)" target="_blank">injective</a></span> if the corresponding relation is injective. Thus the function f of A to B is injective iif an element of B is the image of one and only one element of A. or in other words, if two elements x and z have the same image under f, then these elements are the same. </p>
 <p>Note that to prove that a function f is not injective, just find two distinct elements that have the same image by f. </p>
</div>
<div class="toolbox-text custom pedagogic" key="text_def_finvol">
 <p> If f is a function from E to E, it is <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Involution_(math%C3%A9matiques)" target="_blank">involutive</a></span> if the image of the image of an element x, is x itself. </p>
 <p>Examples:</p>
 <ul>
  <li>the symmetry in a mirror</li>
  <li>in <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Logique_classique" target="_blank">classical logic</a></span> , the negation of a proposition is involutive, allowing the <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Raisonnement_par_l%27absurde" target="_blank">reduction ad absurdum</a></span></li>
  <li>the encryption algorithm <span class="exturl"><a href="https://fr.wikipedia.org/wiki/ROT13" target="_blank">ROT13</a></span></li>
 </ul>
 <p></p>
</div>
<div class="toolbox-text custom pedagogic" key="text_def_fsurj">
 <p>A function f of A to B is surjective if all elements of B are the image of at least one element of A. </p>
</div>
<div class="toolbox-text custom pedagogic" key="text_def_rantisym">
 <p>A binary relation on E is antisymmetric if, for any elements x y of E, if the pairs (x, y) and (y, x) belong to the graph of the relationship, then x is the same element as y.</p>
</div>
<div class="toolbox-text custom pedagogic" key="text_def_rcomp">
 <p> If A B and C are sets, if
  <!--{type="expr" input="R1"}--> a relation on A×B, and if
  <!--{type="expr" input="R2"}--> a relation on B×C, then composition of
  <!--{type="expr" input="R1"}--> and
  <!--{type="expr" input="R2"}-->, noted
  <!--{type="expr" input="RComp U U U A B C R1 R2"}-->, is the relation on A×C such that an élément x of A is in relation with an element z of C by
  <!--{type="expr" input="RComp U U U A B C R1 R2"}-->, if x and z are in relation with an element y of B, respectively on the left y by
  <!--{type="expr" input="R1"}--> and on the left by
  <!--{type="expr" input="R2"}--> : </p>
</div>
<div class="toolbox-text custom pedagogic" key="text_def_rfun">
 <p>A relation of A×B is functional if an element of A is related to at most one element of B. </p>
</div>
<div class="toolbox-text custom pedagogic" key="text_def_rident">
 <p>The graph of the identity relation on set E, noted
  <!--{type="expr" input="RIdent U E"}--> is all couples
  <!--{type="expr" input="upair U U x x"}--> where x belongs to E. </p>
</div>
<div class="toolbox-text custom pedagogic" key="text_def_rinj">
 <p>A relation of A×B is injective if an element of B is related to at most one element of A. In other words, an element of B in relation by R, is in relation with only one element of A. In other words again, if two elements of a are in relation with an element of B by an injective relation, then these two elements are the same. </p>
</div>
<div class="toolbox-text custom pedagogic" key="text_def_rinv">
 <p>The inverse relation of a relation R defined on A×B, denoted R⁻¹, is defined on B × A by: </p>
</div>
<div class="toolbox-text custom pedagogic" key="text_def_rrefl">
 <p>A binary relation on E is reflexive if any element of E is related to itself.</p>
</div>
<div class="toolbox-text custom pedagogic" key="text_def_rsurj">
 <p>A relation of A × B is surjective, or right-total, if all elements of B are in relation with an element of A. </p>
</div>
<div class="toolbox-text custom pedagogic" key="text_def_rsym">
 <p>A binary relation on E is symmetric if, for every elements x and y of E, the pairs (x, y) and (y, x) belong to the graph of the relation.</p>
</div>
<div class="toolbox-text custom pedagogic" key="text_def_rtotleft">
 <p>A relation on A × B is left-total if all elements of A are in relation with an element of B. </p>
</div>
<div class="toolbox-text custom pedagogic" key="text_def_rtrans">
 <p>A binary relation is transitive if:</p>
</div>
<div key="text_disjonction"></div>
<div key="text_distrib"></div>
<div key="text_elim_comp">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_elim_conj_left">
 <p> If "A ∧ B" is true, then A is true. </p>
</div>
<div class="toolbox-text custom pedagogic" key="text_elim_conj_right">
 <p>If "A ∧ B" is true, then B is true.</p>
</div>
<div key="text_elim_eqfun">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_elim_eqset">
 <p>Two sets A and B are equal if being element of A involves be element of B, and vice versa; that is to say that A is included in B and conversely B is included in A (by definition of inclusion). Equality is simply noté "A = B". </p>
</div>
<div key="text_elim_even_def">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_elim_false_exset">
 <p> By definition, <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Ensemble_vide" target="_blank">the empty set</a></span> , denoted by ∅, is the set that is included in any set. </p>
</div>
<div class="toolbox-text custom pedagogic" key="text_elim_gen_app_rel">
 <p> In the following, a relation R is equated with its graph in order to keep formulas and notations simple. </p>
</div>
<div key="text_elim_has_finite_limit_decr">
 <!--TODO-->
</div>
<div key="text_elim_has_finite_limit_incr">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_elim_is_elem_universe">
 <p> By definition, the universe, noted U, is the set that contains all elements. The universe is the largest set in the sense of inclusion (any set is included in the universe). </p>
</div>
<div key="text_elim_multiple">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_elim_negation">
 <p> The negation of a statement A is defined using the constant <span style="font-weight:bold">contradiction</span> as follows: </p>
</div>
<div key="text_elim_pprod">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_elim_requiv">
 <p>An <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Relation_d%27%C3%A9quivalence" target="_blank">equivalence relation</a></span> is reflexive, symmetric, and transitive. For example, equality and equivalence are equivalence relations. </p>
</div>
<div class="toolbox-text custom pedagogic" key="text_elim_scomp">
 <p> The complement of a set A in the universe U, denoted "
  <!--{type="expr" input="scomp U (sall U) A"}--> " and read "complement of A in U" or simply "complement of A", contains elements that are not in A: </p>
 <span style="position:relative;left:-20px;display:inherit;width:110%;text-align:center;padding-bottom:0px;background-color:rgba(0,172,231,1)"> <img src="./svg/complement.svg" style="width:auto;height:150px;position:relative"> </span>
</div>
<div class="toolbox-text custom pedagogic" key="text_elim_sdiff">
 <p> The relative complement of two sets A and B, denoted "
  <!--{type="expr" input="sdiff U A B"}-->" contains the elements that are in A and not in B: </p>
 <span style="display:inherit;width:100%;text-align:center;padding-bottom:0px;position:relative"> <img src="./svg/diff.svg" style="width:auto;height:150px"> </span>
</div>
<div class="toolbox-text custom pedagogic" key="text_elim_sequiv">
 <p>The equivalence class of an element x by a relation R on a set E, denoted
  <!--{type="expr" input="sequiv U E x R"}--> , is the set of elements related to x by R.</p>
</div>
<div class="toolbox-text custom pedagogic" key="text_elim_set_lteq">
 <p>A set is included in another if and only if being an element of it implies being element of the other.</p>
 <span style="display:inherit;width:100%;text-align:center;padding-bottom:0px"> <img src="./svg/subset.svg" style="width:auto;height:150px"> </span>
</div>
<div key="text_elim_shas_lower_bound">
 <!--TODO-->
</div>
<div key="text_elim_shas_upper_bound">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_elim_sinter">
 <p> The intersection of two sets A and B, denoted "
  <!--{type="expr" input="sinter U A B"}--> " and read "A inter B" contains the elements that are in both A and B: </p>
 <span style="display:inherit;width:100%;text-align:center;padding-bottom:0px;position:relative"> <img src="./svg/inter.svg" style="width:auto;height:150px"> </span>
</div>
<div key="text_elim_sis_decreasing">
 <!--TODO-->
</div>
<div key="text_elim_sis_gt_zero">
 <!--TODO-->
</div>
<div key="text_elim_sis_increasing">
 <!--TODO-->
</div>
<div key="text_elim_sis_lt_zero">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_elim_subset">
 <p> <a href="https://fr.wikipedia.org/wiki/Ensemble_des_parties_d%27un_ensemble" target="_blank">The power set</a> of a set A, denoted
  <!--{type="expr" input="ssubset U A"}--> , is the set of subsets of A. </p>
 <p> In particular we deduce that
  <!--{type="prop" sci="true" input="sis_element A (ssubset U A)"}--> since
  <!--{type="prop" sci="true" input="set_lteq U A A"}--> by definition of inclusion. </p>
</div>
<div class="toolbox-text custom pedagogic" key="text_elim_sunion">
 <p> The union of two sets A and B, denoted "
  <!--{type="expr" input="sunion U A B"}--> " and read "A union B" contains the elements that either A or B in: </p>
 <span style="display:inherit;width:100%;text-align:center;padding-bottom:0px;position:relative"> <img src="./svg/union.svg" style="width:auto;height:150px"> </span>
</div>
<div class="toolbox-text custom pedagogic" key="text_elim_true_at_rank">
 <p>The first step of the induction defines a statement P of an index n, as in the example below: </p>
</div>
<div key="text_eq_inverse">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic lrapply" key="text_eq_reverse">
 <p>Taking the opposite on left and right sides.</p>
</div>
<div class="toolbox-text custom pedagogic eqrel" key="text_eq_symmetry">
 <p>If a = b then b = a.</p>
</div>
<div class="toolbox-text custom pedagogic eqrel" key="text_eq_trans">
 <p>If a = b and b = c then a = c.</p>
</div>
<div key="text_eqfun">
 <!--TODO-->
</div>
<div key="text_eqrel"></div>
<div key="text_eqset"></div>
<div key="text_equiv"></div>
<div class="toolbox-text custom pedagogic" key="text_equiv_rtrans">
 <p>Set formulation of a transitive relation:</p>
</div>
<div class="toolbox-text custom pedagogic" key="text_ex_elim">
 <p> The deduction from an existence
  <!--{type="prop" sci="true" input="exists x, app_prop U F x"}--> <span class="stress">declares an element</span> x that verifies the proposition
  <!--{type="prop" sci="true" input="app_prop U F x"}--> . </p>
</div>
<div class="toolbox-text custom pedagogic" key="text_ex_intro">
 <p> Proving existence is about <span class="stress">finding an element</span> for which the statement is true. Such an element is called a <span class="stress">witness</span> of the proof
  <!--{type="prop" sci="true" input="exists (x:O1U), app_prop O1U F x"}--> . </p>
 <!-- <p>Trouver un témoin consiste à trouver une valeur pour l'<span class="stress">inconnue de raisonnement</span> <span class="evar" style="font-size:15px">x?</span> </p> -->
</div>
<div key="text_exists"></div>
<div class="toolbox-text custom pedagogic" key="text_expand">
 <p>Full development of product of factors.</p>
</div>
<div key="text_fact">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_factorize">
 <p>'Remarkable' factorization detects a common factor in a sum of terms, and factorize it.</p>
</div>
<div class="toolbox-text custom pedagogic" key="text_falseall">
 <p>"False results from what you want." This rule enable to justify any statement with the constant <span style="font-weight:bold">contradiction.</span></p>
 <p>This rule is very useful especially in the reasoning by disjunction of cases: indeed if a contradiction is obtained in a case, it can be concluded directly with this rule.</p>
 <p>You find this logical principle in popular expressions:</p>
 <ul>
  <li>With "if", we would put Paris in a bottle (french).</li>
  <li>When Pigs Fly ...</li>
 </ul>
</div>
<div key="text_forall"></div>
<div key="text_funop">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_gen_factorize">
 <p>Factorization by any value <span class="stress">other than zero.</span></p>
</div>
<div key="text_geo_def">
 <!--TODO-->
</div>
<div key="text_geo_pro">
 <!--TODO-->
</div>
<div key="text_geo_series">
 <!--TODO-->
</div>
<div key="text_implication"></div>
<div class="toolbox-text custom pedagogic" key="text_inclusionsimpl">
 <p> One can simplify the intersection (or the union) of two sets if one of two sets is included in the other. </p>
</div>
<div class="toolbox-text custom pedagogic" key="text_ind_basic_forall">
 <p>The justification by induction uses the <span class="stress">initialization</span> statement and the <span class="stress">heredity</span> statement. </p>
</div>
<div key="text_ind_init">
 <!--TODO-->
</div>
<div key="text_induction"></div>
<div class="toolbox-text custom pedagogic" key="text_ineq_sym_rew">
 <p>A comparison can be rewritten by changing the order of values ​​and replacing the comparison by its reciprocal. For example
  <!--{type="prop" sci="true" style="vertical-align:-3px;" input="ExprLT a b"}--> rewrites to
  <!--{type="prop" sci="true" style="vertical-align:-3px;" input="ExprGT b a"}--> . </p>
</div>
<div key="text_ineqapp"></div>
<div key="text_ineqbound"></div>
<div key="text_ineqcomb"></div>
<div key="text_ineqconv">
 <!--TODO-->
</div>
<div key="text_ineqrel"></div>
<div class="toolbox-text custom pedagogic" key="text_intro_false">
 <p> We can deduce a contradiction from a statement and its negation.</p>
</div>
<div class="toolbox-text custom pedagogic" key="text_intro_or_left">
 <p>To prove "A ∨ B", it suffices to prove A.</p>
</div>
<div class="toolbox-text custom pedagogic" key="text_intro_or_right">
 <p>To prove "A ∨ B", it suffices to prove B.</p>
</div>
<div key="text_intro_sqrt_square">
 <!--TODO-->
</div>
<div key="text_leftright"></div>
<div key="text_leftright_ineq"></div>
<div key="text_leftright_neq"></div>
<div key="text_limfinite">
 <!--TODO-->
</div>
<div key="text_limit_finite">
 <!--TODO-->
</div>
<div key="text_limit_inf">
 <!--TODO-->
</div>
<div key="text_limit_neg_inf">
 <!--TODO-->
</div>
<div key="text_limitinf">
 <!--TODO-->
</div>
<div key="text_limitops">
 <!--TODO-->
</div>
<div class="toolbox-text custom simpl" key="text_linearsimpl" style="padding-left:20px;padding-right:20px">
 <p>Simplifications can:</p>
 <ul>
  <li style="font-size:14px">calculate a numerical term (which contains only numbers)</li>
  <li style="font-size:14px">perform simple polynomial operations (addition, subtraction, ...)
   <!-- <span class="stress">de degré 1</span> --></li>
  <li style="font-size:14px">perform linear simplifications (elimination of terms like 'x-x')</li>
  <!--  <li style="font-size:14px;">factoriser les puissances par rapport à la multiplication</li> -->
 </ul>
 <p></p>
</div>
<div key="text_logicothers"></div>
<div class="toolbox-text custom pedagogic leftright" key="text_lradd">
 <p>Addition to left and right sides. This allows to pass a term from one side of an equality to the other (with sign change).</p>
</div>
<div key="text_lradd_bounded">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_lradd_ineq">
 <p>Addition to left and right sides. This allows to pass a term from one side of an inequality to the other (with sign change). </p>
</div>
<div key="text_lradd_neq">
 <!--TODO-->
</div>
<div key="text_lrapply"></div>
<div class="toolbox-text custom pedagogic leftright" key="text_lrdiv">
 <p>Division by a value of left and right sides. The argument should be different from zero.</p>
</div>
<div key="text_lrdiv_bounded">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_lrdiv_ineq">
 <p>Division by a value of left and right sides. If the is argument is negative, the sense of inequality is changed. </p>
</div>
<div key="text_lrdiv_neq">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic leftright" key="text_lrmul">
 <p>Multiplication by a value of the left and right sides.</p>
</div>
<div key="text_lrmul_bounded">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_lrmul_ineq">
 <p>Multiplication by a value of left and right sides. If this value is negative, the sense of inequality is changed.</p>
</div>
<div key="text_lrmul_neq">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic leftright" key="text_lrsub">
 <p>Subtraction by a value of left and right sides. This allows to pass a term from one side of an equality to the other (with sign change).</p>
</div>
<div key="text_lrsub_bounded">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_lrsub_ineq">
 <p>Subtraction by a value of left and right sides. This allows to pass a term from one side of an inequ to the other (with sign change).</p>
</div>
<div key="text_lrsub_neq">
 <!--TODO-->
</div>
<div key="text_lt_next_int">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_modus_ponens">
 <p> Deducing B from A means that if A is true, one can deduce B. This rule is called <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Modus_ponens" target="_blank">modus ponens</a></span> .</p>
</div>
<div key="text_muldiv">
 <!--TODO-->
</div>
<div key="text_multiple">
 <!--TODO-->
</div>
<div key="text_negation"></div>
<div key="text_neq_symmetry">
 <!--TODO-->
</div>
<div key="text_non_zero_gt">
 <!--TODO-->
</div>
<div key="text_non_zero_lt">
 <!--TODO-->
</div>
<div key="text_oldest">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_polysquare">
 <p>The square factorization of the sum of the term
  <!--{type="expr" input="a"}--> and
  <!--{type="expr" input="b"}--> is given by the formula: </p>
 <p>
  <!--{type="prop" sci="true" input=" ((pow a 2) + (2*a*b) + (pow b 2)) = (pow (a+b) 2)"}--></p>
 <p>For example :</p>
</div>
<div key="text_prod">
 <!--TODO-->
</div>
<div key="text_proddecompl">
 <!--TODO-->
</div>
<div key="text_proddef">
 <!--TODO-->
</div>
<div key="text_prodidx">
 <!--TODO-->
</div>
<div key="text_prodinverse">
 <!--TODO-->
</div>
<div key="text_prodlinear">
 <!--TODO-->
</div>
<div key="text_prodrem">
 <!--TODO-->
</div>
<div key="text_prodresult1">
 <!--TODO-->
</div>
<div key="text_prodsimpl">
 <!--TODO-->
</div>
<div key="text_produpshift">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic appdef" key="text_reason_capacity">
 <p>Since hat wearers are endowed with reason, if one can deduce one hat color, so can a hat wearer, and then he knows the color of his/her hat. </p>
</div>
<div key="text_red_true_at_rank">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_reducedenom">
 <p>Getting to the common denominator of a sum of fractions.</p>
 <p></p>
</div>
<div key="text_relops"></div>
<div key="text_relothers"></div>
<div key="text_relprop"></div>
<div key="text_relset">
 <!--TODO-->
</div>
<div key="text_remid"></div>
<div key="text_rewops"></div>
<div key="text_rewprops">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_rewriting">
 <p> Select a term 'a' in an equation allows to replace the term with 'b' if equality 'a = b' is true. </p>
</div>
<div key="text_sandwich">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_section">
 <p>To prove "A ⇒ B" one creates a new logical scope (a new exercise) in which A is a hypothesis and B is the conclusion.</p>
</div>
<div key="text_series_limitation">
 <!--TODO-->
</div>
<div key="text_series_sign">
 <!--TODO-->
</div>
<div key="text_series_variation">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_set_absorb">
 <p> The empty set is the <span class="exturl"><a href="https://fr.wikipedia.org/wiki/%C3%89l%C3%A9ment_absorbant" target="_blank">absorbent element</a></span> of the intersection operation, and the universe is the absorbent element of the union operation (as 0 is the multiplication of absorbent element). </p>
</div>
<div class="toolbox-text custom pedagogic" key="text_set_adabsurdum">
 <p>The complement of the complement of a set is the set. This rule, elimination of double complement, is called 'ad absurdum', by analogy with the <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Raisonnement_par_l%27absurde" target="_blank">reduction ad absurdum</a></span> of classical logic, which is the rule for the elimination of double negation. </p>
</div>
<div key="text_set_comb">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_set_demorgan">
 <p> The complement of the intersection (resp. union) of two sets is the union (resp. intersection) complements of these sets. </p>
</div>
<div class="toolbox-text custom pedagogic" key="text_set_eq_symmetry">
 <p>The symmetry of set equality is available for set calculations.</p>
</div>
<div class="toolbox-text custom pedagogic" key="text_set_eq_trans">
 <p>Transitivity of set equality is available for set calculations.</p>
</div>
<div class="toolbox-text custom pedagogic" key="text_set_excluded">
 <p> Every element of the universe belong to either a set or to its complement, to the exclusion of any other possibility. </p>
</div>
<div key="text_set_inter_comb">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_set_lteq_transitivity">
 <p>The set inclusion is a transitive relation.</p>
</div>
<div class="toolbox-text custom pedagogic" key="text_set_neutral">
 <p> The empty set is the <span class="exturl"><a href="https://fr.wikipedia.org/wiki/%C3%89l%C3%A9ment_neutre" target="_blank">neutral element</a></span> of the union and the universe is the neutral element of the intersection (as 1 is the neutral element of the multiplication, and 0 is the neutral element of addition ). </p>
</div>
<div key="text_set_rewriting"></div>
<div key="text_set_union_comb">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_setassociative">
 <p> Intersection and union are associative operations. </p>
</div>
<div class="toolbox-text custom pedagogic" key="text_setcommutative">
 <p> Intersection and union are commutative operations. </p>
</div>
<div class="toolbox-text custom pedagogic" key="text_setdevelopp">
 <p> Intersection and union operations are distributive over one another. </p>
</div>
<div key="text_setexpr">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_setfactorize">
 <p> Intersection and union operations are distributive over one another. </p>
</div>
<div key="text_setfun"></div>
<div key="text_setgraph"></div>
<div key="text_setops"></div>
<div key="text_sigma"></div>
<div class="toolbox-text custom pedagogic" key="text_sigmadecompl">
</div>
<div key="text_sigmadef">
 <!--TODO-->
</div>
<div key="text_sigmaidx">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_sigmainverse">
 <p>Summed elements' order can be reversed to add (by commutative property of addition).</p>
</div>
<div class="toolbox-text custom pedagogic" key="text_sigmalinear">
 <p>One can factorize
  <!--{type="expr" input="lambda"}--> below only if
  <!--{type="expr" input="lambda"}--> does not depend on k.</p>
</div>
<div key="text_sigmarem"></div>
<div key="text_sigmaresult1">
 <!--TODO-->
</div>
<div key="text_sigmaresult2">
 <!--TODO-->
</div>
<div key="text_sigmaresult3">
 <!--TODO-->
</div>
<div key="text_sigmasimpl">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_sigmaupshift">
 <p>Shifting the index of the summed value.</p>
</div>
<div key="text_simpl"></div>
<div key="text_slim_def_elim">
 <!--TODO-->
</div>
<div key="text_slim_inf_def_elim">
 <!--TODO-->
</div>
<div key="text_slimfinite_inf_elim">
 <!--TODO-->
</div>
<div key="text_slteq"></div>
<div key="text_somesets"></div>
<div key="text_sophiehattheory"></div>
<div class="toolbox-text custom pedagogic" key="text_square_diff">
 <p>The factorization of the difference of squares is given by the formula: </p>
 <p>
  <!--{type="prop" sci="true" input="((pow a 2)-(pow b 2)) = ((a+b)*(a-b))"}--></p>
 <p>For example :</p>
</div>
<div key="text_subadd">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_trans_lt_gt">
 <p> If a is greater than b, which is greater than c, then a is greater than c. </p>
 <p>These rules are also available for double inequality</p>
</div>
<div key="text_true_at_rank">
 <!--TODO-->
</div>
<div key="text_truthlie">
 <!--TODO-->
</div>
<div key="text_updownsimpl">
 <!--TODO-->
</div>
<div class="toolbox-text custom pedagogic" key="text_varchange">
 <p>a change of variables is a basic technique used to simplify problems in which the original variables are replaced with functions of other variables</p>
 <p>In the example below, the equation
  <!--{type="expr" input="sqrt(x)"}--> is a second-degree equation in 'a', if
  <!--{type="prop" sci="true" style="vertical-align:-3px;" input="a=sqrt x"}--> : </p>
</div>
<div key="text_youngest">
 <!--TODO-->
</div>
