<div class="pedagogic paper" key="exercise_description_demo_bernoulli_1">
 <!--{type="ex_title"}-->
 <p> <span class="txtwrap slide" style="padding-top:15px"> <img src="./img/demo_bernoulli_1.png"> </span> </p>
 <p> Les puissances de 2 sont minorées par les valeurs de l'exposant, c'est à dire que
  <!--{type="expr" input="(pow 2 n) >= (plus n 1)"}-->, comme l'illustrent le graphe ci-contre et le tableau ci-dessous : </p>
 <center>
  <table class="borderblue">
    S
   <colgroup>
    <col width="60">
    <col width="60">
    <col width="60">
   </colgroup>
   <tbody>
    <tr>
     <td><span class="bold">
       <!--{type="expr" input="n"}--></span></td>
     <td><span class="bold">
       <!--{type="expr" input="n+1"}--></span></td>
     <td><span class="bold">
       <!--{type="expr" input="2^n"}--></span></td>
    </tr>
    <tr>
     <td>
      <!--{type="expr" input="0"}--></td>
     <td>
      <!--{type="expr" input="1"}--></td>
     <td>
      <!--{type="expr" input="1"}--></td>
    </tr>
    <tr>
     <td>
      <!--{type="expr" input="1"}--></td>
     <td>
      <!--{type="expr" input="2"}--></td>
     <td>
      <!--{type="expr" input="2"}--></td>
    </tr>
    <tr>
     <td>
      <!--{type="expr" input="2"}--></td>
     <td>
      <!--{type="expr" input="3"}--></td>
     <td>
      <!--{type="expr" input="4"}--></td>
    </tr>
    <tr>
     <td>
      <!--{type="expr" input="3"}--></td>
     <td>
      <!--{type="expr" input="4"}--></td>
     <td>
      <!--{type="expr" input="8"}--></td>
    </tr>
    <tr>
     <td>...</td>
     <td>...</td>
     <td>...</td>
    </tr>
   </tbody>
  </table>
 </center>
 <p> Cette inégalité est un cas particulier des <span class="exturl"><a href="https://fr.wikipedia.org/wiki/In%C3%A9galit%C3%A9_de_Bernoulli" target="_blank">inégalités de Bernoulli</a></span>, démontrées dans l'exercice ci-dessous : </p>
 <p>
  <!--{type="exercise" input="demo_bernoulli_2"}--> </p>
</div>
<div class="pedagogic paper" key="exercise_description_demo_bernoulli_2">
 <!--{type="ex_title"}-->
 <p>Ces inégalités généralisent le résultat du précédent exercice. Elles sont attribuées au mathématicien suisse <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Jacques_Bernoulli" target="_blank">Jacques Bernoulli</a></span>. On les appelle les <span class="exturl"><a href="https://fr.wikipedia.org/wiki/In%C3%A9galit%C3%A9_de_Bernoulli" target="_blank">inégalités de Bernoulli</a></span>.</p>
</div>
<div class="pedagogic paper" key="exercise_description_ineq_ex_8">
 <!--{type="ex_title"}-->
 <p>L'object est de démontrer le théorème d'addition terme à terme de deux inégalités. Ce théorème est donc verrouillé.</p>
</div>
<div class="pedagogic paper" key="exercise_description_logic_connector_abs_peirce">
 <!--{type="ex_title"}-->
 <p><span class="lock">w</span><span class="cons">Logique constructiviste</span></p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_connector_ex_easy_01">
 <!--{type="ex_title"}-->
 <p>On démontre que la disjonction est distributive <span class="stress">sur la conjonction</span>.</p>
 <p><span class="lock">w</span><span class="cons">Logique constructiviste</span></p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_connector_ex_easy_02">
 <!--{type="ex_title"}-->
 <p> On démontre que la conjonction est distributive <span class="stress">sur la disjonction</span>. </p>
 <p> <span class="lock">w</span><span class="cons">Logique constructiviste</span> </p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_connector_ex_easy_06">
 <!--{type="ex_title"}-->
 <p> Dans cet exercice, l'univers des éléments est l'ensemble des <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Entier_naturel" target="_blank">entiers naturels</a></span>. </p>
 <p> Les formules sont appelées des <span class="stress">propositions définies sur ℕ</span>, et les éléments sont les entiers. </p>
 <p> On note "
  <!--{type="prop" sci="true" input="forall (x:Nvar), app_prop U P x"}-->" et "
  <!--{type="prop" sci="true" input="exists (x:Nvar), app_prop U P x"}-->" les quantifications sur ℕ. </p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_connector_ex_easy_08">
 <!--{type="ex_title"}-->
 <a href="https://fr.wikipedia.org/wiki/L%27%C3%89cole_d%27Ath%C3%A8nes" target="_blank"><img class="txtwrap" src="./img/aristote-raphael-ecole-d-athenes.jpg" height="30%" width="30%"></a>
 <p> Le <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Syllogisme" target="_blank">syllogisme</a></span> est un raisonnement formalisé au 4<span class="sup">ème</span> siècle avant notre ère dans la <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Gr%C3%A8ce_antique" target="_blank">Grèce antique</a></span> par <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Aristote" target="_blank">Aristote</a></span> qui le considérait comme l'élément fondamental de la logique et du raisonnement. </p>
 <p> Le syllogisme a servi, et sert encore, de fondation logique au <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Droit" target="_blank">Droit</a></span> qui est né dans la <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Rome_antique#La_R.C3.A9publique_romaine" target="_blank">Rome antique</a></span>. Il est le schéma sur lequel sont construits les jugements de droit dans la tradition occidentale. </p>
 <p>Imaginons par exemple qu'un tribunal doive répondre à la question "Socrate est-il mortel ?". La réponse passe par la découverte d'un attribut "Homme". Posons les définitions :</p>
 <table class="slide">
  <colgroup>
   <col width="150">
   <col width="30">
   <col width="150">
  </colgroup>
  <tbody>
   <tr>
    <td style="padding-top: 10px; border-right: 1px solid whitesmoke; border-bottom: 1px solid whitesmoke;">Terme mineur</td>
    <td style="padding-top: 10px; border-right: 1px solid whitesmoke; border-bottom: 1px solid whitesmoke;">A</td>
    <td style="padding-top: 10px; border-bottom: 1px solid whitesmoke;">Socrate</td>
   </tr>
   <tr>
    <td style="border-right: 1px solid whitesmoke; border-bottom: 1px solid whitesmoke;">Terme moyen</td>
    <td style="border-right: 1px solid whitesmoke; border-bottom: 1px solid whitesmoke;">B</td>
    <td style="border-bottom: 1px solid whitesmoke;">être un Homme</td>
   </tr>
   <tr>
    <td style="border-right: 1px solid whitesmoke;">Terme majeur</td>
    <td style="border-right: 1px solid whitesmoke;">C</td>
    <td>être mortel</td>
   </tr>
  </tbody>
 </table>
 <p>Le jugement est alors établi suivant le schéma ci-dessous :</p>
 <table class="slide">
  <colgroup>
   <col width="150">
   <col width="140">
   <col width="250">
  </colgroup>
  <tbody>
   <tr>
    <td style="padding-top: 10px; border-right: 1px solid whitesmoke; border-bottom: 1px solid whitesmoke; vertical-align: middle;">Prémisse majeure</td>
    <td style="border-right: 1px solid whitesmoke; border-bottom: 1px solid whitesmoke; vertical-align: middle;">B ⇒ C</td>
    <td style="border-right: 1px solid whitesmoke; border-bottom: 1px solid whitesmoke; vertical-align: middle;"> Tous les Hommes sont mortels. (Homme ⇒ mortel)</td>
    <!--    <td style="border-bottom: 1px solid whitesmoke; vertical-align: middle;">La règle de droit</td> -->
   </tr>
   <tr>
    <td style="border-right: 1px solid whitesmoke; border-bottom: 1px solid whitesmoke; vertical-align: middle;">Prémisse mineure</td>
    <td style="border-right: 1px solid whitesmoke; border-bottom: 1px solid whitesmoke; vertical-align: middle;">A ⇒ B</td>
    <td style="border-right: 1px solid whitesmoke; border-bottom: 1px solid whitesmoke; vertical-align: middle;">Socrate est un Homme.</td>
    <!--    <td style="border-bottom: 1px solid whitesmoke; vertical-align: middle;"> La qualification juridique du terme mineur (Socrate) qui fait l’objet du procès.</td> -->
   </tr>
   <tr>
    <td style="border-right: 1px solid whitesmoke; border-bottom: 1px solid whitesmoke; vertical-align: middle;">Conclusion</td>
    <td style="border-right: 1px solid whitesmoke; border-bottom: 1px solid whitesmoke; vertical-align: middle;">A ⇒ C</td>
    <td style="border-right: 1px solid whitesmoke; border-bottom: 1px solid whitesmoke; vertical-align: middle;">Socrate est mortel.</td>
    <!--    <td style="border-bottom: 1px solid whitesmoke; vertical-align: middle;">Le jugement</td> -->
   </tr>
  </tbody>
 </table>
 <p> L'enjeu du procès est donc la qualification ou non du terme mineur (l'accusé) en terme moyen. L'apprentissage de l'esprit des lois (le sens donné aux lois) permettant au juge de décider, se fait par l'étude de la <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Jurisprudence" target="_blank">jurisprudence</a></span> qui est l'ensemble des décisions de justice. </p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_connector_ex_easy_12">
 <!--{type="ex_title"}-->
 <p>Cette implication n'est vraie qu'en logique classique. Cela ne pose pas de problème à son utilisation en électronique : soit le courant passe, soit il ne passe pas.</p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_connector_ex_easy_13">
 <!--{type="ex_title"}-->
 <a href="./img/Diopsis.jpg" target="_blank"><img class="txtwrap" src="./img/Diopsis.jpg" height="30%" width="30%"></a>
 <p>Les <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Lois_de_De_Morgan" target="_blank">lois de De Morgan</a></span> sont des formules permettant de calculer la négation de n'importe quelle proposition mathématique.</p>
 <p>On démontre que la négation d'une disjonction est la conjonction des négations des opérandes.</p>
 <p>Ces lois sont utilisées en informatique dans la conception des <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Fonction_logique" target="_blank">fonctions logiques</a></span> et de leur matérialisation physique sous forme notamment de <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Circuit_int%C3%A9gr%C3%A9">circuits intégrés</a></span>.</p>
 <p><span class="lock">w</span><span class="cons">Logique constructiviste</span></p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_connector_ex_easy_14">
 <!--{type="ex_title"}-->
 <p> Un <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Op%C3%A9rateur_(symbole)" target="_blank">opérateur</a></span> binaire, noté par exemple ★, est <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Associativit%C3%A9" target="_blank">associatif</a></span> si quels que soient les <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Op%C3%A9rande" target="_blank">opérandes</a></span> a b c : </p>
 <p>a ★ (b ★ c) = (a ★ b) ★ c</p>
 <p>Leur position n'ayant pas d'importance, les parenthèses peuvent être omises. La valeur ci-dessus s'écrit donc a ★ b ★ c. C'est par exemple l'associativité de l'addition qui permet d'écrire 3 + 5 + 8 sans besoin de faire figurer des parenthèses.</p>
 <p> <span class="lock">w</span><span class="cons">Logique constructiviste</span> </p>
 <div class="slide">
  <p>On démontre une équivalence en démontrant deux implications, par définition de l'équivalence. On choisit la définition <span class="buttontheo">équivalence</span> pour démontrer
   <!--{type="tag" input="s0"}-->. </p>
 </div>
</div>
<div class="custom pedagogic" key="exercise_description_logic_connector_ex_easy_16">
 <!--{type="ex_title"}-->
 <p> La <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Proposition_contrapos%C3%A9e" target="_blank">contraposée</a></span>, ou modus tollens, consiste à démontrer A implique B en démontrant que la négation de B implique la négation de A : si on n'avait pas B, on n'aurait pas A, donc si on a A, on a B. </p>
 <p> Ce raisonnement n'est vrai qu'en <span class="stress">logique classique</span>. En revanche, l'implication inverse,
  <!--{type="prop" sci="true" input="(A -> B) -> (~B -> ~A)"}--> est vraie en logique constructiviste, comme on le démontre dans l'exercice suivant. </p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_connector_ex_easy_17">
 <!--{type="ex_title"}-->
 <p>Dans ce sens, l'implication se démontre en logique constructiviste.</p>
 <p><span class="lock">w</span><span class="cons">Logique constructiviste</span></p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_connector_ex_easy_27">
 <!--{type="ex_title"}-->
 <p>De manière similaire à l'associativité de la conjonction, on démontre l'associativité de la disjonction.</p>
 <div class="slide">
  <p>Démontrer la disjonction
   <!--{type="prop" sci="true" input="or A B"}--> nécessite de <span class="stress">faire un choix</span> entre la démonstration de A et celle de B. </p>
  <p>La méthode consiste choisir le plus tard possible, et à exploiter d'abord toutes les hypothèses (par disjonction de cas) pour obtenir le maximum d'information permettant de décider.</p>
 </div>
 <p> <span class="lock">w</span><span class="cons">Logique constructiviste</span> </p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_connector_ex_easy_31">
 <!--{type="ex_title"}-->
 <p> Le <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Raisonnement_par_l%27absurde" target="_blank">raisonnement par l'absurde</a></span> consiste à démontrer une proposition A en montrant que si sa négation, ¬ A, est vraie, alors on obtient une contradiction : </p>
 <table class="slide">
  <colgroup>
   <col width="100%">
  </colgroup>
  <tbody>
   <tr>
    <td><span class="def">Raisonnement par l'absurde</span>
     <!--{type="prop" sci="true" input="forall A:Prop, ((~(~A)) -> A)"}--></td>
   </tr>
  </tbody>
  <tbody>
  </tbody>
 </table>
 <p> En effet,
  <!--{type="prop" sci="true" input="~(~A)"}--> se réécrit
  <!--{type="prop" sci="true" input="(~A -> False)"}--> par définition de la négation. Le raisonnement par l'absurde est donc une règle d'élimination de la double négation. </p>
 <p>On démontre dans cet exercice que le tiers exclu implique le raisonnement par l'absurde.</p>
 <p></p>
 <p> <span class="lock">w</span><span class="cons">Logique constructiviste</span> </p>
 <p>L'implication réciproque est démontrée dans l'exercice ci-dessous. Ainsi, le raisonnement par l'absurde est équivalent au tiers exclu, et n'est donc pas admis en logique constructiviste : </p>
 <p>
  <!--{type="exercise" input="logic_quantifier_ex_le_48"}--> </p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_connector_ex_easy_32">
 <!--{type="ex_title"}-->
 <p>On démontre que la disjonction de deux négations est la négation de la conjonction des propositions. Cette implication se fait en logique constructiviste, mais pas l'implication inverse comme on le constate dans l'exercice suivant.</p>
 <p> <span class="lock">w</span><span class="cons">Logique constructiviste</span> </p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_connector_ex_easy_33">
 <!--{type="ex_title"}-->
 <p>On démontre que la disjonction est distributive <span class="stress">sur l'implication</span>.</p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_connector_ex_easy_34">
 <!--{type="ex_title"}-->
 <p>On démontre que la conjonction est "à moitié distributive" sur l'implication.</p>
</div>
<div class="pedagogic paper" key="exercise_description_logic_connector_peirce_abs_te">
 <!--{type="ex_title"}-->
 <p><span class="lock">w</span><span class="cons">Logique constructiviste</span></p>
</div>
<div class="pedagogic paper" key="exercise_description_logic_connector_peirce_law">
 <!--{type="ex_title"}-->
 <p><a href="https://fr.wikipedia.org/wiki/Charles_Sanders_Peirce" target="_blank"><img class="txtwrap" src="./img/peirce.jpg" height="30%" width="30%"></a><span class="exturl"><a href="https://fr.wikipedia.org/wiki/Charles_Sanders_Peirce" target="_blank">Charles Sanders Peirce</a></span> est un sémiologue et philosophe américain de la seconde moitié du 19<span class="sup">ème</span> siècle. </p>
 <p> La <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Loi_de_Peirce" target="_blank">loi de Peirce</a></span> est vrai en logique classique.</p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_connector_tuto_01">
 <!--{type="ex_title"}-->
 <p>Que peut-on déduire de la conjonction "A ∧ B" ?</p>
 <p><span class="light-bulb">A</span>Suivre les indications de résolution (appuyer sur le bouton avec une ampoule en haut à droite de l'écran).</p>
 <!--  <p><span class="light-bulb">A</span>Un exercice possède une conclusion et un contexte initial qui pose les variables et les hypothèses.</p>
  <p><span class="light-bulb">A</span>La conclusion et les hypothèses sont des <span class="exturl"><a href="http://fr.wikipedia.org/wiki/Proposition" target="_blank">propositions mathématiques</a></span>. L'objectif est d'élaborer un enchaînement de propositions appelé <span class="exturl"><a href="http://fr.wikipedia.org/wiki/D%C3%A9monstration_%28math%C3%A9matiques_%C3%A9l%C3%A9mentaires%29" target="_blank">démonstration</a></span>, permettant de justifier la conclusion.</p> -->
</div>
<div class="custom pedagogic" key="exercise_description_logic_quantifier_21">
 <!--{type="ex_title"}-->
 <p>Il existe en Ecosse un club très fermé qui obéit aux règles suivantes :</p>
 <ul>
  <li> Tout membre non écossais porte des chaussettes rouges.</li>
  <li>Tout membre porte un kilt ou ne porte pas de chaussettes rouges.</li>
  <li>Les membres mariés ne sortent pas le dimanche.</li>
  <li>Un membre sort le dimanche si et seulement s’il est écossais.</li>
  <li>Tout membre qui porte un kilt est écossais et marié.</li>
  <li>Tout membre écossais porte un kilt.</li>
 </ul>
 <p>On démontre que ce club est si fermé qu’il ne peut accepter personne !</p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_quantifier_ex_03">
 <!--{type="ex_title"}-->
 <p>On démontre que le complément d'une union est l'intersection des compléments.</p>
 <p>On appelle cette formule une loi de De Morgan par analogie avec les lois de De Morgan établies pour les conjonctions et disjonctions. On constate en effet une similitude des propriétés (distributivité, associativité, commutativité) de l'union, de l'intersection et du complément, et celles de la disjonction, la conjonction et la négation respectivement.</p>
 <p>Cette analogie résulte de la définition des opérateurs ensemblistes : l'appartenance à l'union de deux ensembles est la disjonction des appartenances à chacun des deux ensembles.</p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_quantifier_ex_07">
 <!--{type="ex_title"}-->
 <p>On achève la démonstration de la distributivité de la quatification existentielle sur la disjonction.</p>
 <p> Il faut faire apparaître la valeur témoin inconnue <span class="button" style="font-family: 'Times New Roman'; font-weight: bold; font-size: 14px; padding: 3px;">x?</span> dans une portée (ou une sous-portée) qui contient la (les) variables(s) permettant de renseigner cette valeur témoin inconnue. Dans l'exemple ci-contre, la valeur témoin est fournie dans les portées créées <span class="buttontheo">par disjonction de cas</span>. Ce raisonnement est donc utilisé <span class="stress">avant</span> le raisonnement <span class="buttontheo">par construction</span>. </p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_quantifier_ex_09">
 <!--{type="ex_title"}-->
 <p>On montre que l'ensemble vide est un <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Inclusion_(math%C3%A9matiques)" target="_blank">sous-ensemble</a></span> de n'importe quel ensemble.</p>
</div>
<div class="pedagogic paper" key="exercise_description_logic_quantifier_ex_easy_08">
 <!--{type="ex_title"}-->
 <p>Quelle est la négation logique d'une quantification universelle ?</p>
 <p>La négation de "quel que soit x, F (x)" n'est pas "quel que soit x, non F (x)", mais "il existe x tel que non F (x)".</p>
 <p>On démontre ici une des deux implications.</p>
</div>
<div class="pedagogic paper" key="exercise_description_logic_quantifier_ex_easy_09">
 <!--{type="ex_title"}-->
 <p>Quelle est la négation logique d'une quantification existentielle ?</p>
 <p>La négation de "il existe x tel que F (x)" n'est pas "il existe x tel que non F (x)", mais "quel que soit x, non F (x)".</p>
</div>
<div class="pedagogic paper" key="exercise_description_logic_quantifier_ex_le_01">
 <!--{type="ex_title"}-->
 <p>La relation binaire sur ℕ "être plus petit que", notée
  <!--{type="prop" sci="true" input="app_rel rel_le x y"}-->, est définie dans ces exercices par une formule existentielle :</p>
 <table class="slide">
  <colgroup>
   <col width="100%">
  </colgroup>
  <tbody>
   <tr>
    <td> <span class="def">Etre plus petit que</span>
     <!--{type="prop" sci="true" input="forall (x y:Nvar), equiv (app_rel rel_le x y) (exists (z:Nvar),y=x+z)"}--> </td>
   </tr>
  </tbody>
  <tbody>
  </tbody>
 </table>
 <p>On démontre que l'addition est croissante pour cette relation.</p>
 <p>Exercices "être plus petit que" :</p>
 <p>
  <!--{type="exercise" input="logic_quantifier_ex_le_02"}-->
  <!--{type="exercise" input="logic_quantifier_ex_le_03"}--></p>
</div>
<div class="pedagogic paper" key="exercise_description_logic_quantifier_ex_le_02">
 <!--{type="ex_title"}-->
 <p>Exercices "être plus petit que" :</p>
 <p>
  <!--{type="exercise" input="logic_quantifier_ex_le_01"}-->
  <!--{type="exercise" input="logic_quantifier_ex_le_03"}--></p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_quantifier_ex_le_04">
 <!--{type="ex_title"}-->
 <p> <span class="def">source : <span class="exturl"><a href="http://www.lri.fr/~paulin/MathInfo" target="_blank">TP 1 Eléments de logique</a></span></span> </p>
 <p>Sur l'île des purs et des pires, il y a des habitants. Ces habitants sont soit des purs, soit des pires. Les purs disent toujours la vérité alors que les pires mentent toujours.</p>
 <p> Montrer que si <span style="font-weight: bold">a</span> et <span style="font-weight: bold">b</span> sont deux habitants de l'île et que <span style="font-weight: bold">a</span> dit que <span style="font-weight: bold">b</span> est pire, alors au moins l'un des deux est pire. </p>
 <p>On utilise l'axiome <span class="buttontheo">pur ou pire</span> pour générer deux cas : soit <span style="font-weight: bold">a</span> est pur, soit <span style="font-weight: bold">a</span> est pire. </p>
 <!-- La théorie "vérités et
    mensonges" est munie des axiomes suivants :
  </p>
  <table class="slide">
    <colgroup>
      <col width="25%">
      <col width="75%">
    </colgroup>
    <tbody>
      <tr>
      <tr>
        <td style="vertical-align: top"><span class="def"
          style="padding-top: 20px">Nature Pure ou pire</span></td>
        <td style="padding-top: 24px;"><span type="prop">forall
            (a:gbmember), (or (is_good a) (is_bad a))</span></td>
      </tr>
      <td style="vertical-align: top; padding-top: 8px"><span
        class="def">Vérité des purs</span></td>
      <td><span type="prop" style="padding-top: 20px">forall
          (a:gbmember) (P:Prop), (is_good a) -> (say a P) -> P</span></td>
      </tr>
      <tr>
        <td style="vertical-align: top; padding-top: 8px"><span
          class="def">Mensonge des pires</span></td>
        <td><span type="prop">forall (a:gbmember) (P:Prop),
            (is_bad a) -> (say a P) -> (~ P)</span></td>
      </tr>
    <tbody>
  </table>-->
</div>
<div class="custom pedagogic" key="exercise_description_logic_quantifier_ex_le_05">
 <!--{type="ex_title"}-->
 <p> <span class="def">source : <span class="exturl"><a href="http://www.lri.fr/~paulin/MathInfo" target="_blank">TP 1 Eléments de logique</a></span></span> </p>
 <p> Montrer que si <span style="font-weight: bold">a</span> dit que <span style="font-weight: bold">a</span> et <span style="font-weight: bold">b</span> sont tous les deux pires, alors <span style="font-weight: bold">a</span> est pire. </p>
 <p> Les exercices "vérités et mensonges" : </p>
 <!--{type="exercise" input="logic_quantifier_ex_le_04"}-->
 <!--{type="exercise" input="logic_quantifier_ex_le_05"}-->
 <!--{type="exercise" input="logic_quantifier_ex_le_06"}-->
 <!--{type="exercise" input="logic_quantifier_ex_le_07"}-->
</div>
<div class="custom pedagogic" key="exercise_description_logic_quantifier_ex_le_06">
 <!--{type="ex_title"}-->
 <p> <span class="def">source : <span class="exturl"><a href="http://www.lri.fr/~paulin/MathInfo" target="_blank">TP 1 Eléments de logique</a></span></span> </p>
 <p> Montrer que si <span style="font-weight: bold">a</span> dit une
  <!--{type="expr" input="False"}--> alors c'est un pire. </p>
 <p></p> Les exercices "vérités et mensonges" :
 <p></p>
 <!--{type="exercise" input="logic_quantifier_ex_le_04"}-->
 <!--{type="exercise" input="logic_quantifier_ex_le_05"}-->
 <!--{type="exercise" input="logic_quantifier_ex_le_06"}-->
 <!--{type="exercise" input="logic_quantifier_ex_le_07"}-->
</div>
<div class="custom pedagogic" key="exercise_description_logic_quantifier_ex_le_07">
 <!--{type="ex_title"}-->
 <p> <span class="def">source : <span class="exturl"><a href="http://www.lri.fr/~paulin/MathInfo" target="_blank">TP 1 Eléments de logique</a></span></span> </p>
 <p>Montrer qu'un habitant ne peut pas dire qu'il est lui-même un pire.</p>
 <p></p> Les exercices "vérités et mensonges" :
 <p></p>
 <!--{type="exercise" input="logic_quantifier_ex_le_04"}-->
 <!--{type="exercise" input="logic_quantifier_ex_le_05"}-->
 <!--{type="exercise" input="logic_quantifier_ex_le_06"}-->
 <!--{type="exercise" input="logic_quantifier_ex_le_07"}-->
</div>
<div class="pedagogic paper" key="exercise_description_logic_quantifier_ex_le_13">
 <!--{type="ex_title"}-->
 <!--  <a href="https://fr.wikipedia.org/wiki/Principe_des_tiroirs" target="_blank"><img class="txtwrap" src="http://img.1.im6.fr/03E8000007913469-photo-dressing-tiroir-casiers-chaussettes.jpg" height="30%" width="30%"></img></a> -->
 <span class="def">source : <span class="exturl"><a href="http://www.lri.fr/~paulin/MathInfo" target="_blank">TP 2 Relations et fonctions</a></span></span>
 <p> En 1834, le mathématicien allemand <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Johann_Peter_Gustav_Lejeune_Dirichlet" target="_blank">Johann Dirichlet</a></span> énonça le <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Principe_des_tiroirs" target="_blank">principe des tiroirs</a></span>, qui s'applique dans le cas où n chaussettes occupent m tiroirs : </p>
 <p style="align: center; font-style: italic">Si n &gt; m, alors au moins un tiroir doit contenir strictement plus d'une chaussette.</p>
 <p> Autrement dit, par <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Proposition_contrapos%C3%A9e" target="_blank">contraposée</a></span>, si chaque tiroir contient au plus une chaussette, alors n &lt;= m. </p>
 <p> Considérons une <span class="stress">fonction f de rangement</span> de n+1 chaussettes, indexées de 0 à n, dans des tiroirs : elle prend en argument l'indice d'une chaussette et retourne l'indice d'un tiroir. La condition qu'un tiroir contient au plus une chaussette, se traduit par le fait que la fonction de rangement est <span class="stress">injective</span> : deux chaussettes se rangent dans deux tiroirs différents. De plus, puisque par hypothèse m tiroirs contiennent les chaussettes, il existe une chaussette, indicée x, telle que f(x)=m. </p>
 <p>Démontrer le principe des tiroirs consiste donc à démontrer que si la fonction f est injective sur l'ensemble [0 ... n], alors il existe une chaussette indicée x, telle que son tiroir, f(x), est supérieur ou égal à n.</p>
 <p>Pour simplifier, on va raisonner sur une notion plus forte que l'injectivité et considérer des fonctions strictement croissantes :</p>
 <table class="slide">
  <colgroup>
   <col width="100%">
  </colgroup>
  <tbody>
   <tr>
    <td>
     <!--{type="prop" sci="true" input=" forall (n:Nvar) (f:NvarFun), equiv (FFMono n f) (forall (x y:Nvar), ExprLT x y -> ExprLT y n -> ExprLT (app_fun f x) (app_fun f y))"}--></td>
   </tr>
  </tbody>
  <tbody>
  </tbody>
 </table>
 <p>On démontre ci-contre que la croissance stricte est bien une condition plus forte que l'injectivité sur [0 ... n], qui s'exprime ici de la manière suivante :</p>
 <table class="slide">
  <colgroup>
   <col width="100%">
  </colgroup>
  <tbody>
   <tr>
    <td>
     <!--{type="prop" sci="true" input="forall (n:Nvar) (f:NvarFun), equiv (FFInj n f) (forall (x y:Nvar), ExprLT x n -> ExprLT y n -> app_fun f x = app_fun f y -> nvar x = nvar y)"}--></td>
   </tr>
  </tbody>
  <tbody>
  </tbody>
 </table>
 <p>Le principe des tiroirs est démontré dans l'exercice suivant à partir de la croissance stricte de la fonction de rangement.</p>
 <p> </p>
 <h3>Résolution</h3>
 <p> Effectuer un raisonnement à base de cas à l'aide de
  <!--{type="tag" input="2"}-->. </p>
 <p>Utiliser les raisonnements ci-dessous sur les égalités et les inégalités :</p>
 <table class="slide">
  <colgroup>
   <col width="100%">
  </colgroup>
  <tbody>
   <tr>
    <td><span class="def">Symétrie de l'égalité</span>
     <!--{type="prop" sci="true" input="forall (x y:O1U), (equiv (x=y) (y=x))"}--><br><br>
     <!--{type="prop" sci="true" input="forall (x y:O1U), (equiv (x<>y) (y<>x))"}--></td>
   </tr>
  </tbody>
  <tbody>
  </tbody>
 </table>
 <table class="slide">
  <colgroup>
   <col width="100%">
  </colgroup>
  <tbody>
   <tr>
    <td><span class="def">Réécriture symétrique de l'inégalité</span>
     <!--{type="prop" sci="true" input="forall (x y:O1U), (equiv (ExprGT x y) (ExprLT y x))"}--><br><br>
     <!--{type="prop" sci="true" input="forall (x y:O1U), (equiv (ExprGTEQ x y) (ExprLTEQ y x))"}--></td>
   </tr>
  </tbody>
  <tbody>
  </tbody>
 </table>
 <table class="slide">
  <colgroup>
   <col width="100%">
  </colgroup>
  <tbody>
   <tr>
    <td><span class="def">Inégalité stricte</span>
     <!--{type="prop" sci="true" input="forall (x y:O1U), (ExprGT x y) -> (x <> y)"}--><br><br>
     <!--{type="prop" sci="true" input="forall (x y:O1U), (ExprLT x y) -> (x <> y)"}--></td>
   </tr>
  </tbody>
  <tbody>
  </tbody>
 </table>
</div>
<div class="pedagogic paper" key="exercise_description_logic_quantifier_ex_le_14">
 <!--{type="ex_title"}-->
 <span class="def">source : <span class="exturl"><a href="http://www.lri.fr/~paulin/MathInfo" target="_blank">TP 2 Relations et fonctions</a></span></span>
 <p>Le principe des tiroirs est présenté dans l'exercice précédent. Il s'agit de démontrer que si une fonction est injective sur [0 .. n], alors il existe x dans [0 ... n] tel que f(x) ≥ n. </p>
 <p>On a démontré précédemment qu'une condition suffisante pour être injective sur [0 ... n] est d'être strictement croissante sur [0 ... n].</p>
 <p>Le principe des tiroirs est démontré ci-contre avec l'hypothèse de croissance stricte.</p>
 <div class="slide">
  <p> Utiliser un raisonnement par récurrence sur n. </p>
 </div>
 <p>Les théorèmes suivants sont disponibles pour transformer une inégalité entre deux entiers en une inégalité stricte, et inversement :</p>
 <table class="slide">
  <colgroup>
   <col width="100%">
  </colgroup>
  <tbody>
   <tr>
    <td><span class="def">Transition vers l'entier suivant</span>
     <!--{type="prop" sci="true" input="forall (x y:O1U), (equiv (ExprGT x y) (ExprGTEQ x (y+1)))"}--><br><br>
     <!--{type="prop" sci="true" input="forall (x y:O1U), (equiv (ExprGTEQ x y) (ExprGT (x+1) y))"}--></td>
   </tr>
  </tbody>
  <tbody>
  </tbody>
 </table>
 <p>Les différentes formes de la transitivité des relations d'ordres permettent également d'introduire ou d'éliminer des inégalités, strictes ou non :</p>
 <table class="slide">
  <colgroup>
   <col width="100%">
  </colgroup>
  <tbody>
   <tr>
    <td><span class="def">Transitivité</span>
     <!--{type="prop" sci="true" input="forall (x y z:O1U), (ExprGT x y) -> (ExprGT y z) -> (ExprGT x z)"}--><br><br>
     <!--{type="prop" sci="true" input="forall (x y z:O1U), (ExprGTEQ x y) -> (ExprGT y z) -> (ExprGT x z)"}--><br><br>
     <!--{type="prop" sci="true" input="forall (x y z:O1U), (ExprGT x y) -> (ExprGTEQ y z) -> (ExprGT x z)"}--><br><br>
     <!--{type="prop" sci="true" input="forall (x y z:O1U), (ExprGTEQ x y) -> (ExprGTEQ y z) -> (ExprGTEQ x z)"}--><br><br>
     <!--{type="prop" sci="true" input="forall (x y z:O1U), (ExprGT x y) -> (ExprGTEQ y z) -> (ExprGTEQ x z)"}--><br><br>
     <!--{type="prop" sci="true" input="forall (x y z:O1U), (ExprGTEQ x y) -> (ExprGT y z) -> (ExprGTEQ x z)"}--></td>
   </tr>
  </tbody>
  <tbody>
  </tbody>
 </table>
</div>
<div class="custom pedagogic" key="exercise_description_logic_quantifier_ex_le_27">
 <!--{type="ex_title"}-->
 <p>Ce résultat est disponible dans les autres exercices en tant que <span class="buttontheo">caratérisation ensembliste</span> d'une relation transitive.</p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_quantifier_ex_le_31">
 <!--{type="ex_title"}-->
 <p> Utiliser la caractérisation ensembliste d'une relation transitive, et la conservation de l'inclusion par composition. </p>
 <p> <span class="light-bulb">A</span>Sélectionner un terme avec la souris dans une proposition permet de le remplacer par un autre terme ; il faut alors pouver l'égalité avec le terme remplacé. </p>
 <h3>Voir également</h3>
 <p>
  <!--{type="exercise" input="logic_quantifier_ex_le_27"}-->
  <!--{type="exercise" input="logic_quantifier_ex_le_47"}--> </p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_quantifier_ex_le_47">
 <!--{type="ex_title"}-->
 <p>La composition conserve l'inclusion.</p>
 <p> Ce résultat est disponible dans les autres exercices en tant que combinaison par <span class="buttontheo">composition</span>. </p>
</div>
<div class="custom pedagogic" key="exercise_description_logic_quantifier_ex_le_48">
 <!--{type="ex_title"}-->
 <p>On démontre la règle du tiers exclu en supposant admis le raisonnement par l'absurde.</p>
 <p><span class="lock">w</span><span class="cons">Logique constructiviste</span></p>
</div>
<div class="pedagogic paper" key="exercise_description_logic_quantifier_ex_le_71">
 <!--{type="ex_title"}-->
 <p>Madame Confuse a trois enfants, Alice Bill et Carl.</p>
 <p>Quand on lui demande l'âge de ses enfants, Mme Confuse répond qu'Alice est la plus jeune, à moins que Bill le soit, et que si Carl n'est pas le plus jeune alors Alice est la plus âgée.</p>
 <p>Quel est l'enfant le plus jeune, quel est l'enfant le plus âgé ?</p>
 <!--  <h3>Formalisation</h3> -->
 <p>On suppose que les enfants sont différents et qu'il n'ont pas le même âge.</p>
 <p><span class="light-bulb">A</span>La réponse de Mme Confuse est modélisée par les hypothèses <span class="propid">4</span> et <span class="propid">5</span>.</p>
 <p>Utiliser les axiomes ci-contre pour déterminer l'enfant le plus jeune.</p>
 <!--  <p>De plus, si un enfant est le plus vieux (le plus jeune), alors il n'est pas le plus jeune (le plus âgé) :</p>
    <table class="slide">
    <colgroup>
      <col width="100%">
    </colgroup>
    <tbody>
      <tr>
        <td>
    <span class="def">Antonymie</span>
    <span type="prop">forall (x:Child), (Youngest x) -> (~(Oldest x))</span><br></br>
    <span type="prop">forall (x:Child), (Oldest x) -> (~(Youngest x))</span>
        </td>
      </tr>
    <tbody>
  </table>
  <p>Enfin, si un enfant est le plus jeune (le plus âgé), alors n'importe quel autre enfant n'est pas le plus jeune (le plus âgé)</p>
    <table class="slide">
    <colgroup>
      <col width="100%">
    </colgroup>
    <tbody>
      <tr>
        <td>
    <span class="def">Unicité</span>
    <span type="prop">forall (x y:Child), (x <> y) -> (Youngest x) -> (~(Youngest y))</span><br></br>
    <span type="prop">forall (x y:Child), (x <> y) -> (Oldest x) -> (~(Oldest y))</span>
        </td>
      </tr>
    <tbody>
  </table> -->
</div>
<div class="pedagogic paper" key="exercise_description_logic_quantifier_ex_le_72">
 <p> <span class="def">source : <span class="exturl"> <a href="http://images.math.cnrs.fr/Coqito-ergo-sum.html" target="_blank"> Aurélien Alvarez pour lemonde.fr </a> </span> </span> </p>
 <h2 style="margin-top:0">Enoncé</h2>
 <p style="position:relative;left:-30px"><iframe frameborder="0" width="400" height="225" src="http://www.dailymotion.com/embed/video/xzpqbm" allowfullscreen></iframe><br></p>
 <h2>Solution</h2>
 <p style="position:relative;left:-30px"><iframe frameborder="0" width="400" height="225" src="http://www.dailymotion.com/embed/video/xzpqco" allowfullscreen></iframe></p>
 <p><span class="stress">A vous de jouer !</span> résolvez l'énigme à l'aide de l'axiomatique mise à disposition.</p>
</div>
<div class="pedagogic paper" key="exercise_description_sigma_ex_15">
 <!--{type="ex_title"}-->
 <p>Si on considère la suite des n premiers entiers ordonnés du plus grand au plus petit, on constate que la somme du ième élément de cette suite et du ième premier entier est égale à n+1, quel que soit i. </p>
 <p>Le tableau ci-dessous illustre ce phénomène (la dernière colonne est la somme des autres) : </p>
 <table class="borderblue">
  <colgroup>
   <col width="80">
   <col width="15">
   <col width="15">
   <col width="15">
   <col width="15">
   <col width="140">
  </colgroup>
  <tbody>
   <tr>
    <td><span class="bold">Croissant</span></td>
    <td>
     <!--{type="expr" input="1"}--></td>
    <td>
     <!--{type="expr" input="2"}--></td>
    <td><span>...</span></td>
    <td>
     <!--{type="expr" input="n"}--></td>
    <td>
     <!--{type="expr" input="S"}--></td>
   </tr>
   <tr>
    <td><span class="bold">Décroissant</span></td>
    <td>
     <!--{type="expr" input="n"}--></td>
    <td>
     <!--{type="expr" input="n-1"}--></td>
    <td><span>...</span></td>
    <td>
     <!--{type="expr" input="1"}--></td>
    <td>
     <!--{type="expr" input="S"}--></td>
   </tr>
   <tr>
    <td><span class="bold">Somme</span></td>
    <td>
     <!--{type="expr" input="n+1"}--></td>
    <td>
     <!--{type="expr" input="n+1"}--></td>
    <td><span>...</span></td>
    <td>
     <!--{type="expr" input="n+1"}--></td>
    <td>
     <!--{type="expr" input="2*S"}--> =
     <!--{type="expr" input="n*(n+1)"}--></td>
   </tr>
  </tbody>
 </table>
 <p>Utiliser le <span class="buttontheo">parcours à rebours</span> pour obtenir la somme des entiers du plus grand au plus petit
  <!--{type="expr" style="vertical-align:-3px;" input="(sigma(k,0,n,n-k))"}-->.</p>
 <p><span class="lock">w</span> La formule <span class="buttontheo">premiers entiers</span> est verrouillée dans cet exercice.</p>
</div>
<div class="pedagogic paper" key="exercise_description_sigma_ex_16">
 <!--{type="ex_title"}-->
 <p>Utiliser l'identité <span class="propid">1</span> le plus tôt possible. Cette identité s'obtient en développant
  <!--{type="expr" input="(n+1)^3"}--> :</p>
 <table>
  <colgroup>
   <col width="500">
  </colgroup>
  <tbody>
   <tr>
    <td style="border-color: whitesmoke;">
     <!--{type="expr" input="(n+1)^3"}--> <span style="margin : 5px">=</span>
     <!--{type="expr" input="(n+1)*((n^2)+(2*n)+1)"}--> <span style="margin : 5px">=</span>
     <!--{type="expr" input="(n^3)+(3*(n^2))+(3*n)+1"}--> </td>
   </tr>
  </tbody>
 </table>
 <p><span class="lock">w</span> La formule <span class="buttontheo">premiers carrés</span> est verrouillée dans cet exercice.</p>
</div>
<div key="help_description_icon_exercises_check">
 <p>exercice résolu. Cliquer sur 'commencer' pour charger la solution.</p>
</div>
<div key="help_description_icon_exercises_difficulty">
 <p>difficulté de l'exerices (le nombre de flammes, de 0 à 3, indique le niveau de difficulté).</p>
</div>
<div key="help_description_icon_exercises_lighbulb">
 <p>Indications (les exercices de didacticiel offrent ce service)</p>
</div>
<div key="help_description_icon_exercises_lock">
 <p>Verrou. L'obtention des cocardes 'didacticiel' du chapitre courant (et éventuellement des chapitres prérequis) permet de débloquer l'accès à l'exercice.</p>
</div>
<div key="help_description_icon_trophy_all">
 <p>La cocarde 'universel' est obtenue lorsque tous les exercices du chapitre sont résolus.</p>
</div>
<div key="help_description_icon_trophy_diagnostic">
 <p>La cocarde 'express' est obtenue lorsque tous les exercices marqués 'express' sont résolus. L'obtention de cette cocarde rend accessibles dans le diagnostic les théorèmes du chapitres.</p>
</div>
<div key="help_description_icon_trophy_tutorial">
 <p>La cocarde 'didacticiel' est obtenue lorsque tous les exercices de didacticiel sont résolus.</p>
</div>
<div key="help_description_icon_trophy_unavoidable">
 <p>La cocarde 'Incontournable' est obtenue lorsque tous les exercices incontournables du chapitre sont résolus.</p>
</div>
<div key="help_description_shortcut_browsing_left_scope">
 <p>Afficher la portée à gauche de la portée courante</p>
</div>
<div key="help_description_shortcut_browsing_lower_prop">
 <p>Déplacer le focus sur la propostion en dessous de la proposition courante</p>
</div>
<div key="help_description_shortcut_browsing_open_scope">
 <p>Ouvrir la portée de justification</p>
</div>
<div key="help_description_shortcut_browsing_redo">
 <p>Exécuter l'étape de démonstration annulée</p>
</div>
<div key="help_description_shortcut_browsing_right_scope">
 <p>Afficher la portée à droite de la portée courante.</p>
</div>
<div key="help_description_shortcut_browsing_undo">
 <p>Annuler la dernière étape de démonstration</p>
</div>
<div key="help_description_shortcut_browsing_upper_prop">
 <p>Déplacer le focus sur la proposition au dessus de la proposition courante.</p>
</div>
<div key="help_description_shortcut_commutativity_commut_left">
 <p>Sélectionner le terme à gauche.</p>
</div>
<div key="help_description_shortcut_commutativity_commut_mode">
 <p>Activer le mode commutativité au clavier.</p>
</div>
<div key="help_description_shortcut_commutativity_commut_right">
 <p>Sélectionner le terme de droite.</p>
</div>
<div key="help_description_shortcut_commutativity_commut_shift_left">
 <p>Déplacer le terme sélectionné à gauche.</p>
</div>
<div key="help_description_shortcut_commutativity_commut_shift_right">
 <p>Déplacer le terme sélectionné à droite.</p>
</div>
<div key="help_description_shortcut_commutativity_enter_commut">
 <p>Appliquer l'ordre des termes pour la commutativité.</p>
</div>
<div key="help_description_shortcut_commutativity_esc_commut">
 <p>Sortir du mode commutativité au clavier.</p>
</div>
<div key="help_description_shortcut_evar_enter_evar">
 <p>Affecter une valeur à une inconnue de raisonnement</p>
</div>
<div key="help_description_shortcut_evar_esc_evar">
 <p>Sortir du mode affectation d'une inconnue de raisonnement au clavier</p>
</div>
<div key="help_description_shortcut_evar_evar_left">
 <p>Sélectionner l'inconnue de raisonnement précédente</p>
</div>
<div key="help_description_shortcut_evar_evar_mode">
 <p>Activer le mode affectation d'une inconnue de raisonnement au clavier</p>
</div>
<div key="help_description_shortcut_evar_evar_right">
 <p>Sélectionner l'inconnue de raisonnement suivante</p>
</div>
<div key="help_description_shortcut_proof_context">
 <p>Afficher/cacher le contexte (propositions des autres portées disponibles en déduction) </p>
</div>
<div key="help_description_shortcut_proof_deduce">
 <p>Ouvrir la fenêtre de diagnostic en déduction</p>
</div>
<div key="help_description_shortcut_proof_enter">
 <p>Effectuer une des actions suivantes :</p>
 <ul>
  <li style="font-size:14px">Ouvrir la fenêtre de diagnostic en déduction si la proposition est justifiée</li>
  <li style="font-size:14px">Ouvrir la fenêtre de diagnostic en justification si la proposition n'est pas justifiée</li>
  <li style="font-size:14px">Unifier avec la proposition proposée par la copie numérique</li>
 </ul>
</div>
<div key="help_description_shortcut_proof_justify">
 <p>Effectuer une des actions suivantes :</p>
 <ul>
  <li style="font-size:14px">Ouvrir la fenêtre de diagnostic en justification si la proposition n'est pas justifiée</li>
  <li style="font-size:14px">Afficher le théorème dans la boîte à outil si la proposition est justifiée</li>
 </ul>
</div>
<div key="help_description_shortcut_selection_enter_select">
 <p>Ouvrir la fenêtre de diagnostic de réécriture du terme sélectionné</p>
</div>
<div key="help_description_shortcut_selection_esc_select">
 <p>Sortir du mode sélection au clavier</p>
</div>
<div key="help_description_shortcut_selection_group_select">
 <p>Marquer le terme sélectionné comme groupe (permet de garder le terme intact lors des réécritures)</p>
</div>
<div key="help_description_shortcut_selection_select_down">
 <p>Sélectionner le premier argument</p>
</div>
<div key="help_description_shortcut_selection_select_left">
 <p>Sélectionner l'argument précédent</p>
</div>
<div key="help_description_shortcut_selection_select_mode">
 <p>Activer le mode sélection au clavier</p>
</div>
<div key="help_description_shortcut_selection_select_right">
 <p>Sélectionner l'argument suivant</p>
</div>
<div key="help_description_shortcut_selection_select_shift_left">
 <p>Augmenter la sélection avec l'argument précédent</p>
</div>
<div key="help_description_shortcut_selection_select_shift_right">
 <p>Augmenter la sélection avec l'argument suivant</p>
</div>
<div key="help_description_shortcut_selection_select_up">
 <p>Sélectionner la fonction dont l'argument est le terme sélectionné</p>
</div>
<div key="help_description_shortcut_unification_enter_union">
 <p>Unifier avec la proposition sélectionnée</p>
</div>
<div key="help_description_shortcut_unification_esc_union">
 <p>Sortir du mode unification au clavier</p>
</div>
<div key="help_description_shortcut_unification_left_union">
 <p>Sélectionner la propostion à gauche</p>
</div>
<div key="help_description_shortcut_unification_right_union">
 <p>Sélectionner la proposition à droite</p>
</div>
<div key="help_description_shortcut_unification_union_mode">
 <p>Activer le mode unfication au clavier</p>
</div>
<div key="help_section_description_browsing">
 <p>Le raisonnement est présenté dans le style de la déduction naturelle : les propositions justifiées sont disposées les unes sous les autres, avec les hypothèses en tête et la conclusion en dernier.</p>
 <p>Une justification est un théorème appliqué à des propositions qui se situent au-dessus de la propostion justifiée. Une justification peut également être un raisonnement, qui se trouve alors dans une autre portée logique (représentée par un onglet).</p>
 <p>On navigue dans la copie à la souris, ou en mettant le focus sur la proposition souhaitée à l'aide des raccourcis clavier ci-dessous :</p>
</div>
<div key="help_section_description_commutativity">
 <p>Lorsque l'on choisit la réécriture par commutativité, on spécifie l'ordre des termes soit à la souris par glisser-lâcher, soit à l'aide des raccourcis clavier ci-dessous :</p>
</div>
<div key="help_section_description_evar">
 <p>L'application de certains théorèmes peut faire apparaître dans la copie des inconnues de raisonnement (un identifiant dans une pastille bleue)</p>
 <p>On renseigne les valeurs de ces inconnues soit en cliquant dessus, soit à l'aide des raccourcis clavier ci-dessous :</p>
</div>
<div key="help_section_description_exercises">
 <!--TODO-->
</div>
<div key="help_section_description_proof">
 <p>Plusieurs actions de démonstration sont possibles :</p>
 <ul>
  <li style="font-size:14px">Justifier (si la proposition n'est pas déjà justifiée)</li>
  <li style="font-size:14px">Unifier (si des propositions unifiables sont proposées)</li>
  <li style="font-size:14px">Déduire</li>
  <li style="font-size:14px">Supprimer (si la proposition n'est pas utilisée par une justification)</li>
  <li style="font-size:14px">Déplacer par glisser-lâcher de l'indice de la proposition (sous contrainte du style déductif : une proposition ne peut être qu'au dessus d'une proposition qui l'utilise dans sa justification)</li>
 </ul>
 <p>Les raccourcis clavier ci-dessous sont disponibles :</p>
</div>
<div key="help_section_description_selection">
 <p>Les opérations de réécriture (développement, factorisation, ...) sont possibles en sélectionnant le terme à réécrire</p>
 <p>La sélection se fait soit à la souris, soit à l'aide des raccourcis clavier ci-dessous :</p>
</div>
<div key="help_section_description_trophy">
 <!--TODO-->
</div>
<div key="help_section_description_unification">
 <p>Lorsque plusieurs unifications sont possibles, il faut sélectionner la proposition adéquate, soit à la souris, soit à l'aide des raccourcis clavier ci-dessous :</p>
</div>
<div key="pager_account"></div>
<div class="pager" key="pager_algebra">
 <a href="https://fr.wikipedia.org/wiki/%C3%89variste_Galois" target="_blank"><img class="txtwrap" src="./img/Evariste_galois.jpg" height="20%" width="20%"></a>
 <p>Les <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Structure_alg%C3%A9brique" target="_blank">structures algébriques</a></span> sont les objets d'étude de ce chapitre.</p>
 <p> Au début du XIX<span class="sup">ème</span> siècle, <span class="exturl"><a href="https://fr.wikipedia.org/wiki/%C3%89variste_Galois" target="_blank">Evariste Galois</a></span> introduit le concept de <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Groupe_(math%C3%A9matiques)" target="_blank">groupe</a></span>. </p>
</div>
<div key="pager_algebra_structures"></div>
<div class="pager" key="pager_analysis">
 <a href="https://fr.wikipedia.org/wiki/Augustin_Louis_Cauchy" target="_blank"><img class="txtwrap" src="./img/Augustin-Louis_Cauchy_1901.jpg" height="12%" width="12%"></a>
 <p> Au cours du 19<span class="sup">ème</span> siècle, les mathématiciens posent les bases de l’analyse des propriétés des fonctions réelles (fonctions à valeur réelle) : continutité, convergence, limite, dérivation, intégration, ... </p>
 <p></p>
 <p> En France dès le début du siècle, <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Augustin_Louis_Cauchy" target="_blank">Augustin Louis Cauchy</a></span> étudie notamment les propriétés de convergence des suites croissantes positives, introduites dans ce chapitre. En Allemagne, <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Bernhard_Riemann" target="_blank">Bernhard Riemann</a></span> et <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Karl_Weierstrass" target="_blank">Karl Weierstrass</a></span> élaborent les théories de l’intégration et des limites de fonction. </p>
</div>
<div class="pager" key="pager_analysis_induction">
 <p> Le <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Raisonnement_par_r%C3%A9currence" target="_blank">raisonnement par récurrence</a></span> est un raisonnement incontournable, simple et puissant. Il permet de démontrer qu’une proposition P(n), dépendant d’un indice n, est vraie quelle que soit la valeur de l’indice, c’est à dire notamment vraie pour une infinité de valeurs de l’indice n. </p>
 <p> Par exemple, sans le raisonnement par récurrence, il faudrait une infinité de calculs (ou une très grande quantité) pour avoir la certitude (ou quasi-certitude) que la proposition “
  <!--{type="expr" input="4^n - 1"}--> est divisible par 3” est vraie quelle que soit la valeur de n, alors qu’un raisonnement par récurrence donne la certitude en quelques lignes de démonstration. </p>
</div>
<div class="pager" key="pager_analysis_limits">
 <p>La limite d’une fonction en un point ou en l’infini est introduite formellement. La méthode de calcul par composition de limites est présentée : par exemple, sous certaines conditions, la limite d’une somme est la somme des limites. Cette méthode permet de calculer la limite de n’importe quelle fonction par décomposition en fonctions élémentaires, dont on connaît les valeurs limites. </p>
</div>
<div class="pager" key="pager_analysis_series">
 <p> Une suite est une fonction de ℕ dans ℝ. On introduit ici quelques propriétés fondamentales des ces fonctions : </p>
 <ul>
  <li>croissance, décroissance</li>
  <li>majoration, minoration</li>
  <li>convergence, divergence</li>
 </ul>
</div>
<div key="pager_badges"></div>
<div key="pager_credits"></div>
<div key="pager_dashboard"></div>
<div class="custom pager" key="pager_demo_seg">
 <p>Le calcul algébrique consiste à transformer une relation d'égalité (ou d'inégalité), entre des nombres réels ou des vecteurs par exemple. L'enjeu est d'élaborer une séquence de transformations (factorisation, développement, ...) pour démontrer certaines propriétés mathématiques.</p>
</div>
<div class="pager" key="pager_eq_seg">
 <p>Une égalité peut se transformer, notamment à l’aide des transformations introduites dans ce chapitre :</p>
 <ul>
  <li>les opérations à gauche et à droite, qui permettent de “passer un terme de l’autre côté” en changeant son signe</li>
  <li>les combinaisons d’égalité, qui permettent typiquement de résoudre des systèmes d’équation</li>
  <li>le passage au carré, ou le passage à la racine carrée (si la valeur est positive), ...</li>
 </ul>
</div>
<div class="pager" key="pager_ineq_seg">
 <p>Les inégalités comparent deux nombres réels. Elles se transforment de manière similaire aux égalités :</p>
 <ul>
  <li>opérations à gauche et à droite</li>
  <li>combinaisons (addition, soustraction)</li>
  <li>applications de fonctions (opposé, carré, racine, …)</li>
  <li>…</li>
 </ul>
 <p>Si la transformation appliquée à gauche et à droite d’une inégalité est une fonction décroissante, le sens de l’inégalité entre les valeurs obtenues est inversé.</p>
</div>
<div class="pager" key="pager_logic">
 <p>Les règles de formation des <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Proposition" target="_blank">propositions</a></span>, et les règles de raisonnement associées, forment un système logique, appelé <span class="exturl"><a href="https://fr.wikipedia.org/wiki/D%C3%A9duction_naturelle" target="_">déduction naturelle</a></span>, utilisé notamment dans l'élaboration des <span class="exturl"><a href="https://fr.wikipedia.org/wiki/D%C3%A9monstration_(math%C3%A9matiques_%C3%A9l%C3%A9mentaires)" target="_blank">démonstrations</a></span> mathématiques.</p>
 <p>La valeur de ce système tient notamment dans le fait qu’il est indépendant de la théorie étudiée. Une théorie est l'ensemble des axiomes (théorèmes admis) définissant des objets et leurs propriétés.</p>
</div>
<div class="pager" key="pager_logic_connector">
 <p>Les connecteurs logiques sont des éléments fondamentaux pour former des propositions mathématiques à partir de deux propositions quelconques A et B :</p>
 <ul>
  <li>l’implication, A implique B, notée "A ⇒ B"</li>
  <li>la conjonction, A et B, notée "A ∧ B"</li>
  <li>la disjonction, A ou B, notée "A ∨ B"</li>
  <li>la négation, non A, notée "¬ A"</li>
 </ul>
 <p>Chacun de ces connecteurs est associé à deux régles :</p>
 <ul>
  <li>une règle permettant de justifier (ou démontrer) la proposition : comment justifier "A ∧ B" ?</li>
  <li>une règle permettant de déduire une nouvelle proposition : que peut on déduire de "A ∧ B" ?</li>
 </ul>
</div>
<div class="pager" key="pager_logic_function">
 <p>Une fonction f d'une variable x d'un univers A, est une procédure de calcul d'un élément y d'un univers B telle que la proposition "y=f(x)" est une relation fonctionnelle de A vers B.</p>
</div>
<div class="pager" key="pager_logic_quantifier">
 <p>Les propositions mathématiques peuvent également être des formules avec des variables prenant certaines valeurs : par exemple “3 est un nombre premier” peut être considéré comme la formule “x est un nombre premier” où la variable “x” prend la valeur “3”.</p>
 <p>Pour une formule à variable, on a besoin d’exprimer que la proposition obtenue est vraie <span class="stress" style="font-size:16px">quelle que soit</span> la valeur de la variable, ou qu’<span class="stress" style="font-size:16px">il existe</span> au moins une valeur pour laquelle la proposition est vraie. Ces nouveaux éléments de langage sont les quantificateurs.</p>
</div>
<div class="pager" key="pager_logic_relation">
 <p>Les relations, omniprésentes en mathématiques, sont des formules mettant en relation deux valeurs appartenant à deux univers, potentiellement différents. On parle de relation binaire lorsque les valeurs appartiennent au même univers.</p>
 <p>La caractérisation ensembliste des relations, ainsi que leurs propriétés, sont présentées.</p>
</div>
<div class="pager" key="pager_rewrite_seg">
 <p>Les réécritures permettent de déduire d’une égalité, une égalité presque identique dans laquelle un terme
  <!--{type="expr" input="a"}--> est remplacé par un terme
  <!--{type="expr" input="b"}-->, à condition que
  <!--{type="prop" sci="true" style="vertical-align:-3px;" input="a = b"}-->. Les réécritures de a en b sont données par le calcul algébrique :</p>
 <ul>
  <li>factorisation, développement</li>
  <li>idéntitiés remarquables</li>
  <li>simplifications</li> ...
 </ul>
 <p>Par exemple, on peut déduire de
  <!--{type="prop" sci="true" style="vertical-align:-3px;" input="x=(2*(x-1))"}--> la proposition
  <!--{type="prop" sci="true" style="vertical-align:-3px;" input="x= (2*x) - 2"}--> en remplaçant le terme
  <!--{type="expr" input="2*(x-1)"}--> par
  <!--{type="expr" input="minus (2*x) 2"}--> ; on sait en effet que
  <!--{type="prop" sci="true" style="vertical-align:-3px;" input="(2*(x-1)) = ((2*x)-2)"}--> par développement.</p>
</div>
<div class="pager" key="pager_set_operators">
 <p>Un ensemble E est une collection d'objets qu'on appelle <span class="stress" style="font-size:16px">les éléments</span> de E.</p>
 <p>La proposition qu'un élément x appartient à E, ou est élément de E, se note <span class="stress" style="font-size:16px">
   <!--{type="prop" sci="true" input="sis_element x E"}--></span>. La négation de l'appartenance, ¬(
  <!--{type="prop" sci="true" input="sis_element x E"}-->), se note <span class="stress" style="font-size:16px">
   <!--{type="prop" sci="true" input="~sis_element x E"}--></span>. </p>
 <p>Un <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Op%C3%A9ration_ensembliste" target="blank">opérateur ensembliste</a></span> permet de construire un ensemble à partir d'autres ensembles.</p>
</div>
<div class="pager" key="pager_set_rewoperators">
 <p>Les calculs algébriques sur les ensembles ressemblent aux calculs sur les nombres parce que : </p>
 <ul>
  <li>les opérations ensemblistes (intersection, union, ...) ont des propriétés similaires aux opérations numériques (addition, multiplication, ...) : associativité, commutativité, distributivité, ... </li>
  <li>l'égalité ensembliste et l'égalité numérique sont des relations d'équivalence qui sont transitives, symétriques et réflexives (voir section suivante)</li>
 </ul>
 <p>L'algèbre ensembliste est équivalente à l'<span class="exturl"><a href="https://fr.wikipedia.org/wiki/Alg%C3%A8bre_de_Boole_(logique)" target="_blank">algèbre booléenne</a></span> : soit un élement appartient à un ensemble, soit il n'y appartient pas. Cette algèbre est centrale en informatique, dans l'écriture des programmes et dans l'élaboration des circuits électroniques. </p>
</div>
<div class="pager" key="pager_settheory">
 <a href="https://fr.wikipedia.org/wiki/Georg_Cantor" target="_blank"><img class="txtwrap" src="./img/cantor.jpg" height="12%" width="12%"></a>
 <p> A la fin du 19<span class="sup">ème</span> siècle, le mathématicien allemand <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Georg_Cantor" target="_blank">Georg Cantor</a></span> élabore la <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Th%C3%A9orie_des_ensembles" target="_blank">théorie des ensembles</a></span>. Elle permet de définir les éléments fondamentaux des mathématiques, notamment les nombres entiers, les nombres réels, les fonctions ... </p>
 <p>En 1930, le mathématicien austro-hongrois <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Kurt_G%C3%B6del" target="_blank">Kurt Gödel</a></span> montre même que n'importe quelle théorie peut se traduire dans la théorie des ensembles. </p>
</div>
<div class="pager" key="pager_sigma_seg">
 <p>La notation sigma sert à faire la somme des termes d’une série de n nombres indéxés notés
  <!--{type="expr" input="app_series a i"}--> (avec l'indice i compris entre 1 et n typiquement). Cette somme se note :
  <!--{type="expr" style="vertical-align: -4px;" input="(sigma(k,1,n,(app_series a k)))"}-->.</p>
 <p>Dans cette notation, l'indice k est une variable muette : elle n'est pas déclarée dans le contexte et n'est valable que pour l'expression sommée.</p>
 <p>Les propriétés du sigma sont celles de l’addition (associativité, distributivité de la multiplication, …) et celles des changements d’écriture de l’indexation des nombres sommés.</p>
</div>
<div key="slide_demo_tuto_app_(3 * x - 6 = zero,lradd,0)">
 <!--   (3 * x - 6 = zero,lradd,0)
  by Forward lradd)
 -->
 <div expr="(3 * x - 6 = zero,lradd,0)" class="pedagogic slide" exercise="demo_tuto_app">
  <p>L'objectif est d'<span class="stress">isoler
    <!--{type="expr" input="pow x 2"}--></span> à gauche. On commence donc par isoler x à gauche comme dans les exercices précédents, puis on passe au carré à gauche et à droite.</p>
 </div>
</div>
<div key="slide_demo_tuto_app_(3 * x = 6,lrdiv,0)">
 <!--   (3 * x = 6,lrdiv,0)
  by Forward lrdiv)
 -->
 <div expr="(3 * x = 6,lrdiv,0)" class="pedagogic slide" exercise="demo_tuto_app">
  <p>On divise par 3 à gauche et à droite pour isoler x.</p>
 </div>
</div>
<div key="slide_demo_tuto_app_(x = 2,app_square,0)">
 <!--   (x = 2,app_square,0)
  by Forward app_square)
 -->
 <div expr="(x = 2,app_square,0)" class="pedagogic slide" exercise="demo_tuto_app">
  <p>On applique la fonction carré à gauche et à droite.</p>
 </div>
</div>
<div key="slide_demo_tuto_comb_(3 * x - y = zero,combadd,0)">
 <!--   (3 * x - y = zero,combadd,0)
  by Forward combadd)
 -->
 <div expr="(3 * x - y = zero,combadd,0)" class="pedagogic slide" exercise="demo_tuto_comb">
  <p>L'objectif est d'isoler x en commençant par <span class="stress">éliminer y</span>. On constate que y apparaît à gauche dans la proposition
   <!--{type="tag" input="s0"}--> et que l'opposé de y apparaît à gauche dans
   <!--{type="tag" input="s1"}-->.</p>
  <p>On peut donc éliminer y en additionnant membre à membre
   <!--{type="tag" input="s1"}--> et
   <!--{type="tag" input="s0"}-->.</p>
 </div>
</div>
<div key="slide_demo_tuto_comb_(4 * x = 4,lrdiv,0)">
 <!--   (4 * x = 4,lrdiv,0)
  by Forward lrdiv)
 -->
 <div expr="(4 * x = 4,lrdiv,0)" class="pedagogic slide" exercise="demo_tuto_comb">
  <p>On isole x en éliminant le coefficiant 4 par division à gauche et à droite par 4.</p>
 </div>
</div>
<div key="slide_demo_tuto_first_(2 * x + 1 = 5,lrsub,0)">
 <!--   (2 * x + 1 = 5,lrsub,0)
  by Forward lrsub)
 -->
 <div expr="(2 * x + 1 = 5,lrsub,0)" class="pedagogic slide" exercise="demo_tuto_first">
  <p>L'objectif est d'<span class="stress">isoler
    <!--{type="expr" input="x"}--></span> à gauche de l'égalité, c'est-à-dire d'obtenir, par opérations successives, une égalité de la forme x=… .</p>
  <p>On commence par isoler
   <!--{type="expr" input="2*x"}--> en éliminant 1 à gauche, par soustraction à gauche et à droite de 1.</p>
 </div>
</div>
<div key="slide_demo_tuto_first_(2 * x = 4,lrdiv,0)">
 <!--   (2 * x = 4,lrdiv,0)
  by Forward lrdiv)
 -->
 <div expr="(2 * x = 4,lrdiv,0)" class="pedagogic slide" exercise="demo_tuto_first">
  <p> On isole
   <!--{type="expr" input="x"}--> en élimiant le facteur 2, par division à gauche et à droite par 2 (qui est différent de 0). </p>
 </div>
</div>
<div key="slide_demo_tuto_first_(find_expr x 2)">
 <!--   (find_expr x 2)
  by Backward (find_expr_intro)
 -->
 <div expr="(find_expr x 2)" class="pedagogic slide" exercise="demo_tuto_first">
 </div>
</div>
<div key="slide_demo_tuto_fun_(( fanonym  (SReals) (sunknown Expr) (x) (3 * x)),app_def,0)">
 <!--   (( fanonym  (SReals) (sunknown Expr) (x) (3 * x)),app_def,0)
  by Forward app_def)
 -->
 <div expr="(( fanonym  (SReals) (sunknown Expr) (x) (3 * x)),app_def,0)" class="pedagogic slide" exercise="demo_tuto_fun">
 </div>
</div>
<div key="slide_demo_tuto_fun_(( fanonym  (SReals) (sunknown Expr) (x) (x)),app_def,0)">
 <!--   (( fanonym  (SReals) (sunknown Expr) (x) (x)),app_def,0)
  by Forward app_def)
 -->
 <div expr="(( fanonym  (SReals) (sunknown Expr) (x) (x)),app_def,0)" class="pedagogic slide" exercise="demo_tuto_fun">
 </div>
</div>
<div key="slide_demo_tuto_fun_((app_expr f a) = 3 * a,combadd,0)">
 <!--   ((app_expr f a) = 3 * a,combadd,0)
  by Forward combadd)
 -->
 <div expr="((app_expr f a) = 3 * a,combadd,0)" class="pedagogic slide" exercise="demo_tuto_fun">
 </div>
</div>
<div key="slide_demo_tuto_fun_((app_expr g b) = b,lrmul,0)">
 <!--   ((app_expr g b) = b,lrmul,0)
  by Forward lrmul)
 -->
 <div expr="((app_expr g b) = b,lrmul,0)" class="pedagogic slide" exercise="demo_tuto_fun">
 </div>
</div>
<div key="slide_demo_tuto_neq_(2 * x <> 4,lrsub_neq,0)">
 <!--   (2 * x <> 4,lrsub_neq,0)
  by Forward lrsub_neq)
 -->
 <div expr="(2 * x <> 4,lrsub_neq,0)" class="pedagogic slide" exercise="demo_tuto_neq">
  <p>On soustrait 4 à gauche et à droite de
   <!--{type="tag" input="s2"}-->. </p>
 </div>
</div>
<div key="slide_demo_tuto_neq_(x <> 2,lrmul_neq,0)">
 <!--   (x <> 2,lrmul_neq,0)
  by Forward lrmul_neq)
 -->
 <div expr="(x <> 2,lrmul_neq,0)" class="pedagogic slide" exercise="demo_tuto_neq">
  <p>L'objectif est d'obtenir le membre de gauche de
   <!--{type="tag" input="s1"}--> à l'aide des opérations à gauche et à droite.</p>
  <p> On multiplie par 2 à gauche et à droite de
   <!--{type="tag" input="s1"}-->.</p>
 </div>
</div>
<div key="slide_demo_tuto_rel_(x + 1 = 1,lrsub,0)">
 <!--   (x + 1 = 1,lrsub,0)
  by Forward lrsub)
 -->
 <div expr="(x + 1 = 1,lrsub,0)" class="pedagogic slide" exercise="demo_tuto_rel">
  <p>On soustrait 1 à gauche et à droite de
   <!--{type="tag" input="s4"}-->.</p>
 </div>
</div>
<div key="slide_demo_tuto_rel_(y + 2 = 3,lrsub,0)">
 <!--   (y + 2 = 3,lrsub,0)
  by Forward lrsub)
 -->
 <div expr="(y + 2 = 3,lrsub,0)" class="pedagogic slide" exercise="demo_tuto_rel">
  <p>L'objectif est d'isoler x en élimiant y par transitivité. On commence par isoler y dans
   <!--{type="tag" input="s1"}-->. </p>
 </div>
</div>
<div key="slide_demo_tuto_rel_(y = 1,eq_trans,2)">
 <!--   (y = 1,eq_trans,2)
  by Forward eq_trans)
 -->
 <div expr="(y = 1,eq_trans,2)" class="pedagogic slide" exercise="demo_tuto_rel">
  <p>On élimine y par transitivité.</p>
 </div>
</div>
<div key="slide_demo_tuto_sigma_(( sigma( k, zero, zero, k)) = (zero * (zero + 1)) / 2)">
 <!-- 	(( sigma( k, zero, zero, k)) = (zero * (zero + 1)) / 2)
	by Backward select of select ( sigma( k, zero, zero, k)) = (zero * (zero + 1)) / 2 (sigmasimpl)
 -->
 <div expr="(( sigma( k, zero, zero, k)) = (zero * (zero + 1)) / 2)" class="pedagogic slide" exercise="demo_tuto_sigma">
 </div>
</div>
<div key="slide_demo_tuto_sigma_((forall n : Nvar, ( sigma( k, zero, n, k)) = (n * (n + 1)) / 2))">
 <!-- 	((forall n : Nvar, ( sigma( k, zero, n, k)) = (n * (n + 1)) / 2))
	by Backward (elim_true_at_rank)
 -->
 <div expr="((forall n : Nvar, ( sigma( k, zero, n, k)) = (n * (n + 1)) / 2))" class="pedagogic slide" exercise="demo_tuto_sigma">
 </div>
</div>
<div key="slide_demo_tuto_sigma_((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)))">
 <!-- 	((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)))
	by Section
 -->
 <div expr="((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)))" class="pedagogic slide" exercise="demo_tuto_sigma">
 </div>
</div>
<div key="slide_demo_tuto_sigma_((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)),( sigma( k, zero, n + 1, k)) = ((n * (n + 1)) / 2 + n) + 1,reducedenom,0)">
 <!-- 	((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)),( sigma( k, zero, n + 1, k)) = ((n * (n + 1)) / 2 + n) + 1,reducedenom,0)
	by Forward select of ( sigma( k, zero, n + 1, k)) = select (((n * (n + 1)) / 2 + n) + 1) (reducedenom)
 -->
 <div expr="((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)),( sigma( k, zero, n + 1, k)) = ((n * (n + 1)) / 2 + n) + 1,reducedenom,0)" class="pedagogic slide" exercise="demo_tuto_sigma">
 </div>
</div>
<div key="slide_demo_tuto_sigma_((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)),( sigma( k, zero, n + 1, k)) = ((n + 1) * (n + 2)) / 2,commutativity,0)">
 <!-- 	((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)),( sigma( k, zero, n + 1, k)) = ((n + 1) * (n + 2)) / 2,commutativity,0)
	by Forward select of ( sigma( k, zero, n + 1, k)) = select ((n + 2) * (n + 1)) / 2 (commutativity)
 -->
 <div expr="((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)),( sigma( k, zero, n + 1, k)) = ((n + 1) * (n + 2)) / 2,commutativity,0)" class="pedagogic slide" exercise="demo_tuto_sigma">
 </div>
</div>
<div key="slide_demo_tuto_sigma_((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)),( sigma( k, zero, n + 1, k)) = (n * (n + 1) + 2 * (n + 1)) / 2,factorize,0)">
 <!-- 	((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)),( sigma( k, zero, n + 1, k)) = (n * (n + 1) + 2 * (n + 1)) / 2,factorize,0)
	by Forward select of ( sigma( k, zero, n + 1, k)) = select (n * (n + 1) + 2 * (n + 1)) / 2 (factorize)
 -->
 <div expr="((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)),( sigma( k, zero, n + 1, k)) = (n * (n + 1) + 2 * (n + 1)) / 2,factorize,0)" class="pedagogic slide" exercise="demo_tuto_sigma">
 </div>
</div>
<div key="slide_demo_tuto_sigma_((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)),( sigma( k, zero, n, k)) + (n + 1) = (n * (n + 1)) / 2 + (n + 1),sigmadef,0)">
 <!-- 	((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)),( sigma( k, zero, n, k)) + (n + 1) = (n * (n + 1)) / 2 + (n + 1),sigmadef,0)
	by Forward select of select ((( sigma( k, zero, n, k)) + n) + 1) = ((n * (n + 1)) / 2 + n) + 1 (sigmadef)
 -->
 <div expr="((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)),( sigma( k, zero, n, k)) + (n + 1) = (n * (n + 1)) / 2 + (n + 1),sigmadef,0)" class="pedagogic slide" exercise="demo_tuto_sigma">
 </div>
</div>
<div key="slide_demo_tuto_sigma_((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)),( sigma( k, zero, n, k)) = (n * (n + 1)) / 2,lradd,0)">
 <!-- 	((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)),( sigma( k, zero, n, k)) = (n * (n + 1)) / 2,lradd,0)
	by Forward lradd)
 -->
 <div expr="((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)),( sigma( k, zero, n, k)) = (n * (n + 1)) / 2,lradd,0)" class="pedagogic slide" exercise="demo_tuto_sigma">
 </div>
</div>
<div key="slide_demo_tuto_sigma_((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)),true_at_rank P (n + 1))">
 <!-- 	((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)),true_at_rank P (n + 1))
	by Backward (red_true_at_rank)
 -->
 <div expr="((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)),true_at_rank P (n + 1))" class="pedagogic slide" exercise="demo_tuto_sigma">
 </div>
</div>
<div key="slide_demo_tuto_sigma_((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)),true_at_rank P n,red_true_at_rank,0)">
 <!-- 	((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)),true_at_rank P n,red_true_at_rank,0)
	by Forward red_true_at_rank)
 -->
 <div expr="((forall n : Nvar, true_at_rank P n -> true_at_rank P (n + 1)),true_at_rank P n,red_true_at_rank,0)" class="pedagogic slide" exercise="demo_tuto_sigma">
 </div>
</div>
<div key="slide_demo_tuto_sigma_((forall n : Nvar, true_at_rank P n))">
 <!-- 	((forall n : Nvar, true_at_rank P n))
	by Backward (ind_basic_forall)
 -->
 <div expr="((forall n : Nvar, true_at_rank P n))" class="pedagogic slide" exercise="demo_tuto_sigma">
 </div>
</div>
<div key="slide_demo_tuto_sigma_(true_at_rank P zero)">
 <!-- 	(true_at_rank P zero)
	by Backward (red_true_at_rank)
 -->
 <div expr="(true_at_rank P zero)" class="pedagogic slide" exercise="demo_tuto_sigma">
 </div>
</div>
<div key="slide_logic_connector_tuto_01_(and B A)">
 <!-- 	(and B A)
	by Backward (conj)
 -->
 <div expr="(and B A)" class="pedagogic slide" exercise="logic_connector_tuto_01">
 </div>
</div>
<div key="slide_logic_connector_tuto_02_(and A B,elim_conj_left,0)">
 <!--   (and A B,elim_conj_left,0)
  by Forward elim_conj_left)
 -->
 <div expr="(and A B,elim_conj_left,0)" class="pedagogic slide" exercise="logic_connector_tuto_02">
 </div>
</div>
<div key="slide_logic_connector_tuto_02_(and A B,elim_conj_right,0)">
 <!--   (and A B,elim_conj_right,0)
  by Forward elim_conj_right)
 -->
 <div expr="(and A B,elim_conj_right,0)" class="pedagogic slide" exercise="logic_connector_tuto_02">
 </div>
</div>
<div key="slide_logic_connector_tuto_02_(and B A)">
 <!--   (and B A)
  by Backward (conj)
 -->
 <div expr="(and B A)" class="pedagogic slide" exercise="logic_connector_tuto_02">
  <p>
   <!--<span class="light-bulb">ń</span>--> Comme dans l'exemple précédent, on justifie la conjonction
   <!--{type="tag" input="s1"}--> en invoquant la règle <span class="buttontheo">par conjonction</span>. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_03_(or A B)">
 <!--   (or A B)
  by Backward (intro_or_right)
 -->
 <div expr="(or A B)" class="pedagogic slide" exercise="logic_connector_tuto_03">
  <p>
   <!--<span class="light-bulb">ń</span>--> Le choix entre A et B pour prouver
   <!--{type="tag" input="s1"}--> <span class="buttontheo">par disjonction</span> est simple car seule la proposition B est fournie en hypothèse
   <!--{type="tag" input="s0"}-->. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_04_(case P (or Q P))">
 <!--   (case P (or Q P))
  by Section
 -->
 <div expr="(case P (or Q P))" class="pedagogic slide" exercise="logic_connector_tuto_04">
  <p>
   <!--<span class="light-bulb">ń</span>--> Démontrer Q ∨ P dans le cas où <span class="stress">P est vraie</span>, consiste à créer une <span class="stress">portée logique</span> dans laquelle P est une hypothèse et Q ∨ P est la conclusion, à l'aide du bouton <span class="buttonscope-wrapper"> <span class="buttonscope">↵</span></span>. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_04_(case P (or Q P),or Q P)">
 <!--   (case P (or Q P),or Q P)
  by Backward (intro_or_right)
 -->
 <div expr="(case P (or Q P),or Q P)" class="pedagogic slide" exercise="logic_connector_tuto_04">
  <p>
   <!--<span class="light-bulb">ń</span>--> On se retrouve dans cette portée exactement dans la même situation que dans l'exercice précédent. La démonstration de la disjonction
   <!--{type="tag" input="s2_1"}--> se fait en choisissant P qui est vraie par hypothèse
   <!--{type="tag" input="s2_0"}-->. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_04_(case Q (or Q P))">
 <!--   (case Q (or Q P))
  by Section
 -->
 <div expr="(case Q (or Q P))" class="pedagogic slide" exercise="logic_connector_tuto_04">
  <p>
   <!--<span class="light-bulb">ń</span>--> Démontrer Q ∨ P dans le cas où <span class="stress">Q est vraie</span>, consiste à créer une <span class="stress">portée logique</span> dans laquelle Q est une hypothèse et Q ∨ P est la conclusion, à l'aide du bouton <span class="buttonscope-wrapper"><span class="buttonscope">↵</span></span>. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_04_(case Q (or Q P),or Q P)">
 <!--   (case Q (or Q P),or Q P)
  by Backward (intro_or_left)
 -->
 <div expr="(case Q (or Q P),or Q P)" class="pedagogic slide" exercise="logic_connector_tuto_04">
  <p>
   <!--<span class="light-bulb">ń</span>--> On se retrouve dans cette portée exactement dans la même situation que dans l'exercice précédent. La démonstration de la disjonction
   <!--{type="tag" input="s3_1"}--> se fait en choisissant P qui est vraie par hypothèse
   <!--{type="tag" input="s3_0"}-->. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_04_(or Q P)">
 <!--   (or Q P)
  by Backward (case_base)
 -->
 <div expr="(or Q P)" class="pedagogic slide" exercise="logic_connector_tuto_04">
  <p>
   <!--<span class="light-bulb">ń</span>-->Le raisonnement <span class="buttontheo">par disjonction de cas</span> est disponible pour justifier une proposition lorsqu'une disjonction est présente. </p>
  <p> On démontre
   <!--{type="tag" input="s1"}--> à l'aide de la disjonction
   <!--{type="tag" input="s0"}--> par disjonction de cas. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_06_(A -> (B -> and A B))">
 <!--   (A -> (B -> and A B))
  by Section
 -->
 <div expr="(A -> (B -> and A B))" class="pedagogic slide" exercise="logic_connector_tuto_06">
  <p>
   <!--<span class="light-bulb">ń</span>--> Le bouton
   <!--{type="button_section"}--> permet de créer la portée logique ayant A en hypothèse et
   <!--{type="prop" input="(B -> (and A B))"}--> en conclusion. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_06_(A -> (B -> and A B),B -> and A B)">
 <!--   (A -> (B -> and A B),B -> and A B)
  by Section
 -->
 <div expr="(A -> (B -> and A B),B -> and A B)" class="pedagogic slide" exercise="logic_connector_tuto_06">
  <p>
   <!--<span class="light-bulb">ń</span>--> De nouveau, le bouton
   <!--{type="button_section"}--> permet de créer la portée logique ayant A et B en hypothèses et "A ∧ B" en conclusion. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_06_(B -> and A B,A -> (B -> and A B),and A B)">
 <!--   (B -> and A B,A -> (B -> and A B),and A B)
  by Backward (conj)
 -->
 <div expr="(B -> and A B,A -> (B -> and A B),and A B)" class="pedagogic slide" exercise="logic_connector_tuto_06">
  <p>
   <!--<span class="light-bulb">ń</span>--> On se retrouve dans la situation du premier exercice de ce didacticiel (prouver une conjonction). On prouve
   <!--{type="tag" input="s3_1"}--> par conjonction à l'aide des hypothèses
   <!--{type="tag" input="s2_0"}--> et
   <!--{type="tag" input="s3_0"}-->. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_07_(B)">
 <!--   (B)
  by Backward (modus_ponens)
 -->
 <div expr="(B)" class="pedagogic slide" exercise="logic_connector_tuto_07">
  <p>
   <!--<span class="light-bulb">ń</span>--> On déduit B de l'implication
   <!--{type="tag" input="s0"}--> si A est vraie. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_085_(A -> False,modus_ponens,0)">
 <!--   (A -> False,modus_ponens,0)
  by Forward modus_ponens)
 -->
 <div expr="(A -> False,modus_ponens,0)" class="pedagogic slide" exercise="logic_connector_tuto_085">
  <p>
   <!--<span class="light-bulb">ń</span>--> Le <span class="stress">modus ponens</span> permet de déduire le faux de
   <!--{type="tag" input="s3"}-->. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_085_(~ A,elim_negation,0)">
 <!--   (~ A,elim_negation,0)
  by Forward elim_negation)
 -->
 <div expr="(~ A,elim_negation,0)" class="pedagogic slide" exercise="logic_connector_tuto_085">
  <p>
   <!--<span class="light-bulb">ń</span>--> Traduire la négation
   <!--{type="tag" input="s0"}--> en une implication du faux, par définition de la négation. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_08_(A -> False)">
 <!--   (A -> False)
  by Section
 -->
 <div expr="(A -> False)" class="pedagogic slide" exercise="logic_connector_tuto_08">
  <p>
   <!--<span class="light-bulb">ń</span>--> Le bouton <span class="buttonscope-wrapper"><span class="buttonscope">↵</span></span> permet de créer une portée dans laquelle A est une hypothèse.</p>
 </div>
</div>
<div key="slide_logic_connector_tuto_08_(A -> False,B)">
 <!--   (A -> False,B)
  by Backward (modus_ponens)
 -->
 <div expr="(A -> False,B)" class="pedagogic slide" exercise="logic_connector_tuto_08">
  <p>
   <!--<span class="light-bulb">ń</span>--> Le <span class="stress">modus ponens</span> permet de justifier B par l'hypothèse A à l'aide de
   <!--{type="tag" input="s0"}-->. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_08_(A -> False,False)">
 <!--   (A -> False,False)
  by Backward (modus_ponens)
 -->
 <div expr="(A -> False,False)" class="pedagogic slide" exercise="logic_connector_tuto_08">
  <p>
   <!--<span class="light-bulb">ń</span>--> Le <span class="stress">modus ponens</span> permet de justifier le faux par l'hypothèse B à l'aide de
   <!--{type="tag" input="s2"}-->. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_08_(~ A)">
 <!--   (~ A)
  by Backward (elim_negation)
 -->
 <div expr="(~ A)" class="pedagogic slide" exercise="logic_connector_tuto_08">
  <p>
   <!--<span class="light-bulb">ń</span>--> Traduire la négation
   <!--{type="tag" input="s0"}--> en une implication du faux, par définition de la négation. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_09_(A,intro_false,0)">
 <!--   (A,intro_false,0)
  by Forward intro_false)
 -->
 <div expr="(A,intro_false,0)" class="pedagogic slide" exercise="logic_connector_tuto_09">
  <p>
   <!--<span class="light-bulb">ń</span>-->Cliquer sur <span class="context">Contexte</span> permet de faire apparaître les propositions des portées supérieures. On se retrouve alors exactement dans la situation de l'exercice précédent. On peut donc justifier directement la contradiction
   <!--{type="tag" input="s3"}--> en invoquant le principe de <span class="buttontheo">non-contradiction</span>. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_09_(B)">
 <!--   (B)
  by Backward (falseall)
 -->
 <div expr="(B)" class="pedagogic slide" exercise="logic_connector_tuto_09">
  <p>
   <!--<span class="light-bulb">ń</span>--> La contradiction flagrante des hypothèses
   <!--{type="tag" input="s0"}--> et
   <!--{type="tag" input="s2"}--> invite à justifier B à l'aide <span class="buttontheo">ex falso quodlibet</span>. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_10_(case (~ A) (or A B))">
 <!--   (case (~ A) (or A B))
  by Section
 -->
 <div expr="(case (~ A) (or A B))" class="pedagogic slide" exercise="logic_connector_tuto_10">
  <p>
   <!--<span class="light-bulb">ń</span>--> Lorsque ¬ A est vraie, on démontre "A ∨ B" en choisissant B, que l'on obtient par déduction de ¬ A à l'aide de
   <!--{type="tag" input="s0"}-->. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_10_(case (~ A) (or A B),or A B)">
 <!--   (case (~ A) (or A B),or A B)
  by Backward (intro_or_right)
 -->
 <div expr="(case (~ A) (or A B),or A B)" class="pedagogic slide" exercise="logic_connector_tuto_10">
  <p>
   <!--<span class="light-bulb">ń</span>--> Lorsque ¬ A est vraie, on démontre "A ∨ B" en choisissant B, que l'on obtient par déduction de ¬ A à l'aide de
   <!--{type="tag" input="s0"}-->. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_10_(case A (or A B))">
 <!--   (case A (or A B))
  by Section
 -->
 <div expr="(case A (or A B))" class="pedagogic slide" exercise="logic_connector_tuto_10">
  <p>
   <!--<span class="light-bulb">ń</span>--> Lorsque A est vraie, on démontre "A ∨ B" en choisissant A. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_10_(case A (or A B),or A B)">
 <!--   (case A (or A B),or A B)
  by Backward (intro_or_left)
 -->
 <div expr="(case A (or A B),or A B)" class="pedagogic slide" exercise="logic_connector_tuto_10">
  <p>
   <!--<span class="light-bulb">ń</span>--> Lorsque A est vraie, on démontre "A ∨ B" en choisissant A. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_10_(or A B)">
 <!--   (or A B)
  by Backward (case_base_binary)
 -->
 <div expr="(or A B)" class="pedagogic slide" exercise="logic_connector_tuto_10">
  <p>
   <!--<span class="light-bulb">ń</span>--> La règle du <span class="buttontheo">tiers exclu</span> permet de considérer deux cas pour démontrer
   <!--{type="tag" input="s1"}--> : lorsque A est vraie et lorsque ¬ A est vraie. </p>
 </div>
</div>
<div key="slide_logic_connector_tuto_10_(~ A -> B,modus_ponens,0)">
 <!--   (~ A -> B,modus_ponens,0)
  by Forward modus_ponens)
 -->
 <div expr="(~ A -> B,modus_ponens,0)" class="pedagogic slide" exercise="logic_connector_tuto_10">
  <p>
   <!--<span class="light-bulb">ń</span>--> L'implication
   <!--{type="tag" input="s0"}--> est disponible pour justifier B en tant que <span class="buttontheo">théorème local</span>. On constate que cette justification agit ici comme le modus ponens. La seule différence est que la notion de théorème local étend le modus ponens à des expressions contenant le quantificateur "quel que soit ..." (voir section suivante). </p>
 </div>
</div>
<div key="slide_logic_quantifier_tuto_01_((forall y : O1U, app_prop O1U A y -> exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x)))">
 <!-- 	((forall y : O1U, app_prop O1U A y -> exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x)))
	by Section
 -->
 <div expr="((forall y : O1U, app_prop O1U A y -> exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x)))" class="pedagogic slide" exercise="logic_quantifier_tuto_01">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_01_((forall y : O1U, app_prop O1U A y -> exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x)),app_prop O1U A b -> exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x))">
 <!-- 	((forall y : O1U, app_prop O1U A y -> exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x)),app_prop O1U A b -> exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x))
	by Section
 -->
 <div expr="((forall y : O1U, app_prop O1U A y -> exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x)),app_prop O1U A b -> exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x))" class="pedagogic slide" exercise="logic_quantifier_tuto_01">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_01_(app_prop O1U A b -> exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x),(forall y : O1U, app_prop O1U A y -> exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x)),(exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x)))">
 <!-- 	(app_prop O1U A b -> exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x),(forall y : O1U, app_prop O1U A y -> exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x)),(exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x)))
	by Backward (ex_intro)
 -->
 <div expr="(app_prop O1U A b -> exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x),(forall y : O1U, app_prop O1U A y -> exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x)),(exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x)))" class="pedagogic slide" exercise="logic_quantifier_tuto_01">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_01_(app_prop O1U A b -> exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x),(forall y : O1U, app_prop O1U A y -> exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x)),or (app_prop O1U A b) (app_prop O1U B b))">
 <!-- 	(app_prop O1U A b -> exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x),(forall y : O1U, app_prop O1U A y -> exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x)),or (app_prop O1U A b) (app_prop O1U B b))
	by Backward (intro_or_left)
 -->
 <div expr="(app_prop O1U A b -> exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x),(forall y : O1U, app_prop O1U A y -> exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x)),or (app_prop O1U A b) (app_prop O1U B b))" class="pedagogic slide" exercise="logic_quantifier_tuto_01">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_02_((exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x)),ex_elim,0)">
 <!-- 	((exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x)),ex_elim,0)
	by Forward ex_elim)
 -->
 <div expr="((exists x : O1U, or (app_prop O1U A x) (app_prop O1U B x)),ex_elim,0)" class="pedagogic slide" exercise="logic_quantifier_tuto_02">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_02_(case (app_prop O1U A a)  (or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z)))">
 <!-- 	(case (app_prop O1U A a)  (or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z)))
	by Section
 -->
 <div expr="(case (app_prop O1U A a)  (or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z)))" class="pedagogic slide" exercise="logic_quantifier_tuto_02">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_02_(case (app_prop O1U A a)  (or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z)),(exists y : O1U, app_prop O1U A y))">
 <!-- 	(case (app_prop O1U A a)  (or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z)),(exists y : O1U, app_prop O1U A y))
	by Backward (ex_intro)
 -->
 <div expr="(case (app_prop O1U A a)  (or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z)),(exists y : O1U, app_prop O1U A y))" class="pedagogic slide" exercise="logic_quantifier_tuto_02">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_02_(case (app_prop O1U A a)  (or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z)),or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z))">
 <!-- 	(case (app_prop O1U A a)  (or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z)),or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z))
	by Backward (intro_or_left)
 -->
 <div expr="(case (app_prop O1U A a)  (or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z)),or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z))" class="pedagogic slide" exercise="logic_quantifier_tuto_02">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_02_(case (app_prop O1U B a)  (or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z)))">
 <!-- 	(case (app_prop O1U B a)  (or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z)))
	by Section
 -->
 <div expr="(case (app_prop O1U B a)  (or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z)))" class="pedagogic slide" exercise="logic_quantifier_tuto_02">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_02_(case (app_prop O1U B a)  (or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z)),(exists z : O1U, app_prop O1U B z))">
 <!-- 	(case (app_prop O1U B a)  (or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z)),(exists z : O1U, app_prop O1U B z))
	by Backward (ex_intro)
 -->
 <div expr="(case (app_prop O1U B a)  (or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z)),(exists z : O1U, app_prop O1U B z))" class="pedagogic slide" exercise="logic_quantifier_tuto_02">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_02_(case (app_prop O1U B a)  (or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z)),or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z))">
 <!-- 	(case (app_prop O1U B a)  (or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z)),or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z))
	by Backward (intro_or_right)
 -->
 <div expr="(case (app_prop O1U B a)  (or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z)),or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z))" class="pedagogic slide" exercise="logic_quantifier_tuto_02">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_02_(or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z))">
 <!-- 	(or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z))
	by Backward (case_base)
 -->
 <div expr="(or (exists y : O1U, app_prop O1U A y) (exists z : O1U, app_prop O1U B z))" class="pedagogic slide" exercise="logic_quantifier_tuto_02">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_03_((forall x : O1U, and (app_prop O1U A x) (app_prop O1U B x)))">
 <!-- 	((forall x : O1U, and (app_prop O1U A x) (app_prop O1U B x)))
	by Section
 -->
 <div expr="((forall x : O1U, and (app_prop O1U A x) (app_prop O1U B x)))" class="pedagogic slide" exercise="logic_quantifier_tuto_03">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_03_((forall x : O1U, and (app_prop O1U A x) (app_prop O1U B x)),(forall x : O1U, app_prop O1U A x),apply_forall,0)">
 <!-- 	((forall x : O1U, and (app_prop O1U A x) (app_prop O1U B x)),(forall x : O1U, app_prop O1U A x),apply_forall,0)
	by Forward apply_forall)
 -->
 <div expr="((forall x : O1U, and (app_prop O1U A x) (app_prop O1U B x)),(forall x : O1U, app_prop O1U A x),apply_forall,0)" class="pedagogic slide" exercise="logic_quantifier_tuto_03">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_03_((forall x : O1U, and (app_prop O1U A x) (app_prop O1U B x)),(forall x : O1U, app_prop O1U B x),apply_forall,0)">
 <!-- 	((forall x : O1U, and (app_prop O1U A x) (app_prop O1U B x)),(forall x : O1U, app_prop O1U B x),apply_forall,0)
	by Forward apply_forall)
 -->
 <div expr="((forall x : O1U, and (app_prop O1U A x) (app_prop O1U B x)),(forall x : O1U, app_prop O1U B x),apply_forall,0)" class="pedagogic slide" exercise="logic_quantifier_tuto_03">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_03_((forall x : O1U, and (app_prop O1U A x) (app_prop O1U B x)),and (app_prop O1U A a) (app_prop O1U B a))">
 <!-- 	((forall x : O1U, and (app_prop O1U A x) (app_prop O1U B x)),and (app_prop O1U A a) (app_prop O1U B a))
	by Backward (conj)
 -->
 <div expr="((forall x : O1U, and (app_prop O1U A x) (app_prop O1U B x)),and (app_prop O1U A a) (app_prop O1U B a))" class="pedagogic slide" exercise="logic_quantifier_tuto_03">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_03_(and (forall x : O1U, app_prop O1U A x) (forall x : O1U, app_prop O1U B x),elim_conj_left,0)">
 <!-- 	(and (forall x : O1U, app_prop O1U A x) (forall x : O1U, app_prop O1U B x),elim_conj_left,0)
	by Forward elim_conj_left)
 -->
 <div expr="(and (forall x : O1U, app_prop O1U A x) (forall x : O1U, app_prop O1U B x),elim_conj_left,0)" class="pedagogic slide" exercise="logic_quantifier_tuto_03">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_03_(and (forall x : O1U, app_prop O1U A x) (forall x : O1U, app_prop O1U B x),elim_conj_right,0)">
 <!-- 	(and (forall x : O1U, app_prop O1U A x) (forall x : O1U, app_prop O1U B x),elim_conj_right,0)
	by Forward elim_conj_right)
 -->
 <div expr="(and (forall x : O1U, app_prop O1U A x) (forall x : O1U, app_prop O1U B x),elim_conj_right,0)" class="pedagogic slide" exercise="logic_quantifier_tuto_03">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_04_((forall x : O1U, and (app_prop O1U A x) (app_prop O1U B x)),apply_forall,0)">
 <!-- 	((forall x : O1U, and (app_prop O1U A x) (app_prop O1U B x)),apply_forall,0)
	by Forward apply_forall)
 -->
 <div expr="((forall x : O1U, and (app_prop O1U A x) (app_prop O1U B x)),apply_forall,0)" class="pedagogic slide" exercise="logic_quantifier_tuto_04">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_04_((forall x : O1U, app_prop O1U A x))">
 <!-- 	((forall x : O1U, app_prop O1U A x))
	by Section
 -->
 <div expr="((forall x : O1U, app_prop O1U A x))" class="pedagogic slide" exercise="logic_quantifier_tuto_04">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_04_((forall x : O1U, app_prop O1U A x),and (app_prop O1U A a) (app_prop O1U B a),elim_conj_left,0)">
 <!-- 	((forall x : O1U, app_prop O1U A x),and (app_prop O1U A a) (app_prop O1U B a),elim_conj_left,0)
	by Forward elim_conj_left)
 -->
 <div expr="((forall x : O1U, app_prop O1U A x),and (app_prop O1U A a) (app_prop O1U B a),elim_conj_left,0)" class="pedagogic slide" exercise="logic_quantifier_tuto_04">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_04_((forall x : O1U, app_prop O1U B x))">
 <!-- 	((forall x : O1U, app_prop O1U B x))
	by Section
 -->
 <div expr="((forall x : O1U, app_prop O1U B x))" class="pedagogic slide" exercise="logic_quantifier_tuto_04">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_04_((forall x : O1U, app_prop O1U B x),and (app_prop O1U A a) (app_prop O1U B a),elim_conj_right,0)">
 <!-- 	((forall x : O1U, app_prop O1U B x),and (app_prop O1U A a) (app_prop O1U B a),elim_conj_right,0)
	by Forward elim_conj_right)
 -->
 <div expr="((forall x : O1U, app_prop O1U B x),and (app_prop O1U A a) (app_prop O1U B a),elim_conj_right,0)" class="pedagogic slide" exercise="logic_quantifier_tuto_04">
 </div>
</div>
<div key="slide_logic_quantifier_tuto_04_(and (forall x : O1U, app_prop O1U A x) (forall x : O1U, app_prop O1U B x))">
 <!-- 	(and (forall x : O1U, app_prop O1U A x) (forall x : O1U, app_prop O1U B x))
	by Backward (conj)
 -->
 <div expr="(and (forall x : O1U, app_prop O1U A x) (forall x : O1U, app_prop O1U B x))" class="pedagogic slide" exercise="logic_quantifier_tuto_04">
 </div>
</div>
<div key="slide_rew_tuto_develop_(((x ^ 2 + 3 * x) + 2) + 3 * x = x ^ 2,lrsub,0)">
 <!--   (((x ^ 2 + 3 * x) + 2) + 3 * x = x ^ 2,lrsub,0)
  by Forward lrsub)
 -->
 <div expr="(((x ^ 2 + 3 * x) + 2) + 3 * x = x ^ 2,lrsub,0)" class="pedagogic slide" exercise="rew_tuto_develop">
  <p>On constate que le terme
   <!--{type="expr" input="pow x 2"}--> est présent à gauche et à droite de l'égalité.</p>
  <p>On peut donc
   <!--{type="stress" input="l'éliminer"}--> par soustraction à gauche et à droite.</p>
 </div>
</div>
<div key="slide_rew_tuto_develop_((x + 1) * (x + 2) + 3 * x = x ^ 2,expand,0)">
 <!--   ((x + 1) * (x + 2) + 3 * x = x ^ 2,expand,0)
  by Forward select of select ((x + 1) * (x + 2)) + 3 * x = x ^ 2 (expand)
 -->
 <div expr="((x + 1) * (x + 2) + 3 * x = x ^ 2,expand,0)" class="pedagogic slide" exercise="rew_tuto_develop">
  <p>L'objectif est d'isoler x à gauche.</p>
  <p>On développe les produits de facteurs pour obtenir un polynôme.</p>
 </div>
</div>
<div key="slide_rew_tuto_develop_(6 * x + 2 = zero,lrsub,0)">
 <!--   (6 * x + 2 = zero,lrsub,0)
  by Forward lrsub)
 -->
 <div expr="(6 * x + 2 = zero,lrsub,0)" class="pedagogic slide" exercise="rew_tuto_develop">
  <p>On retrouve une situation connue d'isolement à gauche de la varaible à partir d'un polynôme de degré 1.</p>
  <p>Les opérations à gauche et à droite permettent de conclure.</p>
 </div>
</div>
<div key="slide_rew_tuto_develop_(6 * x = - (2),lrdiv,0)">
 <!--   (6 * x = - (2),lrdiv,0)
  by Forward lrdiv)
 -->
 <div expr="(6 * x = - (2),lrdiv,0)" class="pedagogic slide" exercise="rew_tuto_develop">
  <p>On conclut par division par 6 à gauche et à droite.</p>
 </div>
</div>
<div key="slide_rew_tuto_fact1_(x * (x * (1 + 1 / x ^ 2)) = zero,linearsimpl,0)">
 <!--   (x * (x * (1 + 1 / x ^ 2)) = zero,linearsimpl,0)
  by Forward select of select (x * x) * (1 + 1 / x ^ 2) = zero (linearsimpl)
 -->
 <div expr="(x * (x * (1 + 1 / x ^ 2)) = zero,linearsimpl,0)" class="pedagogic slide" exercise="rew_tuto_fact1">
 </div>
</div>
<div key="slide_rew_tuto_fact1_(x * (x + 1 / x) = zero,gen_factorize,0)">
 <!--   (x * (x + 1 / x) = zero,gen_factorize,0)
  by Forward select of x * select (x + 1 / x) = zero (gen_factorize)
 -->
 <div expr="(x * (x + 1 / x) = zero,gen_factorize,0)" class="pedagogic slide" exercise="rew_tuto_fact1">
 </div>
</div>
<div key="slide_rew_tuto_fact1_(x ^ 2 + 1 = zero,gen_factorize,0)">
 <!--   (x ^ 2 + 1 = zero,gen_factorize,0)
  by Forward select of select (x ^ 2 + 1) = zero (gen_factorize)
 -->
 <div expr="(x ^ 2 + 1 = zero,gen_factorize,0)" class="pedagogic slide" exercise="rew_tuto_fact1">
  <p>L'objectif est de factoriser par
   <!--{type="expr" input="pow x 2"}-->.</p>
 </div>
</div>
<div key="slide_rew_tuto_fact1_(x ^ 2 <> zero)">
 <!--   (x ^ 2 <> zero)
  by Backward (elim_pow_ineq_zero)
 -->
 <div expr="(x ^ 2 <> zero)" class="pedagogic slide" exercise="rew_tuto_fact1">
  <p>slide 2</p>
 </div>
</div>
<div key="slide_rew_tuto_fact2_((x + 1) * ((x - 3) + x) = 2,linearsimpl,0)">
 <!-- 	((x + 1) * ((x - 3) + x) = 2,linearsimpl,0)
	by Forward select of (x + 1) * select ((x - 3) + x) = 2 (linearsimpl)
 -->
 <div expr="((x + 1) * ((x - 3) + x) = 2,linearsimpl,0)" class="pedagogic slide" exercise="rew_tuto_fact2">
 </div>
</div>
<div key="slide_rew_tuto_fact2_((x + 1) * (2 * (x - 3 / 2)) = 2,lrdiv,0)">
 <!-- 	((x + 1) * (2 * (x - 3 / 2)) = 2,lrdiv,0)
	by Forward lrdiv)
 -->
 <div expr="((x + 1) * (2 * (x - 3 / 2)) = 2,lrdiv,0)" class="pedagogic slide" exercise="rew_tuto_fact2">
 </div>
</div>
<div key="slide_rew_tuto_fact2_((x + 1) * (2 * x - 3) = 2,gen_factorize,0)">
 <!-- 	((x + 1) * (2 * x - 3) = 2,gen_factorize,0)
	by Forward select of (x + 1) * select (2 * x - 3) = 2 (gen_factorize)
 -->
 <div expr="((x + 1) * (2 * x - 3) = 2,gen_factorize,0)" class="pedagogic slide" exercise="rew_tuto_fact2">
 </div>
</div>
<div key="slide_rew_tuto_fact2_((x + 1) * (x - 3) + x * (x + 1) = 2,factorize,0)">
 <!-- 	((x + 1) * (x - 3) + x * (x + 1) = 2,factorize,0)
	by Forward select of select ((x + 1) * (x - 3) + x * (x + 1)) = 2 (factorize)
 -->
 <div expr="((x + 1) * (x - 3) + x * (x + 1) = 2,factorize,0)" class="pedagogic slide" exercise="rew_tuto_fact2">
 </div>
</div>
<div key="slide_rew_tuto_group_(E = (x + 1) * (2 * x + (3 + (y - 1))),expand,0)">
 <!-- 	(E = (x + 1) * (2 * x + (3 + (y - 1))),expand,0)
	by Forward select of E = select (UIGroup (x + 1) * (UIGroup (2 * x + 3) + UIGroup (y - 1))) (expand)
 -->
 <div expr="(E = (x + 1) * (2 * x + (3 + (y - 1))),expand,0)" class="pedagogic slide" exercise="rew_tuto_group">
  <p>L'objectif est d'effectuer le développement du membre de droite de
   <!--{type="tag" input="s0"}--> en préservant les termes :</p>
  <ul>
   <li>
    <!--{type="expr" input="plus x 1"}--></li>
   <li>
    <!--{type="expr" input="plus (mult 2 x) 3"}--></li>
   <li>
    <!--{type="expr" input="minus y 1"}--></li>
  </ul>
  <p>La solution consiste à spécifier trois groupements. On crée un groupement en sélectionnant un terme puis en <span class="stress">appuyant sur la touche <span style="font-family:'Courier New';font-weight:bold;padding-left:8px;padding-right:8px">g</span></span>.</p>
  <p>Une fois les trois groupes créés, effectuer le développement de manière usuelle.</p>
 </div>
</div>
<div key="slide_rew_tuto_idrem1_((x ^ 2 + 2 * x) + 1 = 4,polysquare,0)">
 <!--   ((x ^ 2 + 2 * x) + 1 = 4,polysquare,0)
  by Forward select of select ((x ^ 2 + 2 * x) + 1) = 4 (polysquare)
 -->
 <div expr="((x ^ 2 + 2 * x) + 1 = 4,polysquare,0)" class="pedagogic slide" exercise="rew_tuto_idrem1">
  <p>On conclut en factorisant le mebre de gauche par application de l'identité remarquable du carré polynomiale.</p>
 </div>
</div>
<div key="slide_rew_tuto_idrem1_(x ^ 2 + (2 * x - 3) = zero,lradd,0)">
 <!--   (x ^ 2 + (2 * x - 3) = zero,lradd,0)
  by Forward lradd)
 -->
 <div expr="(x ^ 2 + (2 * x - 3) = zero,lradd,0)" class="pedagogic slide" exercise="rew_tuto_idrem1">
  <p>L'objectif est de factoriser à gauche.</p>
  <p>On constate que le membre de gauche commence comme le développement de
   <!--{type="expr" input="pow (x+1) 2"}-->, d'après l'identité remarquable.</p>
  <p>On fait donc apparaître le développement du carré parfait
   <!--{type="expr" input="((pow x 2)+(2*x))+1"}-->, en ajouant 4 à droite et à gauche.</p>
 </div>
</div>
<div key="slide_rew_tuto_idrem2_((x - 3) * (x + 3) + (x + 3) = zero,factorize,0)">
 <!-- 	((x - 3) * (x + 3) + (x + 3) = zero,factorize,0)
	by Forward select of select (((x - 3) * (x + 3) + x) + 3) = zero (factorize)
 -->
 <div expr="((x - 3) * (x + 3) + (x + 3) = zero,factorize,0)" class="pedagogic slide" exercise="rew_tuto_idrem2">
 </div>
</div>
<div key="slide_rew_tuto_idrem2_((x - 3) * (x + 3) = - (x + 3),lradd,0)">
 <!-- 	((x - 3) * (x + 3) = - (x + 3),lradd,0)
	by Forward lradd)
 -->
 <div expr="((x - 3) * (x + 3) = - (x + 3),lradd,0)" class="pedagogic slide" exercise="rew_tuto_idrem2">
 </div>
</div>
<div key="slide_rew_tuto_idrem2_(x ^ 2 - 3 = - x + 3,lrsub,0)">
 <!-- 	(x ^ 2 - 3 = - x + 3,lrsub,0)
	by Forward lrsub)
 -->
 <div expr="(x ^ 2 - 3 = - x + 3,lrsub,0)" class="pedagogic slide" exercise="rew_tuto_idrem2">
 </div>
</div>
<div key="slide_rew_tuto_idrem2_(x ^ 2 - 9 = - (x + 3),square_diff,0)">
 <!-- 	(x ^ 2 - 9 = - (x + 3),square_diff,0)
	by Forward select of select (x ^ 2 - 9) = - (x + 3) (square_diff)
 -->
 <div expr="(x ^ 2 - 9 = - (x + 3),square_diff,0)" class="pedagogic slide" exercise="rew_tuto_idrem2">
 </div>
</div>
<div key="slide_rew_tuto_misc1_((x + 3) * ((x + 2) * (x + 1)) = zero,commutativity,0)">
 <!--   ((x + 3) * ((x + 2) * (x + 1)) = zero,commutativity,0)
  by Forward select of select (((x + 3) * (x + 2)) * (x + 1)) = zero (commutativity)
 -->
 <div expr="((x + 3) * ((x + 2) * (x + 1)) = zero,commutativity,0)" class="pedagogic slide" exercise="rew_tuto_misc1">
  <p>On sélectionne le terme dont on souhaite changer l'ordre.</p>
  <p>On réordonne les termes directement dans la fenêtre de diagnostic par glisser-lâcher des termes du produit.</p>
 </div>
</div>
<div key="slide_rew_tuto_misc2_(x = 2 * (x + 1),rewriting,0)">
 <!--   (x = 2 * (x + 1),rewriting,0)
  by Forward select of x = 2 * select (x + 1) (rewriting)
 -->
 <div expr="(x = 2 * (x + 1),rewriting,0)" class="pedagogic slide" exercise="rew_tuto_misc2">
  <p>L'objectif est d'isoler x à gauche. On constate dans l'hypothèse
   <!--{type="tag" input="s2"}--> qu'un des facteurs à droite,
   <!--{type="expr" input="x+1"}-->, est égal à 4 d'après l'hypothèse
   <!--{type="tag" input="s1"}-->.</p>
  <p>Il suffit donc de remplacer
   <!--{type="expr" input="x+1"}--> par 4 en utilisant
   <!--{type="tag" input="s1"}--> comme justification.</p>
  <p>On commence par sélectionner <span class="stress">à la souris</span> le terme
   <!--{type="expr" input="x+1"}--> dans
   <!--{type="tag" input="s2"}-->.</p>
 </div>
</div>
<div key="slide_rew_tuto_op_((x + 1) / ((y + 2) - 2) = zero,rewriting,0)">
 <!--   ((x + 1) / ((y + 2) - 2) = zero,rewriting,0)
  by Forward select of (x + 1) / (select (y + 2) - 2) = zero (rewriting)
 -->
 <div expr="((x + 1) / ((y + 2) - 2) = zero,rewriting,0)" class="pedagogic slide" exercise="rew_tuto_op">
  <p>On conclut par addition de 2 à gauche et à droite.</p>
 </div>
</div>
<div key="slide_rew_tuto_op_((x + 1) / y = zero,addsub,0)">
 <!--   ((x + 1) / y = zero,addsub,0)
  by Forward select of (x + 1) / select y = zero (addsub)
 -->
 <div expr="((x + 1) / y = zero,addsub,0)" class="pedagogic slide" exercise="rew_tuto_op">
  <p>L'objectif est d'obtenir la propostion
   <!--{type="tag" input="s1"}--> en transformant y au dénominateur dans
   <!--{type="tag" input="s2"}--> en
   <!--{type="expr" input="x-2"}-->.</p>
  <p>On réécrit
   <!--{type="expr" input="y"}--> en
   <!--{type="expr" input="y-2+2"}-->, terme dans lequel on remplace
   <!--{type="expr" input="y-2"}--> par
   <!--{type="expr" input="x"}--> d'après
   <!--{type="tag" input="s0"}-->.</p>
 </div>
</div>
<div key="slide_rew_tuto_simpl2_(((x + 1) + 2 * (x - 2)) / ((x + 1) * (x - 2)) = zero,lrmul,0)">
 <!-- 	(((x + 1) + 2 * (x - 2)) / ((x + 1) * (x - 2)) = zero,lrmul,0)
	by Forward lrmul)
 -->
 <div expr="(((x + 1) + 2 * (x - 2)) / ((x + 1) * (x - 2)) = zero,lrmul,0)" class="pedagogic slide" exercise="rew_tuto_simpl2">
 </div>
</div>
<div key="slide_rew_tuto_simpl2_((x + 2 * (x - 2)) + 1 = zero,linearsimpl,0)">
 <!-- 	((x + 2 * (x - 2)) + 1 = zero,linearsimpl,0)
	by Forward select of select ((x + 2 * (x - 2)) + 1) = zero (linearsimpl)
 -->
 <div expr="((x + 2 * (x - 2)) + 1 = zero,linearsimpl,0)" class="pedagogic slide" exercise="rew_tuto_simpl2">
 </div>
</div>
<div key="slide_rew_tuto_simpl2_(2 / (x + 1) + 1 / (x - 2) = zero,reducedenom,0)">
 <!--   (2 / (x + 1) + 1 / (x - 2) = zero,reducedenom,0)
  by Forward select of select (2 / (x + 1) + 1 / (x - 2)) = zero (reducedenom)
 -->
 <div expr="(2 / (x + 1) + 1 / (x - 2) = zero,reducedenom,0)" class="pedagogic slide" exercise="rew_tuto_simpl2">
  <p>L'objectif est d'isoler x à gauche.</p>
  <p>On commence par réduire les factions polynomiales au même dénominateur,
   <!--{type="expr" input="(x+1)*(x-2)"}-->.</p>
 </div>
</div>
<div key="slide_rew_tuto_simpl2_(3 * x - 3 = zero,lradd,0)">
 <!--   (3 * x - 3 = zero,lradd,0)
  by Forward lradd)
 -->
 <div expr="(3 * x - 3 = zero,lradd,0)" class="pedagogic slide" exercise="rew_tuto_simpl2">
  <p>La situation est de plus en plus simple. Des opérations à gauche et à droite permettent d'isoler x.</p>
 </div>
</div>
<div key="slide_rew_tuto_simpl2_(3 * x = 3,lrdiv,0)">
 <!--   (3 * x = 3,lrdiv,0)
  by Forward lrdiv)
 -->
 <div expr="(3 * x = 3,lrdiv,0)" class="pedagogic slide" exercise="rew_tuto_simpl2">
  <p>On conclut en divisant par 3 à gauche et à droite.</p>
 </div>
</div>
<div key="slide_rew_tuto_simpl_(3 * x + 4 = 10,lrsub,0)">
 <!--   (3 * x + 4 = 10,lrsub,0)
  by Forward lrsub)
 -->
 <div expr="(3 * x + 4 = 10,lrsub,0)" class="pedagogic slide" exercise="rew_tuto_simpl">
  <p>L'objectif d'isolement de x s'effectue à l'aide des opérations à gauche et à droite vues dans le chapitre précédent.</p>
  <p>On soustrait 4 à gauche et à droite pour isoler
   <!--{type="expr" input="3*x"}-->.</p>
 </div>
</div>
<div key="slide_rew_tuto_simpl_(3 * x = 6,lrdiv,0)">
 <!--   (3 * x = 6,lrdiv,0)
  by Forward lrdiv)
 -->
 <div expr="(3 * x = 6,lrdiv,0)" class="pedagogic slide" exercise="rew_tuto_simpl">
  <p>On conclut par division par 3 à gauche et à droite.</p>
 </div>
</div>
<div key="slide_rew_tuto_simpl_(x + (1 + (2 * x + 3)) = 10,linearsimpl,0)">
 <!--   (x + (1 + (2 * x + 3)) = 10,linearsimpl,0)
  by Forward select of select (((x + 1) + 2 * x) + 3) = 10 (linearsimpl)
 -->
 <div expr="(x + (1 + (2 * x + 3)) = 10,linearsimpl,0)" class="pedagogic slide" exercise="rew_tuto_simpl">
  <p>L'objectif est d'isoler x à gauche. On constate que le membre de gauche de l'hypothèse
   <!--{type="tag" input="s0"}--> est une somme de polynômes d'ordre 1 en x,
   <!--{type="expr" input="x+1"}--> et
   <!--{type="expr" input="2*x+1"}-->.</p>
  <p>La simplification permet de réécrire ce membre en un polynôme.</p>
 </div>
</div>
<div key="slide_rew_tuto_varchange_((a - 3) ^ 2 = zero,rewriting,0)">
 <!--   ((a - 3) ^ 2 = zero,rewriting,0)
  by Forward select of (select a - 3) ^ 2 = zero (rewriting)
 -->
 <div expr="((a - 3) ^ 2 = zero,rewriting,0)" class="pedagogic slide" exercise="rew_tuto_varchange">
  <p>On conclut en remplaçant a par
   <!--{type="expr" input="pow x 2"}-->.</p>
 </div>
</div>
<div key="slide_rew_tuto_varchange_((a ^ 2 - 6 * a) + 9 = zero,polysquare,0)">
 <!--   ((a ^ 2 - 6 * a) + 9 = zero,polysquare,0)
  by Forward select of select ((a ^ 2 - 6 * a) + 9) = zero (polysquare)
 -->
 <div expr="((a ^ 2 - 6 * a) + 9 = zero,polysquare,0)" class="pedagogic slide" exercise="rew_tuto_varchange">
  <p>On reconnaît à gauche le carré de
   <!--{type="expr" input="a-3"}-->.</p>
 </div>
</div>
<div key="slide_rew_tuto_varchange_((x ^ 4 - 6 * a) + 9 = zero,rewriting,1)">
 <!--   ((x ^ 4 - 6 * a) + 9 = zero,rewriting,1)
  by Forward select of (select (x ^ 4) - 6 * a) + 9 = zero (rewriting)
 -->
 <div expr="((x ^ 4 - 6 * a) + 9 = zero,rewriting,1)" class="pedagogic slide" exercise="rew_tuto_varchange">
  <p>On remplace
   <!--{type="expr" input="pow x 4"}--> par
   <!--{type="expr" input="pow a 2"}--> dans
   <!--{type="expr" input="s3"}-->.</p>
 </div>
</div>
<div key="slide_rew_tuto_varchange_((x ^ 4 - 6 * x ^ 2) + 9 = zero,varchange,0)">
 <!--   ((x ^ 4 - 6 * x ^ 2) + 9 = zero,varchange,0)
  by Forward select of (x ^ 4 - 6 * select (x ^ 2)) + 9 = zero (varchange)
 -->
 <div expr="((x ^ 4 - 6 * x ^ 2) + 9 = zero,varchange,0)" class="pedagogic slide" exercise="rew_tuto_varchange">
  <p>L'objectif est de factoriser le membre de gauche de l'hypothèse
   <!--{type="tag" input="s0"}-->.</p>
  <p>Appramment il s'agit d'un polynôme de dégré 4, mais en y regardant de plus près, il s'agit d'un polynôme de degré 2 en
   <!--{type="expr" input="pow x 2"}-->.</p>
  <p>On effectue le changement de variable correspondant.</p>
 </div>
</div>
<div key="slide_rew_tuto_varchange_(a = x ^ 2)">
 <!--   (a = x ^ 2)
  by Backward (replacement)
 -->
 <div expr="(a = x ^ 2)" class="pedagogic slide" exercise="rew_tuto_varchange">
  <p>slide 5</p>
 </div>
</div>
<div key="slide_rew_tuto_varchange_(a = x ^ 2,app_square,0)">
 <!--   (a = x ^ 2,app_square,0)
  by Forward app_square)
 -->
 <div expr="(a = x ^ 2,app_square,0)" class="pedagogic slide" exercise="rew_tuto_varchange">
  <p>On passe la défnition de a au carré pour obtenir
   <!--{type="expr" input="pow x 4"}--> en fonction de a.</p>
 </div>
</div>
<div key="slide_rew_tuto_varchange_(a ^ 2 = x ^ 4,linearsimpl,0)">
 <!-- 	(a ^ 2 = x ^ 4,linearsimpl,0)
	by Forward select of a ^ 2 = select ((x ^ 2) ^ 2) (linearsimpl)
 -->
 <div expr="(a ^ 2 = x ^ 4,linearsimpl,0)" class="pedagogic slide" exercise="rew_tuto_varchange">
 </div>
</div>
<div key="text_Antonym1" class="toolbox-text custom pedagogic confuse">
 <p>Si un enfant est le plus jeune, alors il n'est pas le plus âgé. </p>
</div>
<div key="text_Antonym2" class="toolbox-text custom pedagogic confuse">
 <p>Si un enfant est le plus vieux, alors il n'est pas le plus jeune. </p>
</div>
<div key="text_Superlative1" class="toolbox-text custom pedagogic confuse">
 <p>Si un enfant est le plus jeune, alors n'importe quel autre enfant n'est pas le plus jeune. </p>
</div>
<div key="text_Superlative2" class="toolbox-text custom pedagogic confuse">
 <p>Si un enfant est le plus âgé, alors n'importe quel autre enfant n'est pas le plus âgé. </p>
</div>
<div key="text_adabsurdium" class="toolbox-text custom pedagogic">
 <p> Le <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Raisonnement_par_l%27absurde" target="_blank">raisonnement par l'absurde</a></span> consiste à démontrer une proposition A en montrant que si sa négation, ¬ A, est vraie, alors on obtient une contradiction : </p>
 <p> En effet,
  <!--{type="prop" sci="true" input="~(~A)"}--> se réécrit
  <!--{type="prop" sci="true" input="(~A -> False)"}--> par définition de la négation. Le raisonnement par l'absurde est donc une règle d'élimination de la double négation. </p>
</div>
<div key="text_addsub">
 <!--TODO-->
</div>
<div key="text_app_def" class="toolbox-text custom pedagogic appdef">
 <p>On peut appliquer une fonction à une valeur qui appartient au domaine de définition de la fonction, comme dans l'exemple ci-dessous : </p>
</div>
<div key="text_app_sqrt" class="toolbox-text custom pedagogic lrapply">
 <p>Passage à la racine carrée à gauche et à droite, si les valeurs sont positives.</p>
</div>
<div key="text_app_sqrt_bounded">
 <!--TODO-->
</div>
<div key="text_app_square" class="toolbox-text custom pedagogic lrapply">
 <p>Passage au carré à gauche et à droite.</p>
</div>
<div key="text_app_square_bounded">
 <!--TODO-->
</div>
<div key="text_appdef" class="toolbox-text custom pedagogic appdef">
 <p>Une fonction est définie par la formule "Soit f la fonction définie sur ... par f(x) = ...", comme dans l'exemple ci-dessous : </p>
</div>
<div key="text_apply_forall">
 <!--TODO-->
</div>
<div key="text_apply_fun_lr">
 <!--TODO-->
</div>
<div key="text_apply_ineq_inverse">
 <!--TODO-->
</div>
<div key="text_apply_ineq_sqrt">
 <!--TODO-->
</div>
<div key="text_apply_ineq_square">
 <!--TODO-->
</div>
<div key="text_arith_def">
 <!--TODO-->
</div>
<div key="text_arith_pro">
 <!--TODO-->
</div>
<div key="text_arith_series">
 <!--TODO-->
</div>
<div key="text_ax_bad">
 <!--TODO-->
</div>
<div key="text_ax_good">
 <!--TODO-->
</div>
<div key="text_back_elim_equiv" class="toolbox-text custom pedagogic">
 <p>Plusieurs versions de la définition de l'équivalence sont disponibles en déduction et justification :</p>
 <p> </p>
</div>
<div key="text_binrel" class="toolbox-text custom pedagogic">
 <p> Une relation homogène met en relation les élements d'un même ensemble. </p>
</div>
<div key="text_bound_conj" class="toolbox-text custom pedagogic">
 <p>Un encadrement est équivalent à deux inaglités.</p>
</div>
<div key="text_bound_to_eq">
 <!--TODO-->
</div>
<div key="text_bounded_elim">
 <!--TODO-->
</div>
<div key="text_case_base" class="toolbox-text custom pedagogic">
 <p> Si "A ∨ B" est vraie, on sait simplement que l'une des deux propositions est vraie, sans savoir laquelle. On ne peut donc rien déduire directement. En revanche, lorsqu'on veut prouver une proposition C sachant que "A ∨ B" est vraie, il suffit de prouver C dans le cas où A est vraie, et de prouver C dans le cas où B est vraie. On sait alors que C est vraie dans tous les cas, sans savoir laquelle des deux propositions, A ou B, est vraie. . </p>
</div>
<div key="text_case_base_binary" class="toolbox-text custom pedagogic">
 <p>La règle du tiers exclu exprime le fait que, quelle que soit la proposition A, soit A est vraie, soit A est fausse, excluant toute autre valeur de A que vraie et fausse. </p>
</div>
<div key="text_case_good_or_bad">
 <!--TODO-->
</div>
<div key="text_comb_comp_lt" class="toolbox-text custom pedagogic">
 <p>La composition conserve l'inclusion.</p>
</div>
<div key="text_combadd" class="toolbox-text custom pedagogic comb">
 <p></p>
</div>
<div key="text_combinaison" class="toolbox-text custom pedagogic comb">
 <p>Deux égalités peuvent se combiner par addition ou soustraction des membres de gauche et des membres de droite.</p>
</div>
<div key="text_combine_cmp_minus" class="toolbox-text custom pedagogic">
 <p> </p>
</div>
<div key="text_combine_cmp_plus" class="toolbox-text custom pedagogic">
 <p> </p>
</div>
<div key="text_combsub" class="toolbox-text custom pedagogic comb">
 <p></p>
</div>
<div key="text_commutativity" class="toolbox-text custom pedagogic">
 <p>La multplication et l'addition sont commutatives : on peut réordonner les termes dans l'ordre souhaité.</p>
</div>
<div key="text_conj" class="toolbox-text custom pedagogic">
 <p> Prouver "A ∧ B" consiste à fournir deux preuves : une de A et une de B. </p>
</div>
<div key="text_conjunction" class="toolbox-text custom pedagogic">
 <p> La conjonction de deux propositions A B, notée "A ∧ B" et lue "A et B", est vraie si A est vraie et B est vraie. </p>
</div>
<div key="text_converge">
 <!--TODO-->
</div>
<div key="text_deduce_not_color" class="toolbox-text custom pedagogic appdef">
 <p>Puisqu'il n'y a que deux chapeaux blancs, si un porteur de chapeau voit ses deux camarades porter chacun un chapeau blanc, alors il peut déduire qu'il porte nécessairement un chapeau noir.</p>
 <p>Par contraposée, si un porteur de chapeau ne connait pas la couleur de son chapeau, c'est qu'au moins un de ses deux camarades porte un chapeau noir.</p>
</div>
<div key="text_def_fbij" class="toolbox-text custom pedagogic">
 <p> Une fonction f de A vers B est <span class="exturl"> <a href="https://fr.wikipedia.org/wiki/Bijection" target="_blank">bijective </a></span> si elle est à la fois injective et surjective : à tout élement de A correspond exactement une image par f, et à tout élément de B correspond exactement un antécédant par f. </p>
</div>
<div key="text_def_fcomp" class="toolbox-text custom pedagogic">
 <p>La composition de deux fonctions f : A → B et g : B → C, notée "f ∘ g" et lue "f rond g", est une fonction de A vers C telle que l'image d'un élément x de A est l'image par g de l'image par f de x. </p>
 <p> L'opérateur de composition construit une fonction de type (A → C) à partir de deux fonctions de type (A → B) et (B → C). On note une similarité de forme avec la démonstration d'un <span class="exturl"> <a href="https://fr.wikipedia.org/wiki/Syllogisme" target="_blank">syllogisme</a></span> qui fournit une preuve de
  <!--{type="prop" sci="true" input="A -> C"}--> en supposant
  <!--{type="prop" sci="true" input="A -> B"}--> et
  <!--{type="prop" sci="true" input="B -> C"}-->... </p>
</div>
<div key="text_def_finj" class="toolbox-text custom pedagogic">
 <p> Une fonction est <span class="exturl"> <a href="https://fr.wikipedia.org/wiki/Injection_(math%C3%A9matiques)" target="_blank">injective</a></span> si la relation correspondante est injective. Ainsi la fonction f de A vers B est injective si un élément de B est l'image d'un et d'un seul élément de A, ou autrement dit, si une image y n'a qu'un seul antécédent par f; autrement dit encore, si deux éléments x et z ont la même image par f injective, alors ces élements sont les mêmes. </p>
 <p>On remarque que pour prouver qu'une fonction f n'est pas injective, il suffit de trouver deux éléments distincts ayant la même image par f. </p>
</div>
<div key="text_def_finvol" class="toolbox-text custom pedagogic">
 <p> Si f est une fonction de E dans E, elle est <span class="exturl"> <a href="https://fr.wikipedia.org/wiki/Involution_(math%C3%A9matiques)" target="_blank">involutive</a></span> si l'image de l'image d'un élément x, est x lui-même. </p>
 <p>Exemples :</p>
 <ul>
  <li>la symétrie par un miroir</li>
  <li>en <span class="exturl"> <a href="https://fr.wikipedia.org/wiki/Logique_classique" target="_blank">logique classique</a></span>, la négation d'une proposition est involutive, ce qui permet le <span class="exturl"> <a href="https://fr.wikipedia.org/wiki/Raisonnement_par_l%27absurde" target="_blank">raisonnement par l'absurde</a></span></li>
  <li>l'algorithme de chiffrement <span class="exturl"> <a href="https://fr.wikipedia.org/wiki/ROT13" target="_blank">ROT13</a> </span></li>
 </ul>
 <p></p>
</div>
<div key="text_def_fsurj" class="toolbox-text custom pedagogic">
 <p>Une fonction f de A vers B est surjective si tous les élements de B sont l'image d'au moins un élément de A. </p>
</div>
<div key="text_def_rantisym" class="toolbox-text custom pedagogic">
 <p>Une relation homogène sur E est antisymétrique si, quels que soient les élements x y de E, si les couples (x,y) et (y,x) appartiennent au graphe de la relation, alors x est le meme élément que y.</p>
</div>
<div key="text_def_rcomp" class="toolbox-text custom pedagogic">
 <p> Si A B et C sont des ensembles, si
  <!--{type="expr" input="R1"}--> une relation sur A×B, et si
  <!--{type="expr" input="R2"}--> une relation sur B×C, alors la composition de
  <!--{type="expr" input="R1"}--> et
  <!--{type="expr" input="R2"}-->, notée
  <!--{type="expr" input="RComp U U U A B C R1 R2"}-->, est la relation définie sur A×C telle qu'un élément x de A est en relation avec un élément z de C par
  <!--{type="expr" input="RComp U U U A B C R1 R2"}-->, si x et z sont en relation avec un élément y de b, respectivement à gauche par
  <!--{type="expr" input="R1"}--> et à droite par
  <!--{type="expr" input="R2"}--> : </p>
</div>
<div key="text_def_rfun" class="toolbox-text custom pedagogic">
 <p>Une relation de A×B est fonctionnelle si un élément de A est en relation avec au plus un élement de B. </p>
</div>
<div key="text_def_rident" class="toolbox-text custom pedagogic">
 <p>Le graphe de la relation identité sur l'ensemble E, noté
  <!--{type="expr" input="RIdent U E"}-->, est l'ensemble des couples
  <!--{type="expr" input="upair U U x x"}--> où x appartient à E. </p>
</div>
<div key="text_def_rinj" class="toolbox-text custom pedagogic">
 <p>Une relation de A×B est injective si un élément de B est en relation avec au plus un élement de A. Autrement dit, un élément de B en relation par R, n'est en relation qu'avec un seul élément de A. Autrement dit encore, si deux éléments de A sont en relation avec un élément de B par une relation injective, alors ces deux élements sont les mêmes. </p>
</div>
<div key="text_def_rinv" class="toolbox-text custom pedagogic">
 <p>La relation inverse d'une relation R définie sur A×B, notée R⁻¹, est une relation définie sur B×A par : </p>
</div>
<div key="text_def_rrefl" class="toolbox-text custom pedagogic">
 <p>Une relation homogène sur E est réfléxive si tout élément de E est en relation avec lui-meme.</p>
</div>
<div key="text_def_rsurj" class="toolbox-text custom pedagogic">
 <p>Une relation de A×B est surjective, ou totale à droite, si tous les éléments de B sont en relation avec un élément de A. </p>
</div>
<div key="text_def_rsym" class="toolbox-text custom pedagogic">
 <p>Une relation homogène sur E est symétrique si, quels que soient les éléments x y de E, les couples (x,y) et (y,x) appartiennent au graphe de la relation.</p>
</div>
<div key="text_def_rtotleft" class="toolbox-text custom pedagogic">
 <p>Une relation définie sur A×B est totale à gauche si tous les élements de A sont en relation avec un élément de B. </p>
</div>
<div key="text_def_rtrans" class="toolbox-text custom pedagogic">
 <p>Une relation homogène est transitive si :</p>
</div>
<div key="text_disjonction" class="toolbox-text custom pedagogic">
 <p>La disjonction de deux propositions A B, notée "A ∨ B" et lue "A ou B", est vraie si A est vraie ou si B est vraie.</p>
</div>
<div key="text_distrib" class="toolbox-text custom pedagogic">
 <p>La multiplication est distributive sur l'addition.</p>
</div>
<div key="text_elim_comp">
 <!--TODO-->
</div>
<div key="text_elim_conj_left" class="toolbox-text custom pedagogic">
 <p> Si "A ∧ B" est vraie, alors A est vraie. </p>
</div>
<div key="text_elim_conj_right" class="toolbox-text custom pedagogic">
 <p>Si "A ∧ B" est vraie, alors B est vraie.</p>
</div>
<div key="text_elim_eqfun">
 <!--TODO-->
</div>
<div key="text_elim_eqset" class="toolbox-text custom pedagogic">
 <p>Deux ensembles A et B sont égaux si être élément de A implique être élément de B, et réciproquement ; c'est à dire que A est inclus dans B et inversement, B est inclus dans A, par définition de l'inclusion. L'égalité se note simplement "A = B". </p>
</div>
<div key="text_elim_even_def">
 <!--TODO-->
</div>
<div key="text_elim_false_exset" class="toolbox-text custom pedagogic">
 <p> Par définition, <span class="exturl"> <a href="https://fr.wikipedia.org/wiki/Ensemble_vide" target="_blank">l'ensemble vide</a></span>, noté ∅, est l'ensemble qui est inclus dans n'importe quel ensemble. </p>
</div>
<div key="text_elim_gen_app_rel" class="toolbox-text custom pedagogic">
 <p> Dans ce qui suit, <span class="stress">une relation R est assimilée à son graphe</span>, afin d'alléger les formules et les notations. </p>
</div>
<div key="text_elim_has_finite_limit_decr">
 <!--TODO-->
</div>
<div key="text_elim_has_finite_limit_incr">
 <!--TODO-->
</div>
<div key="text_elim_is_elem_universe" class="toolbox-text custom pedagogic">
 <p> Par définition, l'univers, noté U, est l'ensemble qui contient tous les éléments. L'univers est donc le plus grand ensemble au sens de l'inclusion (tout ensemble est inclus dans l'univers). </p>
</div>
<div key="text_elim_multiple">
 <!--TODO-->
</div>
<div key="text_elim_negation" class="toolbox-text custom pedagogic">
 <p> La négation d'une proposition A se définit à l'aide de la constante <span style="font-weight: bold">contradiction</span> (proposition qui représente le fait d'avoir une contradiction) de la manière suivante : </p>
</div>
<div key="text_elim_pprod">
 <!--TODO-->
</div>
<div key="text_elim_requiv" class="toolbox-text custom pedagogic">
 <p>Une <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Relation_d%27%C3%A9quivalence" target="_blank">relation d'équivalence</a></span> est une relation réflexive, symétrique et transitive. Par exemple, l'égalité et l'équivalence sont des relations d'équivalence. </p>
</div>
<div key="text_elim_scomp" class="toolbox-text custom pedagogic">
 <p> Le complément d'un ensemble A dans l'univers U, noté "
  <!--{type="expr" input="scomp U (sall U) A"}-->" et lu "complément de A dans U" ou simplement "complément de A", contient les élements qui ne sont pas dans A : </p>
 <span style="position:relative; left:-20px; display: inherit; width: 110%; text-align: center; padding-bottom: 0px; background-color: rgba(0, 172, 231, 1)"> <img src="./svg/complement.svg" style="width: auto; height:150px;position:relative;"> </span>
</div>
<div key="text_elim_sdiff" class="toolbox-text custom pedagogic">
 <p> La différence de deux ensembles A et B, noté "
  <!--{type="expr" input="sdiff U A B"}-->" et lu "A privé de B", contient les élements qui sont dans A et qui ne sont pas dans B : </p>
 <span style="display: inherit; width: 100%; text-align: center; padding-bottom: 0px; position:relative;"> <img src="./svg/diff.svg" style="width: auto; height: 150px;"> </span>
</div>
<div key="text_elim_sequiv" class="toolbox-text custom pedagogic">
 <p>La classe d'équivalence d'un élement x par une relation R sur un ensemble E, notée
  <!--{type="expr" input="sequiv U E x R"}-->, est l'ensemble des éléments en relation avec x par R.</p>
</div>
<div key="text_elim_set_lteq" class="toolbox-text custom pedagogic">
 <p>Un ensemble est inclus dans un autre si et seulement si être élément de l'un implique être élément de l'autre.</p>
 <span style="display: inherit; width: 100%; text-align: center; padding-bottom:0px"> <img src="./svg/subset.svg" style=" width: auto; height: 150px;"> </span>
</div>
<div key="text_elim_shas_lower_bound">
 <!--TODO-->
</div>
<div key="text_elim_shas_upper_bound">
 <!--TODO-->
</div>
<div key="text_elim_sinter" class="toolbox-text custom pedagogic">
 <p> L'intersection de deux ensembles A et B, noté "
  <!--{type="expr" input="sinter U A B"}-->" et lu "A inter B", contient les élements qui sont à la fois dans A et dans B : </p>
 <span style="display: inherit; width: 100%; text-align: center; padding-bottom: 0px; position:relative;"> <img src="./svg/inter.svg" style="width: auto; height:150px;"> </span>
</div>
<div key="text_elim_sis_decreasing">
 <!--TODO-->
</div>
<div key="text_elim_sis_gt_zero">
 <!--TODO-->
</div>
<div key="text_elim_sis_increasing">
 <!--TODO-->
</div>
<div key="text_elim_sis_lt_zero">
 <!--TODO-->
</div>
<div key="text_elim_subset" class="toolbox-text custom pedagogic">
 <p> Une partie d'un ensemble A est un sous-ensemble de A. <span class="exturl"> <a href="https://fr.wikipedia.org/wiki/Ensemble_des_parties_d%27un_ensemble" target="_blank">L'ensemble des parties</a></span> d'un ensemble A, noté
  <!--{type="expr" input="ssubset U A"}-->, est l'ensemble des sous-ensembles de A. </p>
 <p> On déduit notamment que
  <!--{type="prop" sci="true" input="sis_element A (ssubset U A)"}--> puisque
  <!--{type="prop" sci="true" input="set_lteq U A A"}--> par définition de l'inclusion. </p>
</div>
<div key="text_elim_sunion" class="toolbox-text custom pedagogic">
 <p> L'union de deux ensembles A et B, noté "
  <!--{type="expr" input="sunion U A B"}-->" et lu "A union B", contient les élements qui soit dans A, soit dans B : </p>
 <span style="display: inherit; width: 100%; text-align: center; padding-bottom: 0px;position:relative;"> <img src="./svg/union.svg" style="width: auto; height: 150px;"> </span>
</div>
<div key="text_elim_true_at_rank" class="toolbox-text custom pedagogic">
 <p>La première étape de la récurrence consiste à extraire une proposition P qui dépende d'un indice n, comme dans l’exemple ci dessous : </p>
</div>
<div key="text_eq_inverse">
 <!--TODO-->
</div>
<div key="text_eq_reverse" class="toolbox-text custom pedagogic lrapply">
 <p>Passage à l'opposé à gauche et à droite.</p>
</div>
<div key="text_eq_symmetry" class="toolbox-text custom pedagogic eqrel">
 <p>Si a=b alors b=a.</p>
</div>
<div key="text_eq_trans" class="toolbox-text custom pedagogic eqrel">
 <p>Si a=b et b=c alors a=c.</p>
</div>
<div key="text_eqfun">
 <!--TODO-->
</div>
<div key="text_eqrel" class="toolbox-text custom pedagogic eqrel">
 <p>L'égalité est une relation transitive et symétrique.</p>
</div>
<div key="text_eqset" class="toolbox-text custom pedagogic">
 <p>Deux ensembles A et B sont égaux si être élément de A implique être élément de B, et réciproquement ; c'est à dire que A est inclus dans B et inversement, B est inclus dans A, par définition de l'inclusion. L'égalité se note simplement "A = B". </p>
</div>
<div key="text_equiv" class="toolbox-text custom pedagogic">
 <p>Lorsque les propositions "A ⇒ B" et "B ⇒ A" sont toutes les deux vraies, c'est à dire que "(A ⇒ B) ∧ (B ⇒ A)" est vraie, on dit alors que A est équivalente à B et on note "A ⇔ B". </p>
</div>
<div key="text_equiv_rtrans" class="toolbox-text custom pedagogic">
 <p>Caratérisation ensembliste d'une relation transitive :</p>
</div>
<div key="text_ex_elim" class="toolbox-text custom pedagogic">
 <p> Déduire d'une existence
  <!--{type="prop" sci="true" input="exists x, app_prop U F x"}--> consiste à <span class="stress">déclarer un élément</span> x qui vérifie la proposition :
  <!--{type="prop" sci="true" input="app_prop U F x"}-->. </p>
</div>
<div key="text_ex_intro" class="toolbox-text custom pedagogic">
 <p> Prouver une existence consiste à <span class="stress">trouver un élément</span> pour lequel la proposition est vraie. Un tel élément est appelé <span class="stress">témoin</span> d'une preuve de la proposition
  <!--{type="prop" sci="true" input="exists (x:O1U), app_prop O1U F x"}-->. </p>
 <!-- <p>Trouver un témoin consiste à trouver une valeur pour l'<span class="stress">inconnue de raisonnement</span> <span class="evar" style="font-size:15px">x?</span> </p> -->
</div>
<div key="text_exists" class="toolbox-text custom pedagogic">
 <p> La proposition qu'une formule à variable F est vraie pour un élément x est notée
  <!--{type="prop" sci="true" input="app_prop U F x"}--> et lue "F de x". </p>
 <p> L'existence d'un élément x telle que F (x) soit vraie, notée
  <!--{type="prop" sci="true" input="exists (x:O1U), app_prop O1U F x"}--> et lu "il existe x tel que F de x", est vraie si, pour une valeur t, on peut prouver
  <!--{type="prop" sci="true" input="app_prop U F t"}-->. L'opérateur ∃ est appelé <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Quantificateur_(logique)" target="_blank">quantificateur existentiel</a></span>. </p>
</div>
<div key="text_expand" class="toolbox-text custom pedagogic">
 <p>Développement complet d'un produit de facteurs.</p>
</div>
<div key="text_fact">
 <!--TODO-->
</div>
<div key="text_factorize" class="toolbox-text custom pedagogic">
 <p>Une factorisation 'remarquable' détecte un terme commun dans une somme de termes, et le factorise (sans condition de non nullité).</p>
</div>
<div key="text_falseall" class="toolbox-text custom pedagogic">
 <p>"Du faux découle ce que l'on veut." Cette règle permet de justifier n'importe quelle proposition avec la constante <span style="font-weight:bold">contradiction</span>.</p>
 <p>Cette règle est très utile, notamment dans les raisonnements par disjonction de cas : en effet si on obtient une contradiction dans un cas, on peut le conclure directement grâce à cette règle.</p>
 <p>On trouve ce principe logique dans des expressions populaires :</p>
 <ul>
  <li>Avec des si, on mettrait Paris en bouteille.</li>
  <li>Quand les poules auront des dents ...</li>
 </ul>
</div>
<div key="text_forall" class="toolbox-text custom pedagogic">
 <p> La proposition qu'une formule à variable F est vraie quelle que soit la valeur de cette variable, notée
  <!--{type="prop" sci="true" input="forall (x:O1U), (app_prop O1U F x)"}--> et lue "quel que soit x, F de x", est vraie si on peut prouver
  <!--{type="prop" sci="true" input="app_prop O1U F x"}--> pour un élément x quelconque. L'opérateur ∀ est appelé <span class="exturl"> <a href="https://fr.wikipedia.org/wiki/Quantificateur_(logique)" target="_blank"> quantificateur universel</a></span>. </p>
</div>
<div key="text_funop">
 <!--TODO-->
</div>
<div key="text_gen_factorize" class="toolbox-text custom pedagogic">
 <p>Factorisation par une valeur quelconque <span class="stress">différente de zéro</span>.</p>
</div>
<div key="text_geo_def">
 <!--TODO-->
</div>
<div key="text_geo_pro">
 <!--TODO-->
</div>
<div key="text_geo_series">
 <!--TODO-->
</div>
<div key="text_implication" class="toolbox-text custom pedagogic">
 <p>L'implication liant deux propositions A B, notée "A ⇒ B" et lue "A implique B" ou "si A alors B", signifie que B ne peut pas être fausse lorsque A est vraie.</p>
</div>
<div key="text_inclusionsimpl" class="toolbox-text custom pedagogic">
 <p> On simplifie l'intersection (ou l'union) de deux ensembles si l'un des deux ensembles est inclus dans l'autre. </p>
</div>
<div key="text_ind_basic_forall" class="toolbox-text custom pedagogic">
 <p>La justification par récurrence fait apparaître la proposition d’<span class="stress">initialisation</span> et la proposition d’<span class="stress">hérédité</span>. </p>
</div>
<div key="text_ind_init">
 <!--TODO-->
</div>
<div key="text_induction" class="toolbox-text custom pedagogic">
 <p>En général les propositions commençant par “Quel que soit l’entier n ...” se démontrent par récurrence. </p>
</div>
<div key="text_ineq_sym_rew" class="toolbox-text custom pedagogic">
 <p>Une comparaison peut se réécrire en changeant l'ordre des valeurs et en remplaçant la comparaison par sa réciproque. Par exemple
  <!--{type="prop" sci="true" style="vertical-align:-3px;" input="ExprLT a b"}--> se réécrit en
  <!--{type="prop" sci="true" style="vertical-align:-3px;" input="ExprGT b a"}-->. </p>
</div>
<div key="text_ineqapp" class="toolbox-text custom pedagogic appdef">
 <p>On peut appliquer une fonction à gauche et à droite d'une inégalité, sans changer le sens de l'inégalité, si les valeurs à gauche et à droite appratiennent à un intervalle sur lequel la fonction est définie et croissante.</p>
</div>
<div key="text_ineqbound" class="toolbox-text custom pedagogic">
 <p>Un encadrement d'une valeur donne deux valeurs entre lesquelles elle est comprise. Il est équivalent à deux inégalités.</p>
 <p>Les opérations à droite et à gauche vues pour les inégalités sont également disponibles pour les encadrements.</p>
</div>
<div key="text_ineqcomb" class="toolbox-text custom pedagogic">
 <p>Deux inégalités peuvent se combiner par addition ou soustraction des membres de gauche et des membres de droite.</p>
</div>
<div key="text_ineqconv">
 <!--TODO-->
</div>
<div key="text_ineqrel" class="toolbox-text custom pedagogic">
 <p>Les comparaisons sont des relations transitives. La relation réciproque permet de réécrire une inégalité en changeant l'ordre des valeurs comparées. </p>
</div>
<div key="text_intro_false" class="toolbox-text custom pedagogic">
 <p> On peut déduire une contradiction si l'on suppose une proposition et sa négation.</p>
</div>
<div key="text_intro_or_left" class="toolbox-text custom pedagogic">
 <p>Pour prouver "A ∨ B", il suffit de prouver A.</p>
</div>
<div key="text_intro_or_right" class="toolbox-text custom pedagogic">
 <p>Pour prouver "A ∨ B", il suffit de prouver B.</p>
</div>
<div key="text_intro_sqrt_square">
 <!--TODO-->
</div>
<div key="text_leftright" class="toolbox-text custom pedagogic leftright">
 <p>On conserve l'égalité par application au membre de droite et au membre de gauche de la même opération (addition, soustraction, multiplication, division).</p>
</div>
<div key="text_leftright_ineq" class="toolbox-text custom pedagogic">
 <p>Les opérations à gauche et à droite permettent de transformer une inégalité (ou un encadrement) à gauche et à droite par une opération (addition, soustraction, multiplication, division). </p>
 <p>Quatre formes de comparaison (supériorité ou infériorité, stricte ou non), et quatre formes d'encadrement sont considérées.</p>
</div>
<div key="text_leftright_neq" class="toolbox-text custom pedagogic appdef">
 <p>Comme pour l'égalité, on conserve l'inégalité par application au membre de droite et au membre de gauche de la même opération (addition, soustraction, multiplication, division).</p>
</div>
<div key="text_limfinite">
 <!--TODO-->
</div>
<div key="text_limit_finite">
 <!--TODO-->
</div>
<div key="text_limit_inf">
 <!--TODO-->
</div>
<div key="text_limit_neg_inf">
 <!--TODO-->
</div>
<div key="text_limitinf">
 <!--TODO-->
</div>
<div key="text_limitops">
 <!--TODO-->
</div>
<div key="text_linearsimpl" class="toolbox-text custom simpl" style="
    padding-left: 20px;
    padding-right: 20px;">
 <p>Les simplifications permettent de :</p>
 <ul>
  <li style="font-size:14px;">calculer un terme numérique (qui ne contient que des nombres)</li>
  <li style="font-size:14px;">effectuer des opérations polynomiales simples (addition, soustraction, ...) de polynômes
   <!-- <span class="stress">de degré 1</span> --></li>
  <li style="font-size:14px;">effectuer des simplifications linéaires (élimination des termes 'x-x')</li>
  <!--  <li style="font-size:14px;">factoriser les puissances par rapport à la multiplication</li> -->
 </ul>
 <p></p>
</div>
<div key="text_logicothers" class="toolbox-text custom pedagogic">
 <p> Au début du 20<span class="sup">ème</span> siècle, le courant mathématique <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Constructivisme_(math%C3%A9matiques)" target="_blank">constructiviste</a></span> a considéré qu'une démonstration valide de "A ∨ B" devait permettre de savoir laquelle des deux propositions est vraie, et a donc rejeté l'utilisation du tiers exclu. On parle de <span class="stress">logique constructiviste</span> (ou intuitionniste) lorsque le tiers exclu n'est pas considéré comme un <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Axiome" target="_blank">axiome</a></span> (c'est-à-dire n'est pas admis), et de <span class="stress">logique classique</span> lorsqu'il est admis. </p>
</div>
<div key="text_lradd" class="toolbox-text custom pedagogic leftright">
 <p>Addition à gauche et droite par une valeur à spécifier. Cette opération permet de faire passer un terme de part et d'autre d'une égalité en changeant son signe.</p>
</div>
<div key="text_lradd_bounded">
 <!--TODO-->
</div>
<div key="text_lradd_ineq" class="toolbox-text custom pedagogic">
 <p>Addition à gauche et droite par une valeur à spécifier. Cette opération permet de faire passer un terme de part et d'autre d'une inégalité (encadrement) en changeant son signe. </p>
</div>
<div key="text_lradd_neq">
 <!--TODO-->
</div>
<div key="text_lrapply" class="toolbox-text custom pedagogic lrapply">
 <p>On peut appliquer une fonction à gauche et à droite d'une égalité, si la valeur à gauche et à droite appartient à l'ensemble de définition de la fonction. Quatre fonctions importantes sont introduites : le carré, la racine carrée, la fonction opposée et la fonction inverse.</p>
</div>
<div key="text_lrdiv" class="toolbox-text custom pedagogic leftright">
 <p>Division à gauche et droite par une valeur à spécifier. On note que cette valeur doit être différente de zéro.</p>
</div>
<div key="text_lrdiv_bounded">
 <!--TODO-->
</div>
<div key="text_lrdiv_ineq" class="toolbox-text custom pedagogic">
 <p>Division à gauche et droite par une valeur à spécifier, différente de zéro. Si cette valeur est strictement négative, le sens de l'inégalité en les valeurs divisées change. </p>
</div>
<div key="text_lrdiv_neq">
 <!--TODO-->
</div>
<div key="text_lrmul" class="toolbox-text custom pedagogic leftright">
 <p>Multiplication à gauche et droite par une valeur à spécifier.</p>
</div>
<div key="text_lrmul_bounded">
 <!--TODO-->
</div>
<div key="text_lrmul_ineq" class="toolbox-text custom pedagogic">
 <p>Multiplication à gauche et droite par une valeur à spécifier. Si cette valeur est négative, le sens de l'inégalité entre les valeur multipliées change.</p>
</div>
<div key="text_lrmul_neq">
 <!--TODO-->
</div>
<div key="text_lrsub" class="toolbox-text custom pedagogic leftright">
 <p>Soustration à gauche et droite par une valeur à spécifier. Cette opération permet de faire passer un terme de part et d'autre d'une égalité en changeant son signe.</p>
</div>
<div key="text_lrsub_bounded">
 <!--TODO-->
</div>
<div key="text_lrsub_ineq" class="toolbox-text custom pedagogic">
 <p>Soustration à gauche et droite par une valeur à spécifier. Cette opération permet de faire passer un terme de part et d'autre d'une inégalité (encadrement) en changeant son signe.</p>
</div>
<div key="text_lrsub_neq">
 <!--TODO-->
</div>
<div key="text_lt_next_int">
 <!--TODO-->
</div>
<div key="text_modus_ponens" class="toolbox-text custom pedagogic">
 <p> Pouvoir déduire B à partir de A implique que si A est vraie, on peut déduire B. Cette règle s'appelle <span class="exturl"> <a href="https://fr.wikipedia.org/wiki/Modus_ponens" target="_blank">modus ponens</a></span>.</p>
</div>
<div key="text_muldiv">
 <!--TODO-->
</div>
<div key="text_multiple">
 <!--TODO-->
</div>
<div key="text_negation" class="toolbox-text custom pedagogic">
 <p> La négation d'une proposition A se note "¬ A" et se lit "non A". </p>
</div>
<div key="text_neq_symmetry">
 <!--TODO-->
</div>
<div key="text_non_zero_gt">
 <!--TODO-->
</div>
<div key="text_non_zero_lt">
 <!--TODO-->
</div>
<div key="text_oldest">
 <!--TODO-->
</div>
<div key="text_polysquare" class="toolbox-text custom pedagogic">
 <p>La factorisation en carré de la somme de deux termes
  <!--{type="expr" input="a"}--> et
  <!--{type="expr" input="b"}--> est fournie par la formule : </p>
 <p>
  <!--{type="prop" sci="true" input=" ((pow a 2) + (2*a*b) + (pow b 2)) = (pow (a+b) 2)"}--></p>
 <p>Par exemple :</p>
</div>
<div key="text_prod">
 <!--TODO-->
</div>
<div key="text_proddecompl">
 <!--TODO-->
</div>
<div key="text_proddef">
 <!--TODO-->
</div>
<div key="text_prodidx">
 <!--TODO-->
</div>
<div key="text_prodinverse">
 <!--TODO-->
</div>
<div key="text_prodlinear">
 <!--TODO-->
</div>
<div key="text_prodrem">
 <!--TODO-->
</div>
<div key="text_prodresult1">
 <!--TODO-->
</div>
<div key="text_prodsimpl">
 <!--TODO-->
</div>
<div key="text_produpshift">
 <!--TODO-->
</div>
<div key="text_reason_capacity" class="toolbox-text custom pedagogic appdef">
 <p>Puisque les porteurs de chapeau sont doués de raison, si on peut déduire la couleur d'un chapeau, alors un porteur de chapeau peut en faire autant, et il connait alors la couleur de son chapeau. </p>
</div>
<div key="text_red_true_at_rank">
 <!--TODO-->
</div>
<div key="text_reducedenom" class="toolbox-text custom pedagogic">
 <p>Mise au dénominateur commun d'une somme de fractions.</p>
 <p></p>
</div>
<div key="text_relops" class="toolbox-text custom pedagogic">
 <p>opérateurs</p>
</div>
<div key="text_relothers" class="toolbox-text custom pedagogic">
 <p>remarquables</p>
</div>
<div key="text_relprop" class="toolbox-text custom pedagogic">
 <p>relations</p>
</div>
<div key="text_relset">
 <!--TODO-->
</div>
<div key="text_remid" class="toolbox-text custom pedagogic">
 <p>Les identités remarquables permettent de factoriser des termes ayant des formes particulières simples que l'on rencontre très fréquemment dans les calculs. </p>
</div>
<div key="text_rewops" class="toolbox-text custom pedagogic">
 <p> Les réécritures par opérations appliquent à un terme une opération et son inverse pour obtenir un terme égal (addition et soustraction, mulitplication et division).</p>
</div>
<div key="text_rewprops">
 <!--TODO-->
</div>
<div key="text_rewriting" class="toolbox-text custom pedagogic">
 <p> Sélectionner un terme 'a' dans une équation permet de le remplacer par un terme 'b' si l'égalité 'a=b' peut être démontrée. </p>
</div>
<div key="text_sandwich">
 <!--TODO-->
</div>
<div key="text_section" class="toolbox-text custom pedagogic">
 <p>Prouver "A ⇒ B" consiste à créer une nouvelle portée logique (un nouvel exercice) dans laquelle A est une hypothèse et B est la conclusion.</p>
</div>
<div key="text_series_limitation">
 <!--TODO-->
</div>
<div key="text_series_sign">
 <!--TODO-->
</div>
<div key="text_series_variation">
 <!--TODO-->
</div>
<div key="text_set_absorb" class="toolbox-text custom pedagogic">
 <p> L'ensemble vide est l'<span class="exturl"><a href="https://fr.wikipedia.org/wiki/%C3%89l%C3%A9ment_absorbant" target="_blank">élement absorbant</a></span> de l'intersection, et l'ensemble univers est l'élément absorbant de l'union (comme 0 est l'élément absorbant de la multiplication). </p>
</div>
<div key="text_set_adabsurdum" class="toolbox-text custom pedagogic">
 <p>Le complément du complément d'un ensemble est cet ensemble. On appelle 'absurbe' cette propriété d'élimination du double complément, par analogie avec le <span class="exturl"><a href="https://fr.wikipedia.org/wiki/Raisonnement_par_l%27absurde" target="_blank">raisonnement par l'absurde</a></span> de la logique classique, qui est la règle d'élimination de la double négation. </p>
</div>
<div key="text_set_comb">
 <!--TODO-->
</div>
<div key="text_set_demorgan" class="toolbox-text custom pedagogic">
 <p> Le complément de l'intersection (resp. l'union) des deux ensembles est l'union (resp. l'intersection) des compléments de ces ensembles. </p>
</div>
<div key="text_set_eq_symmetry" class="toolbox-text custom pedagogic">
 <p>La symétrie de l'égalité ensembliste est disponible pour mener des calculs.</p>
</div>
<div key="text_set_eq_trans" class="toolbox-text custom pedagogic">
 <p>La transitivité de l'égalité ensembliste est disponible pour mener des calculs.</p>
</div>
<div key="text_set_excluded" class="toolbox-text custom pedagogic">
 <p> Tout élément de l'univers appartient soit à un ensemble, soit à son complément, à l'exclusion de tout autre possibilité. </p>
</div>
<div key="text_set_inter_comb">
 <!--TODO-->
</div>
<div key="text_set_lteq_transitivity" class="toolbox-text custom pedagogic">
 <p>L'inclusion ensembliste est une relation transitive.</p>
</div>
<div key="text_set_neutral" class="toolbox-text custom pedagogic">
 <p> L'ensemble vide est l'<span class="exturl"><a href="https://fr.wikipedia.org/wiki/%C3%89l%C3%A9ment_neutre" target="_blank">élement neutre</a></span> de l'union et l'ensemble univers est l'élément neutre de l'intersection (comme 1 est l'élément neutre de la multiplication, et 0 est l'élément neutre de l'addition). </p>
</div>
<div key="text_set_rewriting" class="toolbox-text custom pedagogic">
 <p> Les réécritures permettent de remplacer un terme A par un autre terme B à condition de justifier l'égalite de réécriture A=B. Les propriétés algébriques connues (commutativité, associativité, ...) des opérations ensemblistes (intersection, union, ...) sont invoquées directement, sans justifier l'égalité de réécriture. </p>
</div>
<div key="text_set_union_comb">
 <!--TODO-->
</div>
<div key="text_setassociative" class="toolbox-text custom pedagogic">
 <p> L'intersection et l'union sont des opérations associatives. </p>
</div>
<div key="text_setcommutative" class="toolbox-text custom pedagogic">
 <p> L'intersection et l'union sont des opérations commutatives. </p>
</div>
<div key="text_setdevelopp" class="toolbox-text custom pedagogic">
 <p> Les opérations d'intersection et d'union sont distributives l'une sur l'autre. </p>
</div>
<div key="text_setexpr">
 <!--TODO-->
</div>
<div key="text_setfactorize" class="toolbox-text custom pedagogic">
 <p> Les opérations d'intersection et d'union sont distributives l'une sur l'autre. </p>
</div>
<div key="text_setfun" class="toolbox-text custom pedagogic">
 <p> Une fonction est une formule avec une variable x appartenant à un univers A. Cette formule, notée
  <!--{type="expr" input="app_fun f x"}--> et lue 'f de x', est un élément d'un ensemble B. Une fonction f associe donc un élément x de A à un élément y de B appelé <span class="exturl"> <a href="https://fr.wikipedia.org/wiki/Fonction_(math%C3%A9matiques_%C3%A9l%C3%A9mentaires)#Image.2C_ant.C3.A9c.C3.A9dent" target="_blank">l'image</a></span> de x par f. L'élément x est appelé <span class="exturl"> <a href="https://fr.wikipedia.org/wiki/Ant%C3%A9c%C3%A9dent_(math%C3%A9matiques)" target="_blank">l'antécédent</a></span> de y par f. Une telle fonction est déclarée par la formule 'f : A → B' lue 'f est une fonction de A vers B'. </p>
 <!--  <p>
    La nature de cette association est telle que la <span class="exturl">
      <a href="https://fr.wikipedia.org/wiki/Relation_(math%C3%A9matiques)"
   target="_blank">relation</a></span> définie sur A×B par "f(x) = y" est
    fonctionnelle : un élément de A a une et une seule image par f. Une
    fonction peut être assimilée à une relation fonctionnelle.
  </p> -->
</div>
<div key="text_setgraph" class="toolbox-text custom pedagogic">
 <p> L'ensemble des couples
  <!--{type="expr" input="upair U U x y"}--> en relation par R se note "
  <!--{type="prop" sci="true" input="gen_app_rel U U A B R x y"}-->". Cet ensemble est le <span class="stress">graphe</span> de la relation R. Le graphe est donc un sous-ensemble du <span class="exturl"> <a href="https://fr.wikipedia.org/wiki/Produit_cart%C3%A9sien" target="_blank">produit cartésien</a></span>
  <!--{type="expr" input="(pprod U (ExSet U) A B)"}-->. </p>
</div>
<div key="text_setops" class="toolbox-text custom pedagogic">
 <p>Si l'univers est l'ensemble des points du plan, on peut représenter un ensemble par l'ensemble des points à l'intérieur d'une frontière fermée, c'est à dire par une surface. Dans ce cas, on peut représenter les opérations ensemblistes par les surfaces bleues ci-dessous. </p>
</div>
<div key="text_sigma" class="toolbox-text custom pedagogic">
 <p>Les propriétés de réécriture résultent de l'associativité de l'addition et de la distributivité de la mutliplication sur l'addition.</p>
</div>
<div key="text_sigmadecompl" class="toolbox-text custom pedagogic">
</div>
<div key="text_sigmadef">
 <!--TODO-->
</div>
<div key="text_sigmaidx">
 <!--TODO-->
</div>
<div key="text_sigmainverse" class="toolbox-text custom pedagogic">
 <p>On peut inverser l'odre des éléments à additionner (par commutativité de l'addition).</p>
</div>
<div key="text_sigmalinear" class="toolbox-text custom pedagogic">
 <p>On note qu'on ne peut factoriser par
  <!--{type="expr" input="lambda"}--> ci-dessous que si
  <!--{type="expr" input="lambda"}--> ne dépend pas de k.</p>
</div>
<div key="text_sigmarem" class="toolbox-text custom pedagogic">
 <p>Les sommes remarquables sont disponibles dans les résolutions d'exercices.</p>
</div>
<div key="text_sigmaresult1">
 <!--TODO-->
</div>
<div key="text_sigmaresult2">
 <!--TODO-->
</div>
<div key="text_sigmaresult3">
 <!--TODO-->
</div>
<div key="text_sigmasimpl">
 <!--TODO-->
</div>
<div key="text_sigmaupshift" class="toolbox-text custom pedagogic">
 <p>Décalage de l'indice de la valeur sommée (de 1 en plus ou en moins).</p>
</div>
<div key="text_simpl" class="toolbox-text custom simpl">
 <p></p>
</div>
<div key="text_slim_def_elim">
 <!--TODO-->
</div>
<div key="text_slim_inf_def_elim">
 <!--TODO-->
</div>
<div key="text_slimfinite_inf_elim">
 <!--TODO-->
</div>
<div key="text_slteq" class="toolbox-text custom pedagogic">
 <p>Un ensemble A est inclus dans un ensemble B si le fait que x est élément de A implique que x est élément de B.</p>
</div>
<div key="text_somesets" class="toolbox-text custom pedagogic">
</div>
<div key="text_sophiehattheory" class="toolbox-text custom pedagogic appdef">
 <p>Les protagonistes de cette histoire sont appelés des porteurs de chapeau.</p>
</div>
<div key="text_square_diff" class="toolbox-text custom pedagogic">
 <p>La factorisation de la différence de deux carrés est fournie par la formule : </p>
 <p>
  <!--{type="prop" sci="true" input="((pow a 2)-(pow b 2)) = ((a+b)*(a-b))"}--></p>
 <p>Par exemple :</p>
</div>
<div key="text_subadd">
 <!--TODO-->
</div>
<div key="text_trans_lt_gt" class="toolbox-text custom pedagogic">
 <p> Si a est plus grand que b, qui est plus grand que c, alors a est plus grand que c. </p>
 <p>Ces règles sont également disponibles pour les encadrements.</p>
</div>
<div key="text_true_at_rank">
 <!--TODO-->
</div>
<div key="text_truthlie">
 <!--TODO-->
</div>
<div key="text_updownsimpl">
 <!--TODO-->
</div>
<div key="text_varchange" class="toolbox-text custom pedagogic">
 <p>Un changement de variable permet de réexprimer une propostion en fonction d'une nouvelle variable de manière à ce ramener à une situation plus simple et connue.</p>
 <p>Dans l'exemple ci-dessous, l'équation en
  <!--{type="expr" input="sqrt(x)"}--> est une équation de second degré en a, si
  <!--{type="prop" sci="true" style="vertical-align:-3px;" input="a=sqrt x"}--> : </p>
</div>
<div key="text_youngest">
 <!--TODO-->
</div>
